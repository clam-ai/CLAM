{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::addColumn<QStringList>(\"expectedExtracted\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\"\n        << (QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\")\n        << (QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\"\n        << (QStringList() << \"laj/\" << \"laj/lajfile.txt\")\n        << (QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n    QTest::newRow(\"Zip Slip\") << \"zipslip.zip\"\n        << (QStringList() << \"test0.txt\" << \"../zipslip.txt\")\n        << (QStringList() << \"test0.txt\");\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid edge_sparse_csr_reader_double( const char*           i_csr_file_in,\n                                    unsigned int**        o_row_idx,\n                                    unsigned int**        o_column_idx,\n                                    double**              o_values,\n                                    unsigned int*         o_row_count,\n                                    unsigned int*         o_column_count,\n                                    unsigned int*         o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return;\n    }\n    \n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      \n      if ( l_header_read == 0 ) {\n        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n        {\n          \n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          \n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return;\n          }\n\n          \n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\n\n          \n          for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          \n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return;\n        }\n      \n      } else {\n        unsigned int l_row, l_column;\n        double l_value;\n        \n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n        \n        l_row--;\n        l_column--;\n        \n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        \n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  \n  fclose( l_csr_file_handle );\n\n  \n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return;\n  }\n\n  \n  for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n    if ( l_row_idx_id[l_i] == 0 ) {\n      (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n    }\n  }\n\n  \n  if ( l_row_idx_id != NULL ) {\n    free( l_row_idx_id );\n  }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nR_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaClassesAttribute *icattr;\n\tRBinJavaAttrInfo *attr = NULL;\n\tRBinJavaCPTypeObj *obj;\n\tut32 i = 0;\n\tut64 offset = 0, curpos;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr == NULL) {\n\t\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n\tattr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n\tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (offset + 8 > sz) {\n\t\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ticattr = R_NEW0 (RBinJavaClassesAttribute);\n\t\tif (!icattr) {\n\t\t\tbreak;\n\t\t}\n\t\ticattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags);\n\t\ticattr->file_offset = curpos;\n\t\ticattr->size = 8;\n\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx);\n\t\tif (obj == NULL) {\n\t\t\teprintf (\"BINCPLIS IS HULL %d\\n\", icattr->inner_name_idx);\n\t\t}\n\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\tif (!icattr->name) {\n\t\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx);\n\t\t\tif (!obj) {\n\t\t\t\teprintf (\"BINCPLIST IS NULL %d\\n\", icattr->inner_class_info_idx);\n\t\t\t}\n\t\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\t\tif (!icattr->name) {\n\t\t\t\ticattr->name = r_str_dup (NULL, \"NULL\");\n\t\t\t\teprintf (\"r_bin_java_inner_classes_attr: Unable to find the name for %d index.\\n\", icattr->inner_name_idx);\n\t\t\t\tfree (icattr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tIFDBG eprintf(\"r_bin_java_inner_classes_attr: Inner class name %d is %s.\\n\", icattr->inner_name_idx, icattr->name);\n\t\tr_list_append (attr->info.inner_classes_attr.classes, (void *) icattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic mif_hdr_t *mif_hdr_get(jas_stream_t *in)\n{\n\tuchar magicbuf[MIF_MAGICLEN];\n\tchar buf[4096];\n\tmif_hdr_t *hdr;\n\tbool done;\n\tjas_tvparser_t *tvp;\n\tint id;\n\n\thdr = 0;\n\ttvp = 0;\n\n\tif (jas_stream_read(in, magicbuf, MIF_MAGICLEN) != MIF_MAGICLEN) {\n\t\tgoto error;\n\t}\n\tif (magicbuf[0] != (MIF_MAGIC >> 24) || magicbuf[1] != ((MIF_MAGIC >> 16) &\n\t  0xff) || magicbuf[2] != ((MIF_MAGIC >> 8) & 0xff) || magicbuf[3] !=\n\t  (MIF_MAGIC & 0xff)) {\n\t\tjas_eprintf(\"error: bad signature\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(hdr = mif_hdr_create(0))) {\n\t\tgoto error;\n\t}\n\n\tdone = false;\n\tdo {\n\t\tif (!mif_getline(in, buf, sizeof(buf))) {\n\t\t\tjas_eprintf(\"mif_getline failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (buf[0] == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tJAS_DBGLOG(10, (\"header line: len=%d; %s\\n\", strlen(buf), buf));\n\t\tif (!(tvp = jas_tvparser_create(buf))) {\n\t\t\tjas_eprintf(\"jas_tvparser_create failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_tvparser_next(tvp)) {\n\t\t\tjas_eprintf(\"cannot get record type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tid = jas_taginfo_nonull(jas_taginfos_lookup(mif_tags2,\n\t\t  jas_tvparser_gettag(tvp)))->id;\n\t\tjas_tvparser_destroy(tvp);\n\t\ttvp = 0;\n\t\tswitch (id) {\n\t\tcase MIF_CMPT:\n\t\t\tif (mif_process_cmpt(hdr, buf)) {\n\t\t\t\tjas_eprintf(\"cannot get component information\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MIF_END:\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"invalid header information: %s\\n\", buf);\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t}\n\t} while (!done);\n\n\treturn hdr;\n\nerror:\n\tif (hdr) {\n\t\tmif_hdr_destroy(hdr);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nparse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    int *err, gchar **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n\tchar\tline[TOSHIBA_LINE_LENGTH];\n\tint\tnum_items_scanned;\n\tint\tpkt_len, pktnum, hr, min, sec, csec;\n\tchar\tchannel[10], direction[10];\n\tint\ti, hex_lines;\n\tguint8\t*pd;\n\n\t\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\n\n\tif (num_items_scanned != 7) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\n\t\treturn FALSE;\n\t}\n\n\t\n\tdo {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t\n\t\tline[16] = '\\0';\n\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n\tif (num_items_scanned != 1) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n\t\treturn FALSE;\n\t}\n\tif (pkt_len < 0) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: packet header has a negative packet length\");\n\t\treturn FALSE;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n\t\t\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\tphdr->ts.secs = hr * 3600 + min * 60 + sec;\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->caplen = pkt_len;\n\tphdr->len = pkt_len;\n\n\tswitch (channel[0]) {\n\t\tcase 'B':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = (guint8)\n\t\t\t    strtol(&channel[1], NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tsize_t newpos;\n\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\n\treturn m->pos_;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsnmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find_next(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        \n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n\n  return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ngtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileContigRoutine put = img->put.contig;\n\tuint32 row, y, nrow, nrowsub, rowstoread;\n\ttmsize_t pos;\n\tunsigned char* buf = NULL;\n\tuint32 rowsperstrip;\n\tuint16 subsamplinghor,subsamplingver;\n\tuint32 imagewidth = img->width;\n\ttmsize_t scanline;\n\tint32 fromskew, toskew;\n\tint ret = 1, flip;\n        tmsize_t maxstripsize;\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);\n\tif( subsamplingver == 0 ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Invalid vertical YCbCr subsampling\");\n\t\treturn (0);\n\t}\n\t\n\tmaxstripsize = TIFFStripSize(tif);\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(w + w);\n\t} else {\n\t\ty = 0;\n\t\ttoskew = -(int32)(w - w);\n\t}\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\n\tscanline = TIFFScanlineSize(tif);\n\tfromskew = (w < imagewidth ? imagewidth - w : 0);\n\tfor (row = 0; row < h; row += nrow)\n\t{\n\t\tuint32 temp;\n\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\tnrowsub = nrow;\n\t\tif ((nrowsub%subsamplingver)!=0)\n\t\t\tnrowsub+=subsamplingver-nrowsub%subsamplingver;\n\t\ttemp = (row + img->row_offset)%rowsperstrip + nrowsub;\n\t\tif( scanline > 0 && temp > (size_t)(TIFF_TMSIZE_T_MAX / scanline) )\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Integer overflow in gtStripContig\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (_TIFFReadEncodedStripAndAllocBuffer(tif,\n\t\t    TIFFComputeStrip(tif,row+img->row_offset, 0),\n\t\t    (void**)(&buf),\n                    maxstripsize,\n\t\t    temp * scanline)==(tmsize_t)(-1)\n\t\t    && (buf == NULL || img->stoponerr))\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline + \\\n\t\t\t((tmsize_t) img->col_offset * img->samplesperpixel);\n\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos);\n\t\ty += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nlong keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\n\t\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\t\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic __always_inline ssize_t __mcopy_atomic_hugetlb(struct mm_struct *dst_mm,\n\t\t\t\t\t      struct vm_area_struct *dst_vma,\n\t\t\t\t\t      unsigned long dst_start,\n\t\t\t\t\t      unsigned long src_start,\n\t\t\t\t\t      unsigned long len,\n\t\t\t\t\t      bool zeropage)\n{\n\tint vm_alloc_shared = dst_vma->vm_flags & VM_SHARED;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tssize_t err;\n\tpte_t *dst_pte;\n\tunsigned long src_addr, dst_addr;\n\tlong copied;\n\tstruct page *page;\n\tstruct hstate *h;\n\tunsigned long vma_hpagesize;\n\tpgoff_t idx;\n\tu32 hash;\n\tstruct address_space *mapping;\n\n\t\n\tif (zeropage) {\n\t\tup_read(&dst_mm->mmap_sem);\n\t\treturn -EINVAL;\n\t}\n\n\tsrc_addr = src_start;\n\tdst_addr = dst_start;\n\tcopied = 0;\n\tpage = NULL;\n\tvma_hpagesize = vma_kernel_pagesize(dst_vma);\n\n\t\n\terr = -EINVAL;\n\tif (dst_start & (vma_hpagesize - 1) || len & (vma_hpagesize - 1))\n\t\tgoto out_unlock;\n\nretry:\n\t\n\tif (!dst_vma) {\n\t\terr = -ENOENT;\n\t\tdst_vma = find_vma(dst_mm, dst_start);\n\t\tif (!dst_vma || !is_vm_hugetlb_page(dst_vma))\n\t\t\tgoto out_unlock;\n\t\t\n\t\tif (!dst_vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto out_unlock;\n\n\t\tif (dst_start < dst_vma->vm_start ||\n\t\t    dst_start + len > dst_vma->vm_end)\n\t\t\tgoto out_unlock;\n\n\t\terr = -EINVAL;\n\t\tif (vma_hpagesize != vma_kernel_pagesize(dst_vma))\n\t\t\tgoto out_unlock;\n\n\t\tvm_shared = dst_vma->vm_flags & VM_SHARED;\n\t}\n\n\tif (WARN_ON(dst_addr & (vma_hpagesize - 1) ||\n\t\t    (len - copied) & (vma_hpagesize - 1)))\n\t\tgoto out_unlock;\n\n\t\n\terr = -ENOMEM;\n\tif (!vm_shared) {\n\t\tif (unlikely(anon_vma_prepare(dst_vma)))\n\t\t\tgoto out_unlock;\n\t}\n\n\th = hstate_vma(dst_vma);\n\n\twhile (src_addr < src_start + len) {\n\t\tpte_t dst_pteval;\n\n\t\tBUG_ON(dst_addr >= dst_start + len);\n\t\tVM_BUG_ON(dst_addr & ~huge_page_mask(h));\n\n\t\t\n\t\tidx = linear_page_index(dst_vma, dst_addr);\n\t\tmapping = dst_vma->vm_file->f_mapping;\n\t\thash = hugetlb_fault_mutex_hash(h, dst_mm, dst_vma, mapping,\n\t\t\t\t\t\t\t\tidx, dst_addr);\n\t\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\n\t\terr = -ENOMEM;\n\t\tdst_pte = huge_pte_alloc(dst_mm, dst_addr, huge_page_size(h));\n\t\tif (!dst_pte) {\n\t\t\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terr = -EEXIST;\n\t\tdst_pteval = huge_ptep_get(dst_pte);\n\t\tif (!huge_pte_none(dst_pteval)) {\n\t\t\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terr = hugetlb_mcopy_atomic_pte(dst_mm, dst_pte, dst_vma,\n\t\t\t\t\t\tdst_addr, src_addr, &page);\n\n\t\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t\tvm_alloc_shared = vm_shared;\n\n\t\tcond_resched();\n\n\t\tif (unlikely(err == -ENOENT)) {\n\t\t\tup_read(&dst_mm->mmap_sem);\n\t\t\tBUG_ON(!page);\n\n\t\t\terr = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *)src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), true);\n\t\t\tif (unlikely(err)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdown_read(&dst_mm->mmap_sem);\n\n\t\t\tdst_vma = NULL;\n\t\t\tgoto retry;\n\t\t} else\n\t\t\tBUG_ON(page);\n\n\t\tif (!err) {\n\t\t\tdst_addr += vma_hpagesize;\n\t\t\tsrc_addr += vma_hpagesize;\n\t\t\tcopied += vma_hpagesize;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\terr = -EINTR;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\nout_unlock:\n\tup_read(&dst_mm->mmap_sem);\nout:\n\tif (page) {\n\t\t\n\t\tif (vm_alloc_shared)\n\t\t\tSetPagePrivate(page);\n\t\telse\n\t\t\tClearPagePrivate(page);\n\t\tput_page(page);\n\t}\n\tBUG_ON(copied < 0);\n\tBUG_ON(err > 0);\n\tBUG_ON(!copied && !err);\n\treturn copied ? copied : err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus SoftmaxPrepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteSoftmaxParams*>(node->builtin_data);\n  SoftmaxOpData* data = reinterpret_cast<SoftmaxOpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  if (output->type == kTfLiteInt16) {\n    TF_LITE_ENSURE(context, input->type == kTfLiteInt8 ||\n                                input->type == kTfLiteUInt8 ||\n                                input->type == kTfLiteInt16);\n  } else {\n    TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  }\n\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    switch (output->type) {\n      case kTfLiteUInt8:\n      case kTfLiteInt8:\n#ifdef TFLITE_SOFTMAX_USE_UINT16_LUT\n                             data->params.uint8_table1 = data->uint8_table1;\n        data->params.uint8_table2 = data->uint8_table2;\n        optimized_ops::PopulateSoftmaxUInt8LookupTable(\n            &data->params, input->params.scale, params->beta);\n        break;\n#endif\n      case kTfLiteInt16:\n      default:\n        data->params.table = data->table;\n        optimized_ops::PopulateSoftmaxLookupTable(\n            &data->params, input->params.scale, params->beta);\n    }\n\n    data->params.zero_point = output->params.zero_point;\n    data->params.scale = output->params.scale;\n  }\n\n  if (input->type == kTfLiteInt16) {\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);\n\n    data->params.exp_lut = data->exp_lut;\n          gen_lut([](double value) { return std::exp(value); }, -10.0, 0.0,\n            data->params.exp_lut, data->kInt16LUTArraySize);\n    data->params.one_over_one_plus_x_lut = data->one_over_one_plus_x_lut;\n    gen_lut([](double value) { return 1.0 / (1.0 + value); }, 0.0, 1.0,\n            data->params.one_over_one_plus_x_lut, data->kInt16LUTArraySize);\n    data->params.zero_point = output->params.zero_point;\n    data->params.scale = output->params.scale;\n\n    double input_scale_beta_rescale =\n        input->params.scale * params->beta /\n        (10.0 / 65535.0);                               QuantizeMultiplier(input_scale_beta_rescale, &data->params.input_multiplier,\n                       &data->params.input_left_shift);\n  }\n\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus CalculateArithmeticOpData(TfLiteContext* context, TfLiteNode* node,\n                                       OpData* data) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    static constexpr int kInputIntegerBits = 4;\n    const double input_real_multiplier =\n        static_cast<double>(input->params.scale) *\n        static_cast<double>(1 << (31 - kInputIntegerBits));\n\n    const double q = std::frexp(input_real_multiplier, &data->input_left_shift);\n    data->input_multiplier = static_cast<int32_t>(TfLiteRound(q * (1ll << 31)));\n\n    data->input_range_radius =\n        CalculateInputRadius(kInputIntegerBits, data->input_left_shift, 31);\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nString preg_quote(const String& str,\n                  const String& delimiter ) {\n  const char* in_str = str.data();\n  const char* in_str_end = in_str + str.size();\n\n  \n  if (in_str == in_str_end) {\n    return str;\n  }\n\n  char delim_char = 0;      \n  bool quote_delim = false; \n  if (!delimiter.empty()) {\n    delim_char = delimiter.charAt(0);\n    quote_delim = true;\n  }\n\n  \n  static_assert(\n    (StringData::MaxSize * 4 + 1) < std::numeric_limits<int64_t>::max()\n  );\n  String ret(4 * str.size() + 1, ReserveString);\n  char* out_str = ret.mutableData();\n\n  \n  const char* p;\n  char* q;\n  for (p = in_str, q = out_str; p != in_str_end; p++) {\n    char c = *p;\n    switch (c) {\n    case '.': case '\\\\': case '+': case '*': case '?':\n    case '[': case '^':  case ']': case '$': case '(':\n    case ')': case '{':  case '}': case '=': case '!':\n    case '>': case '<':  case '|': case ':': case '-':\n    case '#':\n      *q++ = '\\\\';\n      *q++ = c;\n      break;\n\n    case '\\0':\n      *q++ = '\\\\';\n      *q++ = '0';\n      *q++ = '0';\n      *q++ = '0';\n      break;\n\n    default:\n      if (quote_delim && c == delim_char)\n        *q++ = '\\\\';\n      *q++ = c;\n      break;\n    }\n  }\n  *q = '\\0';\n\n  return ret.setSize(q - out_str);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic bcon_error_t bson_append_bcon_with_state(bson *b, const bcon *bc, bcon_state_t start_state) {\n    bcon_error_t ret = BCON_OK;\n    bcon_state_t state = start_state;\n    char *key = 0;\n    char *typespec = 0;\n    unsigned char doc_stack[DOC_STACK_SIZE];\n    size_t doc_stack_pointer = 0;\n    size_t array_index = 0;\n    unsigned int array_index_stack[ARRAY_INDEX_STACK_SIZE];\n    size_t array_index_stack_pointer = 0;\n    char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; \n    int end_of_data;\n    const bcon *bcp;\n    for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) {\n        bcon bci = *bcp;\n        char *s = bci.s;\n        switch (state) {\n        case State_Element:\n            switch (bcon_token(s)) {\n            case Token_CloseBrace:\n                bson_append_finish_object( b );\n                DOC_POP_STATE; \n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                key = s;\n                state = State_DocSpecValue;\n                break;\n            }\n            break;\n        case State_DocSpecValue:\n            switch (bcon_token(s)) {\n            case Token_Typespec:\n                typespec = s;\n                state = State_DocValue;\n                break;\n            case Token_OpenBrace:\n                bson_append_start_object( b, key );\n                DOC_PUSH_STATE(State_Element);\n                state = State_Element;\n                break;\n            case Token_OpenBracket:\n                bson_append_start_array( b, key );\n                ARRAY_PUSH_RESET_INDEX_STATE(State_Element);\n                state = State_ArraySpecValue;\n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                ret = bson_bcon_key_value(b, key, typespec, bci);\n                state = State_Element;\n                break;\n            }\n            break;\n        case State_DocValue:\n            ret = bson_bcon_key_value(b, key, typespec, bci);\n            state = State_Element;\n            typespec = 0;\n            break;\n        case State_ArraySpecValue:\n            switch (bcon_token(s)) {\n            case Token_Typespec:\n                typespec = s;\n                state = State_ArrayValue;\n                break;\n            case Token_OpenBrace:\n                key = ARRAY_KEY_STRING(array_index++);\n                bson_append_start_object( b, key );\n                DOC_PUSH_STATE(State_ArraySpecValue);\n                state = State_Element;\n                break;\n            case Token_OpenBracket:\n                key = ARRAY_KEY_STRING(array_index++);\n                bson_append_start_array( b, key );\n                ARRAY_PUSH_RESET_INDEX_STATE(State_ArraySpecValue);\n                \n                break;\n            case Token_CloseBracket:\n                bson_append_finish_array( b );\n                ARRAY_POP_INDEX_STATE; \n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                key = ARRAY_KEY_STRING(array_index++);\n                ret = bson_bcon_key_value(b, key, typespec, bci);\n                \n                break;\n            }\n            break;\n        case State_ArrayValue:\n            key = ARRAY_KEY_STRING(array_index++);\n            ret = bson_bcon_key_value(b, key, typespec, bci);\n            state = State_ArraySpecValue;\n            typespec = 0;\n            break;\n        default: assert(NOT_REACHED); break;\n        }\n    }\n    return state == start_state ? BCON_OK : BCON_DOCUMENT_INCOMPLETE;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocessInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (char *)entity->textPtr;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  \n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif \n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE);\n\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      \n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nBOOL nego_process_negotiation_request(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->RequestedProtocols);\n\tWLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);\n\tnego->state = NEGO_STATE_FINAL;\n\treturn TRUE;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext)\n{\n    std::for_each(nodes.begin(), nodes.end(), [&ext](Proxy &x)\n    {\n        if(ext.remove_emoji)\n            x.Remark = trim(removeEmoji(x.Remark));\n\n        nodeRename(x, ext.rename_array, ext);\n\n        if(ext.add_emoji)\n            x.Remark = addEmoji(x, ext.emoji_array, ext);\n    });\n\n    if(ext.sort_flag)\n    {\n        bool failed = true;\n        if(ext.sort_script.size() && ext.authorized)\n        {\n            std::string script = ext.sort_script;\n            if(startsWith(script, \"path:\"))\n                script = fileGet(script.substr(5), false);\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                try\n                {\n                    ctx.eval(script);\n                    auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(\"compare\");\n                    auto comparer = [&](const Proxy &a, const Proxy &b)\n                    {\n                        if(a.Type == ProxyType::Unknow)\n                            return 1;\n                        if(b.Type == ProxyType::Unknow)\n                            return 0;\n                        return compare(a, b);\n                    };\n                    std::stable_sort(nodes.begin(), nodes.end(), comparer);\n                    failed = false;\n                }\n                catch(qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n        }\n        if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b)\n        {\n            return a.Remark < b.Remark;\n        });\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_nack(\n\t\t\t\t\tpjmedia_rtcp_session *session,\n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned nack_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_fb_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && nack_cnt && nack, PJ_EINVAL);\n\n    len = (3 + nack_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    \n    hdr = (pjmedia_rtcp_fb_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));\n    hdr->rtcp_common.pt = RTCP_RTPFB;\n    hdr->rtcp_common.count = 1; \n    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    \n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < nack_cnt; ++i) {\n\tpj_uint16_t val;\n\tval = pj_htons((pj_uint16_t)nack[i].pid);\n\tpj_memcpy(p, &val, 2);\n\tval = pj_htons(nack[i].blp);\n\tpj_memcpy(p+2, &val, 2);\n\tp += 4;\n    }\n\n    \n    *length = len;\n\n    return PJ_SUCCESS;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_clear(AST_object *self)\n{\n    Py_CLEAR(self->dict);\n    return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_for_arguments(struct compiling *c, const node *n)\n{\n    \n    int i, j, k, nposargs = 0, nkwonlyargs = 0;\n    int nposdefaults = 0, found_default = 0;\n    asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;\n    arg_ty vararg = NULL, kwarg = NULL;\n    arg_ty arg = NULL;\n    node *ch;\n\n    if (TYPE(n) == parameters) {\n        if (NCH(n) == 2) \n            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);\n        n = CHILD(n, 1);\n    }\n    assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);\n\n    \n    for (i = 0; i < NCH(n); i++) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == STAR) {\n            \n            i++;\n            if (i < NCH(n) && \n                (TYPE(CHILD(n, i)) == tfpdef ||\n                 TYPE(CHILD(n, i)) == vfpdef)) {\n                i++;\n            }\n            break;\n        }\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;\n        if (TYPE(ch) == EQUAL) nposdefaults++;\n    }\n    \n    for ( ; i < NCH(n); ++i) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;\n    }\n    posargs = (nposargs ? _Ta3_asdl_seq_new(nposargs, c->c_arena) : NULL);\n    if (!posargs && nposargs)\n        return NULL;\n    kwonlyargs = (nkwonlyargs ?\n                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwonlyargs && nkwonlyargs)\n        return NULL;\n    posdefaults = (nposdefaults ?\n                    _Ta3_asdl_seq_new(nposdefaults, c->c_arena) : NULL);\n    if (!posdefaults && nposdefaults)\n        return NULL;\n    \n    kwdefaults = (nkwonlyargs ?\n                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwdefaults && nkwonlyargs)\n        return NULL;\n\n    \n    i = 0;\n    j = 0;  \n    k = 0;  \n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case tfpdef:\n            case vfpdef:\n                \n                \n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        return NULL;\n                    assert(posdefaults != NULL);\n                    asdl_seq_SET(posdefaults, j++, expression);\n                    i += 2;\n                    found_default = 1;\n                }\n                else if (found_default) {\n                    ast_error(c, n,\n                             \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                arg = ast_for_arg(c, ch);\n                if (!arg)\n                    return NULL;\n                asdl_seq_SET(posargs, k++, arg);\n                i += 1; \n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case STAR:\n                if (i+1 >= NCH(n) ||\n                    (i+2 == NCH(n) && (TYPE(CHILD(n, i+1)) == COMMA\n                                       || TYPE(CHILD(n, i+1)) == TYPE_COMMENT))) {\n                    ast_error(c, CHILD(n, i),\n                        \"named arguments must follow bare *\");\n                    return NULL;\n                }\n                ch = CHILD(n, i+1);  \n                if (TYPE(ch) == COMMA) {\n                    int res = 0;\n                    i += 2; \n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        ast_error(c, CHILD(n, i),\n                                \"bare * has associated type comment\");\n                        return NULL;\n                    }\n\n                    res = handle_keywordonly_args(c, n, i,\n                                                  kwonlyargs, kwdefaults);\n                    if (res == -1) return NULL;\n                    i = res; \n                }\n                else {\n                    vararg = ast_for_arg(c, ch);\n                    if (!vararg)\n                        return NULL;\n\n                    i += 2; \n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                        i += 1; \n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        vararg->type_comment = NEW_TYPE_COMMENT(CHILD(n, i));\n                        if (!vararg->type_comment)\n                            return NULL;\n                        i += 1;\n                    }\n\n                    if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef\n                                    || TYPE(CHILD(n, i)) == vfpdef)) {\n                        int res = 0;\n                        res = handle_keywordonly_args(c, n, i,\n                                                      kwonlyargs, kwdefaults);\n                        if (res == -1) return NULL;\n                        i = res; \n                    }\n                }\n                break;\n            case DOUBLESTAR:\n                ch = CHILD(n, i+1);  \n                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);\n                kwarg = ast_for_arg(c, ch);\n                if (!kwarg)\n                    return NULL;\n                i += 2; \n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                assert(i);\n\n                if (kwarg)\n                    arg = kwarg;\n\n                \n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    return NULL;\n                i += 1;\n                break;\n            default:\n                PyErr_Format(PyExc_SystemError,\n                             \"unexpected node in varargslist: %d @ %d\",\n                             TYPE(ch), i);\n                return NULL;\n        }\n    }\n    return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void set_fdc(int drive)\n{\n\tunsigned int new_fdc = fdc;\n\n\tif (drive >= 0 && drive < N_DRIVE) {\n\t\tnew_fdc = FDC(drive);\n\t\tcurrent_drive = drive;\n\t}\n\tif (new_fdc >= N_FDC) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\tfdc = new_fdc;\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (FDCS->rawcmd == 2)\n\t\treset_fdc_info(1);\n\tif (fd_inb(FD_STATUS) != STATUS_READY)\n\t\tFDCS->reset = 1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n\n  auto* params = reinterpret_cast<TfLiteL2NormParams*>(node->builtin_data);\n  L2NormalizationParams* data =\n      static_cast<L2NormalizationParams*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n\n  TF_LITE_ENSURE(context, NumDimensions(input) <= 4);\n\n  TF_LITE_ENSURE(context, output->type == kTfLiteFloat32 ||\n                              output->type == kTfLiteUInt8 ||\n                              output->type == kTfLiteInt8);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8) {\n    data->input_zero_point = input->params.zero_point;\n  } else if (output->type == kTfLiteFloat32) {\n    data->input_zero_point = 0;\n  }\n\n    TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int futex_wait_requeue_pi(u32 __user *uaddr, int fshared,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t int clockrt, u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct rt_mutex *pi_mutex = NULL;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2;\n\tstruct futex_q q;\n\tint res, ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t\n\tdebug_rt_mutex_init_waiter(&rt_waiter);\n\trt_waiter.task = NULL;\n\n\tkey2 = FUTEX_KEY_INIT;\n\tret = get_futex_key(uaddr2, fshared, &key2);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t\n\n\t\n\tif (!q.rt_waiter) {\n\t\t\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current,\n\t\t\t\t\t\t   fshared);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\t\n\t\tWARN_ON(!&q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\t\n\t\tres = fixup_owner(uaddr2, fshared, &q, !ret);\n\t\t\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t\n\t\tunqueue_me_pi(&q);\n\t}\n\n\t\n\tif (ret == -EFAULT) {\n\t\tif (rt_mutex_owner(pi_mutex) == current)\n\t\t\trt_mutex_unlock(pi_mutex);\n\t} else if (ret == -EINTR) {\n\t\t\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(fshared, &q.key);\nout_key2:\n\tput_futex_key(fshared, &key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nparse_tag(char **s, int internal)\n{\n    struct parsed_tag *tag = NULL;\n    int tag_id;\n    char tagname[MAX_TAG_LEN], attrname[MAX_TAG_LEN];\n    char *p, *q;\n    int i, attr_id = 0, nattr;\n\n    \n    tagname[0] = '\\0';\n    q = (*s) + 1;\n    p = tagname;\n    if (*q == '/') {\n\t*(p++) = *(q++);\n\tSKIP_BLANKS(q);\n    }\n    while (*q && !IS_SPACE(*q) && !(tagname[0] != '/' && *q == '/') &&\n\t   *q != '>' && p - tagname < MAX_TAG_LEN - 1) {\n\t*(p++) = TOLOWER(*q);\n\tq++;\n    }\n    *p = '\\0';\n    while (*q && !IS_SPACE(*q) && !(tagname[0] != '/' && *q == '/') &&\n\t   *q != '>')\n\tq++;\n\n    tag_id = getHash_si(&tagtable, tagname, HTML_UNKNOWN);\n\n    if (tag_id == HTML_UNKNOWN ||\n\t(!internal && TagMAP[tag_id].flag & TFLG_INT))\n\tgoto skip_parse_tagarg;\n\n    tag = New(struct parsed_tag);\n    bzero(tag, sizeof(struct parsed_tag));\n    tag->tagid = tag_id;\n\n    if ((nattr = TagMAP[tag_id].max_attribute) > 0) {\n\ttag->attrid = NewAtom_N(unsigned char, nattr);\n\ttag->value = New_N(char *, nattr);\n\ttag->map = NewAtom_N(unsigned char, MAX_TAGATTR);\n\tmemset(tag->map, MAX_TAGATTR, MAX_TAGATTR);\n\tmemset(tag->attrid, ATTR_UNKNOWN, nattr);\n\tfor (i = 0; i < nattr; i++)\n\t    tag->map[TagMAP[tag_id].accept_attribute[i]] = i;\n    }\n\n    \n    SKIP_BLANKS(q);\n    while (1) {\n       Str value = NULL, value_tmp = NULL;\n\tif (*q == '>' || *q == '\\0')\n\t    goto done_parse_tag;\n\tp = attrname;\n\twhile (*q && *q != '=' && !IS_SPACE(*q) &&\n\t       *q != '>' && p - attrname < MAX_TAG_LEN - 1) {\n\t    *(p++) = TOLOWER(*q);\n\t    q++;\n\t}\n\t*p = '\\0';\n\twhile (*q && *q != '=' && !IS_SPACE(*q) && *q != '>')\n\t    q++;\n\tSKIP_BLANKS(q);\n\tif (*q == '=') {\n\t    \n\t    value_tmp = Strnew();\n\t    q++;\n\t    SKIP_BLANKS(q);\n\t    if (*q == '\"') {\n\t\tq++;\n\t\twhile (*q && *q != '\"') {\n\t\t    Strcat_char(value_tmp, *q);\n\t\t    if (!tag->need_reconstruct && is_html_quote(*q))\n\t\t\ttag->need_reconstruct = TRUE;\n\t\t    q++;\n\t\t}\n\t\tif (*q == '\"')\n\t\t    q++;\n\t    }\n\t    else if (*q == '\\'') {\n\t\tq++;\n\t\twhile (*q && *q != '\\'') {\n\t\t    Strcat_char(value_tmp, *q);\n\t\t    if (!tag->need_reconstruct && is_html_quote(*q))\n\t\t\ttag->need_reconstruct = TRUE;\n\t\t    q++;\n\t\t}\n\t\tif (*q == '\\'')\n\t\t    q++;\n\t    }\n\t    else if (*q) {\n\t\twhile (*q && !IS_SPACE(*q) && *q != '>') {\n                   Strcat_char(value_tmp, *q);\n\t\t    if (!tag->need_reconstruct && is_html_quote(*q))\n\t\t\ttag->need_reconstruct = TRUE;\n\t\t    q++;\n\t\t}\n\t    }\n\t}\n\tfor (i = 0; i < nattr; i++) {\n\t    if ((tag)->attrid[i] == ATTR_UNKNOWN &&\n\t\tstrcmp(AttrMAP[TagMAP[tag_id].accept_attribute[i]].name,\n\t\t       attrname) == 0) {\n\t\tattr_id = TagMAP[tag_id].accept_attribute[i];\n\t\tbreak;\n\t    }\n\t}\n\n       if (value_tmp) {\n         int j, hidden=FALSE;\n         for (j=0; j<i; j++) {\n           if (tag->attrid[j] == ATTR_TYPE &&\n               tag->value[j] &&\n               strcmp(\"hidden\",tag->value[j]) == 0) {\n             hidden=TRUE;\n             break;\n           }\n         }\n         if ((tag_id == HTML_INPUT || tag_id == HTML_INPUT_ALT) &&\n             attr_id == ATTR_VALUE && hidden) {\n           value = value_tmp;\n         } else {\n           char *x;\n           value = Strnew();\n           for (x = value_tmp->ptr; *x; x++) {\n             if (*x != '\\n')\n               Strcat_char(value, *x);\n           }\n         }\n       }\n\n\tif (i != nattr) {\n\t    if (!internal &&\n\t\t((AttrMAP[attr_id].flag & AFLG_INT) ||\n\t\t (value && AttrMAP[attr_id].vtype == VTYPE_METHOD &&\n\t\t  !strcasecmp(value->ptr, \"internal\")))) {\n\t\ttag->need_reconstruct = TRUE;\n\t\tcontinue;\n\t    }\n\t    tag->attrid[i] = attr_id;\n\t    if (value)\n\t\ttag->value[i] = html_unquote(value->ptr);\n\t    else\n\t\ttag->value[i] = NULL;\n\t}\n\telse {\n\t    tag->need_reconstruct = TRUE;\n\t}\n    }\n\n  skip_parse_tagarg:\n    while (*q != '>' && *q)\n\tq++;\n  done_parse_tag:\n    if (*q == '>')\n\tq++;\n    *s = q;\n    return tag;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid jas_matrix_asl(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t\t\t\t*data = jas_seqent_asl(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,\n\t\t\t\t\t  u32 *mask)\n{\n\tstruct crypto_attr_type *algt;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn false;\n\n\t*type |= algt->type & CRYPTO_ALG_INTERNAL;\n\t*mask |= algt->mask & CRYPTO_ALG_INTERNAL;\n\n\tif (*type & *mask & CRYPTO_ALG_INTERNAL)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nAsyncSocket::WriteResult AsyncSSLSocket::performWrite(\n    const iovec* vec,\n    uint32_t count,\n    WriteFlags flags,\n    uint32_t* countWritten,\n    uint32_t* partialWritten) {\n  if (sslState_ == STATE_UNENCRYPTED) {\n    return AsyncSocket::performWrite(\n        vec, count, flags, countWritten, partialWritten);\n  }\n  if (sslState_ != STATE_ESTABLISHED) {\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): \"\n               << \"TODO: AsyncSSLSocket currently does not support calling \"\n               << \"write() before the handshake has fully completed\";\n    return WriteResult(\n        WRITE_ERROR, std::make_unique<SSLException>(SSLError::EARLY_WRITE));\n  }\n\n     char* combinedBuf{nullptr};\n  SCOPE_EXIT {\n       if (combinedBuf != nullptr && minWriteSize_ > MAX_STACK_BUF_SIZE) {\n      delete[] combinedBuf;\n    }\n  };\n\n  *countWritten = 0;\n  *partialWritten = 0;\n  ssize_t totalWritten = 0;\n  size_t bytesStolenFromNextBuffer = 0;\n  for (uint32_t i = 0; i < count; i++) {\n    const iovec* v = vec + i;\n    size_t offset = bytesStolenFromNextBuffer;\n    bytesStolenFromNextBuffer = 0;\n    size_t len = v->iov_len - offset;\n    const void* buf;\n    if (len == 0) {\n      (*countWritten)++;\n      continue;\n    }\n    buf = ((const char*)v->iov_base) + offset;\n\n    ssize_t bytes;\n    uint32_t buffersStolen = 0;\n    auto sslWriteBuf = buf;\n    if ((len < minWriteSize_) && ((i + 1) < count)) {\n                                        \n      if (combinedBuf == nullptr) {\n        if (minWriteSize_ > MAX_STACK_BUF_SIZE) {\n                   combinedBuf = new char[minWriteSize_];\n        } else {\n                   combinedBuf = (char*)alloca(minWriteSize_);\n        }\n      }\n      assert(combinedBuf != nullptr);\n      sslWriteBuf = combinedBuf;\n\n      memcpy(combinedBuf, buf, len);\n      do {\n               uint32_t nextIndex = i + buffersStolen + 1;\n        bytesStolenFromNextBuffer =\n            std::min(vec[nextIndex].iov_len, minWriteSize_ - len);\n        if (bytesStolenFromNextBuffer > 0) {\n          assert(vec[nextIndex].iov_base != nullptr);\n          ::memcpy(\n              combinedBuf + len,\n              vec[nextIndex].iov_base,\n              bytesStolenFromNextBuffer);\n        }\n        len += bytesStolenFromNextBuffer;\n        if (bytesStolenFromNextBuffer < vec[nextIndex].iov_len) {\n                   break;\n        } else {\n          bytesStolenFromNextBuffer = 0;\n          buffersStolen++;\n        }\n      } while ((i + buffersStolen + 1) < count && (len < minWriteSize_));\n    }\n\n       if (bytesStolenFromNextBuffer == 0) {\n      while ((i + buffersStolen + 1) < count &&\n             vec[i + buffersStolen + 1].iov_len == 0) {\n        buffersStolen++;\n      }\n    }\n\n          corkCurrentWrite_ =\n        isSet(flags, WriteFlags::CORK) || (i + buffersStolen + 1 < count);\n\n             appEorByteWriteFlags_ = flags & kEorRelevantWriteFlags;\n    bool trackEor = appEorByteWriteFlags_ != folly::WriteFlags::NONE &&\n        (i + buffersStolen + 1 == count);\n    bytes = eorAwareSSLWrite(ssl_, sslWriteBuf, int(len), trackEor);\n\n    if (bytes <= 0) {\n      int error = SSL_get_error(ssl_.get(), int(bytes));\n      if (error == SSL_ERROR_WANT_WRITE) {\n               *partialWritten = uint32_t(offset);\n        return WriteResult(totalWritten);\n      }\n      auto writeResult = interpretSSLError(int(bytes), error);\n      if (writeResult.writeReturn < 0) {\n        return writeResult;\n      }    }\n\n    totalWritten += bytes;\n\n    if (bytes == (ssize_t)len) {\n           (*countWritten) += 1 + buffersStolen;\n      i += buffersStolen;\n         } else {\n      bytes += offset;      while (bytes >= (ssize_t)v->iov_len) {\n                             bytes -= v->iov_len;\n        (*countWritten)++;\n        v = &(vec[++i]);\n      }\n      *partialWritten = uint32_t(bytes);\n      return WriteResult(totalWritten);\n    }\n  }\n\n  return WriteResult(totalWritten);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus CalculateArithmeticOpData(TfLiteContext* context, TfLiteNode* node,\n                                       OpData* data) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (input->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point,\n                      std::numeric_limits<int8_t>::min());\n\n    static constexpr int kInputIntegerBits = 4;\n    const double input_real_multiplier =\n        static_cast<double>(input->params.scale) *\n        static_cast<double>(1 << (31 - kInputIntegerBits));\n\n    data->input_zero_point = input->params.zero_point;\n\n    const double q = std::frexp(input_real_multiplier, &data->input_left_shift);\n    data->input_multiplier = static_cast<int32_t>(TfLiteRound(q * (1ll << 31)));\n\n    data->input_range_radius =\n        CalculateInputRadius(kInputIntegerBits, data->input_left_shift, 31);\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstruct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_options_received tcp_opt;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint mss;\n\tstruct dst_entry *dst;\n\t__u8 rcv_wscale;\n\n\tif (!sysctl_tcp_syncookies || !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk))\n\t\tgoto out;\n\n\tmss = __cookie_v6_check(ipv6_hdr(skb), th, cookie);\n\tif (mss == 0) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t\n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(skb, &tcp_opt, 0, NULL);\n\n\tif (!cookie_timestamp_decode(&tcp_opt))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = inet_reqsk_alloc(&tcp6_request_sock_ops, sk, false);\n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n\ttreq = tcp_rsk(req);\n\ttreq->tfo_listener = false;\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto out_free;\n\n\treq->mss = mss;\n\tireq->ir_rmt_port = th->source;\n\tireq->ir_num = ntohs(th->dest);\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\tif (ipv6_opt_accepted(sk, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t    np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\n\t    np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n\n\tireq->ir_iif = sk->sk_bound_dev_if;\n\t\n\tif (!sk->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tireq->ir_mark = inet_request_mark(sk, skb);\n\n\treq->num_retrans = 0;\n\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\ttreq->snt_synack.v64\t= 0;\n\ttreq->rcv_isn = ntohl(th->seq) - 1;\n\ttreq->snt_isn = cookie;\n\n\t\n\t{\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_TCP;\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\t\tfl6.saddr = ireq->ir_v6_loc_addr;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = ireq->ir_mark;\n\t\tfl6.fl6_dport = ireq->ir_rmt_port;\n\t\tfl6.fl6_sport = inet_sk(sk)->inet_sport;\n\t\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out_free;\n\t}\n\n\treq->rsk_window_clamp = tp->window_clamp ? :dst_metric(dst, RTAX_WINDOW);\n\ttcp_select_initial_window(tcp_full_space(sk), req->mss,\n\t\t\t\t  &req->rsk_rcv_wnd, &req->rsk_window_clamp,\n\t\t\t\t  ireq->wscale_ok, &rcv_wscale,\n\t\t\t\t  dst_metric(dst, RTAX_INITRWND));\n\n\tireq->rcv_wscale = rcv_wscale;\n\tireq->ecn_ok = cookie_ecn_ok(&tcp_opt, sock_net(sk), dst);\n\n\tret = tcp_get_cookie_sock(sk, skb, req, dst);\nout:\n\treturn ret;\nout_free:\n\treqsk_free(req);\n\treturn NULL;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstruct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb,\n\t\t\t     struct ip_options *opt)\n{\n\tstruct tcp_options_received tcp_opt;\n\tu8 *hash_location;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint mss;\n\tstruct rtable *rt;\n\t__u8 rcv_wscale;\n\tbool ecn_ok;\n\n\tif (!sysctl_tcp_syncookies || !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk) ||\n\t    (mss = cookie_check(skb, cookie)) == 0) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t\n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(skb, &tcp_opt, &hash_location, 0);\n\n\tif (!cookie_check_timestamp(&tcp_opt, &ecn_ok))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = inet_reqsk_alloc(&tcp_request_sock_ops); \n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n\ttreq = tcp_rsk(req);\n\ttreq->rcv_isn\t\t= ntohl(th->seq) - 1;\n\ttreq->snt_isn\t\t= cookie;\n\treq->mss\t\t= mss;\n\tireq->loc_port\t\t= th->dest;\n\tireq->rmt_port\t\t= th->source;\n\tireq->loc_addr\t\t= ip_hdr(skb)->daddr;\n\tireq->rmt_addr\t\t= ip_hdr(skb)->saddr;\n\tireq->ecn_ok\t\t= ecn_ok;\n\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\n\t\n\tif (opt && opt->optlen) {\n\t\tint opt_size = sizeof(struct ip_options_rcu) + opt->optlen;\n\n\t\tireq->opt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (ireq->opt != NULL && ip_options_echo(&ireq->opt->opt, skb)) {\n\t\t\tkfree(ireq->opt);\n\t\t\tireq->opt = NULL;\n\t\t}\n\t}\n\n\tif (security_inet_conn_request(sk, skb, req)) {\n\t\treqsk_free(req);\n\t\tgoto out;\n\t}\n\n\treq->expires\t= 0UL;\n\treq->retrans\t= 0;\n\n\t\n\t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, 0, sk->sk_mark, RT_CONN_FLAGS(sk),\n\t\t\t\t   RT_SCOPE_UNIVERSE, IPPROTO_TCP,\n\t\t\t\t   inet_sk_flowi_flags(sk),\n\t\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t\t   ireq->loc_addr, th->source, th->dest);\n\t\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt)) {\n\t\t\treqsk_free(req);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t\n\treq->window_clamp = tp->window_clamp ? :dst_metric(&rt->dst, RTAX_WINDOW);\n\n\ttcp_select_initial_window(tcp_full_space(sk), req->mss,\n\t\t\t\t  &req->rcv_wnd, &req->window_clamp,\n\t\t\t\t  ireq->wscale_ok, &rcv_wscale,\n\t\t\t\t  dst_metric(&rt->dst, RTAX_INITRWND));\n\n\tireq->rcv_wscale  = rcv_wscale;\n\n\tret = get_cookie_sock(sk, skb, req, &rt->dst);\nout:\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\n\tR_FREE (prelink_range);\n\n\t*bin_obj = obj;\n\n\tr_list_push (pending_bin_files, bf);\n\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tif (obj) {\n\t\tobj->cache_buf = NULL;\n\t}\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmcs_recv_connect_response(STREAM mcs_data)\n{\n\tUNUSED(mcs_data);\n\tuint8 result;\n\tuint32 length;\n\tSTREAM s;\n\tstruct stream packet;\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\t\n\tpacket = *s;\n\n\tber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\n\n\tber_parse_header(s, BER_TAG_RESULT, &length);\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);\n\t\treturn False;\n\t}\n\n\tber_parse_header(s, BER_TAG_INTEGER, &length);\n\tin_uint8s(s, length);\t\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\trdp_protocol_error(\"mcs_recv_connect_response(), consume connect id from stream would overrun\", &packet);\n\t}\n\n\tmcs_parse_domain_params(s);\n\n\tber_parse_header(s, BER_TAG_OCTET_STRING, &length);\n\n\tsec_process_mcs_data(s);\n\t\n\treturn s_check_end(s);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n\n    \n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n\n    if( (*p) > end - len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    \n    *p += len;\n    ret = 0;\n\n    return( ret );\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic RFlagsAtOffset* r_flag_get_nearest_list(RFlag *f, ut64 off, int dir) {\n\tRFlagsAtOffset *flags = NULL;\n\tRFlagsAtOffset key;\n\tkey.off = off;\n\tif (dir >= 0) {\n\t\tflags = r_skiplist_get_geq (f->by_off, &key);\n\t} else {\n\t\tflags = r_skiplist_get_leq (f->by_off, &key);\n\t}\n\tif (dir == 0 && flags && flags->off != off) {\n\t\treturn NULL;\n\t}\n\treturn flags;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\n\tRETURN_TRUE;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\t\n\tpmd_t pmdval = *pmd;\n\t\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n\t\tucounts = NULL;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsnmp_ber_decode_length(snmp_packet_t *snmp_packet, uint8_t *length)\n{\n  if(snmp_packet->used == 0) {\n    return 0;\n  }\n\n  *length = *snmp_packet->in++;\n  snmp_packet->used--;\n\n  return 1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART) {\n        data->num_of_part++;\n    }\n\n    return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstruct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg(&inet6_sk(sk)->opt, opt);\n\tsk_dst_reset(sk);\n\n\treturn opt;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteAudioSpectrogramParams*>(node->user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE(context, params->spectrogram->Initialize(params->window_size,\n                                                          params->stride));\n\n  const float* input_data = GetTensorData<float>(input);\n\n  const int64_t sample_count = input->dims->data[0];\n  const int64_t channel_count = input->dims->data[1];\n\n  const int64_t output_width = params->spectrogram->output_frequency_channels();\n\n  float* output_flat = GetTensorData<float>(output);\n\n  std::vector<float> input_for_channel(sample_count);\n  for (int64_t channel = 0; channel < channel_count; ++channel) {\n    float* output_slice =\n        output_flat + (channel * params->output_height * output_width);\n    for (int i = 0; i < sample_count; ++i) {\n      input_for_channel[i] = input_data[i * channel_count + channel];\n    }\n    std::vector<std::vector<float>> spectrogram_output;\n    TF_LITE_ENSURE(context,\n                   params->spectrogram->ComputeSquaredMagnitudeSpectrogram(\n                       input_for_channel, &spectrogram_output));\n    TF_LITE_ENSURE_EQ(context, spectrogram_output.size(),\n                      params->output_height);\n    TF_LITE_ENSURE(context, spectrogram_output.empty() ||\n                                (spectrogram_output[0].size() == output_width));\n    for (int row_index = 0; row_index < params->output_height; ++row_index) {\n      const std::vector<float>& spectrogram_row = spectrogram_output[row_index];\n      TF_LITE_ENSURE_EQ(context, spectrogram_row.size(), output_width);\n      float* output_row = output_slice + (row_index * output_width);\n      if (params->magnitude_squared) {\n        for (int i = 0; i < output_width; ++i) {\n          output_row[i] = spectrogram_row[i];\n        }\n      } else {\n        for (int i = 0; i < output_width; ++i) {\n          output_row[i] = sqrtf(spectrogram_row[i]);\n        }\n      }\n    }\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const CTCBeamSearchDecoderParams* option =\n      reinterpret_cast<CTCBeamSearchDecoderParams*>(node->user_data);\n  const int top_paths = option->top_paths;\n  TF_LITE_ENSURE(context, option->beam_width >= top_paths);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n   TF_LITE_ENSURE_EQ(context, NumOutputs(node), 3 * top_paths + 1);\n\n  const TfLiteTensor* inputs;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputsTensor, &inputs));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(inputs), 3);\n   TF_LITE_ENSURE_EQ(context, inputs->type, kTfLiteFloat32);\n  const int batch_size = SizeOfDimension(inputs, 1);\n\n  const TfLiteTensor* sequence_length;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kSequenceLengthTensor,\n                                          &sequence_length));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(sequence_length), 1);\n  TF_LITE_ENSURE_EQ(context, NumElements(sequence_length), batch_size);\n   TF_LITE_ENSURE_EQ(context, sequence_length->type, kTfLiteInt32);\n\n    for (int i = 0; i < top_paths; ++i) {\n    TfLiteTensor* indices;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &indices));\n    SetTensorToDynamic(indices);\n    TfLiteTensor* values;\n    TF_LITE_ENSURE_OK(context,\n                      GetOutputSafe(context, node, i + top_paths, &values));\n    SetTensorToDynamic(values);\n    TfLiteTensor* output_shape;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i + 2 * top_paths,\n                                             &output_shape));\n    SetTensorToDynamic(output_shape);\n  }\n\n   TfLiteTensor* log_probability_output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, top_paths * 3,\n                                           &log_probability_output));\n  TfLiteIntArray* log_probability_output_shape_array = TfLiteIntArrayCreate(2);\n  log_probability_output_shape_array->data[0] = batch_size;\n  log_probability_output_shape_array->data[1] = top_paths;\n  return context->ResizeTensor(context, log_probability_output,\n                               log_probability_output_shape_array);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\n\tlist_del(&info->list);\n\n\tset_info_for_irq(irq, NULL);\n\n\tWARN_ON(info->refcnt > 0);\n\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\n\tkfree(info);\n\n\t\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\n\tirq_free_desc(irq);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_for_for_stmt(struct compiling *c, const node *n0, bool is_async)\n{\n    const node * const n = is_async ? CHILD(n0, 1) : n0;\n    asdl_seq *_target, *seq = NULL, *suite_seq;\n    expr_ty expression;\n    expr_ty target, first;\n    const node *node_target;\n    int end_lineno, end_col_offset;\n    \n    REQ(n, for_stmt);\n\n    if (NCH(n) == 9) {\n        seq = ast_for_suite(c, CHILD(n, 8));\n        if (!seq)\n            return NULL;\n    }\n\n    node_target = CHILD(n, 1);\n    _target = ast_for_exprlist(c, node_target, Store);\n    if (!_target)\n        return NULL;\n    \n    first = (expr_ty)asdl_seq_GET(_target, 0);\n    if (NCH(node_target) == 1)\n        target = first;\n    else\n        target = Tuple(_target, Store, first->lineno, first->col_offset,\n                       node_target->n_end_lineno, node_target->n_end_col_offset,\n                       c->c_arena);\n\n    expression = ast_for_testlist(c, CHILD(n, 3));\n    if (!expression)\n        return NULL;\n    suite_seq = ast_for_suite(c, CHILD(n, 5));\n    if (!suite_seq)\n        return NULL;\n\n    if (seq != NULL) {\n        get_last_end_pos(seq, &end_lineno, &end_col_offset);\n    } else {\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n    }\n    if (is_async)\n        return AsyncFor(target, expression, suite_seq, seq,\n                        LINENO(n0), n0->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    else\n        return For(target, expression, suite_seq, seq,\n                   LINENO(n), n->n_col_offset,\n                   end_lineno, end_col_offset, c->c_arena);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ndecode_bytes_with_escapes(struct compiling *c, const node *n, const char *s,\n                          size_t len)\n{\n    const char *first_invalid_escape;\n    PyObject *result = _PyBytes_DecodeEscape(s, len, NULL, 0, NULL,\n                                             &first_invalid_escape);\n    if (result == NULL)\n        return NULL;\n\n    if (first_invalid_escape != NULL) {\n        if (warn_invalid_escape_sequence(c, n, *first_invalid_escape) < 0) {\n            Py_DECREF(result);\n            return NULL;\n        }\n    }\n    return result;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  const String& setSize(int64_t len) {\n    assertx(m_str);\n    m_str->setSize(len);\n    return *this;\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nrdp_protocol_error(const char *message, STREAM s)\n{\n\tlogger(Protocol, Error, \"%s(), %s\", __func__, message);\n\tif (s)\n\t\thexdump(s->p, s_length(s));\n\texit(0);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n\t\t\tstruct oz_multiple_fixed *body =\n\t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n\t\t\tu8 *data = body->data;\n\t\t\tunsigned int n;\n\t\t\tif (!body->unit_size ||\n\t\t\t\tlen < sizeof(struct oz_multiple_fixed) - 1)\n\t\t\t\tbreak;\n\t\t\tn = (len - (sizeof(struct oz_multiple_fixed) - 1))\n\t\t\t\t/ body->unit_size;\n\t\t\twhile (n--) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nGF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\n\tif ((entry->type != GF_ISOM_BOX_TYPE_URL) && (entry->type != GF_QT_BOX_TYPE_ALIS) )\n\t\treturn GF_NOT_SUPPORTED;\n\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint ip_options_get(struct net *net, struct ip_options_rcu **optp,\n\t\t   unsigned char *data, int optlen)\n{\n\tstruct ip_options_rcu *opt = ip_options_get_alloc(optlen);\n\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen)\n\t\tmemcpy(opt->opt.__data, data, optlen);\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic Jsi_RC jsi_ArrayConcatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, argc, nsiz;\n    Jsi_Obj *obj, *nobj;\n    Jsi_Value *va;\n\n    obj = _this->d.obj;\n    \n    argc = Jsi_ValueGetLength(interp, args);\n    curlen = jsi_SizeOfArray(interp, obj);\n    Jsi_ObjListifyArray(interp, obj);\n   \n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrMaxSize;\n    if (nsiz<=0) nsiz = 100;\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz+1) <= 0) {\n        rc = JSI_ERROR;\n        Jsi_LogError(\"index too large: %d\", nsiz+1);\n        goto bail;\n    }\n\n    int i, j, m;\n    for (i = 0; i<curlen; i++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[i] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+i, obj->arr[i]);\n    }\n    m = i;\n    for (i = 0; i < argc; i++) {\n         va = Jsi_ValueArrayIndex(interp, args, i);\n         if (va->vt == JSI_VT_OBJECT && Jsi_ObjIsArray(interp, va->d.obj)) {\n            int margc = Jsi_ValueGetLength(interp, va);\n            Jsi_Obj *mobj = va->d.obj;\n            Jsi_ObjListifyArray(interp, mobj);\n            if (Jsi_ObjArraySizer(interp, nobj, curlen += margc) <= 0) {\n                rc = JSI_ERROR;\n                Jsi_LogError(\"index too large: %d\", curlen);\n                goto bail;\n            }\n            for (j = 0; j<margc; j++, m++)\n            {\n                if (!mobj->arr[j]) continue;\n                nobj->arr[m] = NULL;\n                Jsi_ValueDup2(interp, nobj->arr+m, mobj->arr[j]);\n            }\n        } else {\n            if (Jsi_ObjArraySizer(interp, nobj, ++curlen) <= 0) {\n                rc = JSI_ERROR;\n                Jsi_LogError(\"index too large: %d\", curlen);\n                goto bail;\n            }\n            nobj->arr[m] = NULL;\n            Jsi_ValueDup2(interp, nobj->arr+m++, va);\n       }\n    }\n    Jsi_ObjSetLength(interp, nobj, curlen);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return JSI_OK;\n        \nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic TEE_Result utee_param_to_param(struct user_ta_ctx *utc,\n\t\t\t\t      struct tee_ta_param *p,\n\t\t\t\t      struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\t\tuint32_t flags = TEE_MEMORY_ACCESS_READ |\n\t\t\t\t TEE_MEMORY_ACCESS_ANY_OWNER;\n\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tflags |= TEE_MEMORY_ACCESS_WRITE;\n\t\t\t\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tif (tee_mmu_check_access_rights(utc, flags, a, b))\n\t\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void CreateNgrams(const tstring* data, tstring* output, int num_ngrams,\n                    int ngram_width) const {\n    for (int ngram_index = 0; ngram_index < num_ngrams; ++ngram_index) {\n      int pad_width = get_pad_width(ngram_width);\n      int left_padding = std::max(0, pad_width - ngram_index);\n      int right_padding =\n          std::max(0, pad_width - (num_ngrams - (ngram_index + 1)));\n      int num_tokens = ngram_width - (left_padding + right_padding);\n      int data_start_index = left_padding > 0 ? 0 : ngram_index - pad_width;\n\n                int ngram_size = 0;\n           ngram_size += left_padding * left_pad_.length();\n           for (int n = 0; n < num_tokens; ++n) {\n        ngram_size += data[data_start_index + n].length();\n      }\n           ngram_size += right_padding * right_pad_.length();\n           int num_separators = left_padding + right_padding + num_tokens - 1;\n      ngram_size += num_separators * separator_.length();\n\n           tstring* ngram = &output[ngram_index];\n      ngram->reserve(ngram_size);\n      for (int n = 0; n < left_padding; ++n) {\n        ngram->append(left_pad_);\n        ngram->append(separator_);\n      }\n      for (int n = 0; n < num_tokens - 1; ++n) {\n        ngram->append(data[data_start_index + n]);\n        ngram->append(separator_);\n      }\n      ngram->append(data[data_start_index + num_tokens - 1]);\n      for (int n = 0; n < right_padding; ++n) {\n        ngram->append(separator_);\n        ngram->append(right_pad_);\n      }\n\n                DCHECK_EQ(ngram_size, ngram->size());\n    }\n  }\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {\n    int j, loops = server.cronloops++;\n    REDIS_NOTUSED(eventLoop);\n    REDIS_NOTUSED(id);\n    REDIS_NOTUSED(clientData);\n\n    \n    server.unixtime = time(NULL);\n    \n    updateLRUClock();\n\n    \n    if (server.shutdown_asap) {\n        if (prepareForShutdown() == REDIS_OK) exit(0);\n        redisLog(REDIS_WARNING,\"SIGTERM received but errors trying to shut down the server, check the logs for more information\");\n    }\n\n    \n    for (j = 0; j < server.dbnum; j++) {\n        long long size, used, vkeys;\n\n        size = dictSlots(server.db[j].dict);\n        used = dictSize(server.db[j].dict);\n        vkeys = dictSize(server.db[j].expires);\n        if (!(loops % 50) && (used || vkeys)) {\n            redisLog(REDIS_VERBOSE,\"DB %d: %lld keys (%lld volatile) in %lld slots HT.\",j,used,vkeys,size);\n            \n        }\n    }\n\n    \n    if (server.bgsavechildpid == -1 && server.bgrewritechildpid == -1) {\n        if (!(loops % 10)) tryResizeHashTables();\n        if (server.activerehashing) incrementallyRehash();\n    }\n\n    \n    if (!(loops % 50)) {\n        redisLog(REDIS_VERBOSE,\"%d clients connected (%d slaves), %zu bytes in use\",\n            listLength(server.clients)-listLength(server.slaves),\n            listLength(server.slaves),\n            zmalloc_used_memory());\n    }\n\n    \n    if ((server.maxidletime && !(loops % 100)) || server.bpop_blocked_clients)\n        closeTimedoutClients();\n\n    \n    if (server.bgsavechildpid != -1 || server.bgrewritechildpid != -1) {\n        int statloc;\n        pid_t pid;\n\n        if ((pid = wait3(&statloc,WNOHANG,NULL)) != 0) {\n            if (pid == server.bgsavechildpid) {\n                backgroundSaveDoneHandler(statloc);\n            } else {\n                backgroundRewriteDoneHandler(statloc);\n            }\n            updateDictResizePolicy();\n        }\n    } else {\n        \n         time_t now = time(NULL);\n         for (j = 0; j < server.saveparamslen; j++) {\n            struct saveparam *sp = server.saveparams+j;\n\n            if (server.dirty >= sp->changes &&\n                now-server.lastsave > sp->seconds) {\n                redisLog(REDIS_NOTICE,\"%d changes in %d seconds. Saving...\",\n                    sp->changes, sp->seconds);\n                rdbSaveBackground(server.dbfilename);\n                break;\n            }\n         }\n    }\n\n    \n    if (server.masterhost == NULL) activeExpireCycle();\n\n    \n    if (vmCanSwapOut()) {\n        while (server.vm_enabled && zmalloc_used_memory() >\n                server.vm_max_memory)\n        {\n            int retval = (server.vm_max_threads == 0) ?\n                        vmSwapOneObjectBlocking() :\n                        vmSwapOneObjectThreaded();\n            if (retval == REDIS_ERR && !(loops % 300) &&\n                zmalloc_used_memory() >\n                (server.vm_max_memory+server.vm_max_memory/10))\n            {\n                redisLog(REDIS_WARNING,\"WARNING: vm-max-memory limit exceeded by more than 10%% but unable to swap more objects out!\");\n            }\n            \n            if (retval == REDIS_ERR || server.vm_max_threads > 0) break;\n        }\n    }\n\n    \n    if (!(loops % 10)) replicationCron();\n\n    return 100;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus EluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n   if (input->type == kTfLiteInt8) {\n    PopulateLookupTable<int8_t>(data, input, output, [](float value) {\n      return value < 0.0 ? std::exp(value) - 1.0f : value;\n    });\n  }\n  return GenericPrepare(context, node);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\t\n\t*data = &iterator->current;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void handle_run(HttpRequest req, HttpResponse res) {\n        const char *action = get_parameter(req, \"action\");\n        if (action) {\n                if (is_readonly(req)) {\n                        send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                        return;\n                }\n                if (IS(action, \"validate\")) {\n                        LogInfo(\"The Monit http server woke up on user request\\n\");\n                        do_wakeupcall();\n                } else if (IS(action, \"stop\")) {\n                        LogInfo(\"The Monit http server stopped on user request\\n\");\n                        send_error(req, res, SC_SERVICE_UNAVAILABLE, \"The Monit http server is stopped\");\n                        Engine_stop();\n                        return;\n                }\n        }\n        LOCK(Run.mutex)\n        do_runtime(req, res);\n        END_LOCK;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Cross-Site Request Forgery"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\n\tlen = file ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*data_len = r;\n\tok = 1;\n\nerr:\n\tsc_file_free(file);\n\n\treturn ok;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_tensor = GetInput(context, node, 0);\n  const TfLiteTensor* padding_matrix = GetInput(context, node, 1);\n  TfLiteTensor* output_tensor = GetOutput(context, node, 0);\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(padding_matrix), 2);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(padding_matrix, 0),\n                    NumDimensions(input_tensor));\n\n  if (!IsConstantTensor(padding_matrix)) {\n    SetTensorToDynamic(output_tensor);\n    return kTfLiteOk;\n  }\n   auto output_size = GetPaddedOutputShape(input_tensor, padding_matrix);\n  if (output_size == nullptr) {\n    return kTfLiteError;\n  }\n  return context->ResizeTensor(context, output_tensor, output_size.release());\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int irda_recvmsg_stream(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tint noblock = flags & MSG_DONTWAIT;\n\tsize_t copied = 0;\n\tint target, err;\n\tlong timeo;\n\n\tIRDA_DEBUG(3, \"%s()\\n\", __func__);\n\n\tif ((err = sock_error(sk)) < 0)\n\t\treturn err;\n\n\tif (sock->flags & __SO_ACCEPTCON)\n\t\treturn -EINVAL;\n\n\terr =-EOPNOTSUPP;\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\terr = 0;\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\n\ttimeo = sock_rcvtimeo(sk, noblock);\n\n\tmsg->msg_namelen = 0;\n\n\tdo {\n\t\tint chunk;\n\t\tstruct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);\n\n\t\tif (skb == NULL) {\n\t\t\tDEFINE_WAIT(wait);\n\t\t\terr = 0;\n\n\t\t\tif (copied >= target)\n\t\t\t\tbreak;\n\n\t\t\tprepare_to_wait_exclusive(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\n\t\t\t\n\t\t\terr = sock_error(sk);\n\t\t\tif (err)\n\t\t\t\t;\n\t\t\telse if (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\t;\n\t\t\telse if (noblock)\n\t\t\t\terr = -EAGAIN;\n\t\t\telse if (signal_pending(current))\n\t\t\t\terr = sock_intr_errno(timeo);\n\t\t\telse if (sk->sk_state != TCP_ESTABLISHED)\n\t\t\t\terr = -ENOTCONN;\n\t\t\telse if (skb_peek(&sk->sk_receive_queue) == NULL)\n\t\t\t\t\n\t\t\t\tschedule();\n\n\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tchunk = min_t(unsigned int, skb->len, size);\n\t\tif (memcpy_toiovec(msg->msg_iov, skb->data, chunk)) {\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\tif (copied == 0)\n\t\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += chunk;\n\t\tsize -= chunk;\n\n\t\t\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tskb_pull(skb, chunk);\n\n\t\t\t\n\t\t\tif (skb->len) {\n\t\t\t\tIRDA_DEBUG(1, \"%s(), back on q!\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tkfree_skb(skb);\n\t\t} else {\n\t\t\tIRDA_DEBUG(0, \"%s() questionable!?\\n\", __func__);\n\n\t\t\t\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\tbreak;\n\t\t}\n\t} while (size);\n\n\t\n\tif (self->rx_flow == FLOW_STOP) {\n\t\tif ((atomic_read(&sk->sk_rmem_alloc) << 2) <= sk->sk_rcvbuf) {\n\t\t\tIRDA_DEBUG(2, \"%s(), Starting IrTTP\\n\", __func__);\n\t\t\tself->rx_flow = FLOW_START;\n\t\t\tirttp_flow_request(self->tsap, FLOW_START);\n\t\t}\n\t}\n\n\treturn copied;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nget_matching_data(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx, X509 *cert,\n                  pkinit_cert_matching_data **md_out)\n{\n    krb5_error_code ret = ENOMEM;\n    pkinit_cert_matching_data *md = NULL;\n    krb5_principal *pkinit_sans = NULL, *upn_sans = NULL;\n    size_t i, j;\n    char buf[DN_BUF_LEN];\n    unsigned int bufsize = sizeof(buf);\n\n    *md_out = NULL;\n\n    md = calloc(1, sizeof(*md));\n    if (md == NULL)\n        goto cleanup;\n\n    \n    X509_NAME_oneline_ex(X509_get_subject_name(cert), buf, &bufsize,\n                         XN_FLAG_SEP_COMMA_PLUS);\n    md->subject_dn = strdup(buf);\n    if (md->subject_dn == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    \n    X509_NAME_oneline_ex(X509_get_issuer_name(cert), buf, &bufsize,\n                         XN_FLAG_SEP_COMMA_PLUS);\n    md->issuer_dn = strdup(buf);\n    if (md->issuer_dn == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    \n    ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,\n                                    cert, &pkinit_sans, &upn_sans, NULL);\n    if (ret)\n        goto cleanup;\n\n    j = 0;\n    if (pkinit_sans != NULL) {\n        for (i = 0; pkinit_sans[i] != NULL; i++)\n            j++;\n    }\n    if (upn_sans != NULL) {\n        for (i = 0; upn_sans[i] != NULL; i++)\n            j++;\n    }\n    if (j != 0) {\n        md->sans = calloc((size_t)j+1, sizeof(*md->sans));\n        if (md->sans == NULL) {\n            ret = ENOMEM;\n            goto cleanup;\n        }\n        j = 0;\n        if (pkinit_sans != NULL) {\n            for (i = 0; pkinit_sans[i] != NULL; i++)\n                md->sans[j++] = pkinit_sans[i];\n            free(pkinit_sans);\n        }\n        if (upn_sans != NULL) {\n            for (i = 0; upn_sans[i] != NULL; i++)\n                md->sans[j++] = upn_sans[i];\n            free(upn_sans);\n        }\n        md->sans[j] = NULL;\n    } else\n        md->sans = NULL;\n\n    \n    ret = crypto_retrieve_X509_key_usage(context, plg_cryptoctx,\n                                         req_cryptoctx, cert, &md->ku_bits,\n                                         &md->eku_bits);\n    if (ret)\n        goto cleanup;\n\n    *md_out = md;\n    md = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data(context, md);\n    return ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = pmd_read_atomic(pmd);\n\t\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nhandle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg;\n    int i = start;\n    int j = 0; \n\n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    \n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; \n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                \n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void Compute(OpKernelContext* context) override {\n       const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n\n       const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    std::unique_ptr<BoostedTreesEnsembleResource> result(\n        new BoostedTreesEnsembleResource());\n    if (!result->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {\n      result->Unref();\n      result.release();       OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n    }\n\n          auto status =\n        CreateResource(context, HandleFromInput(context, 0), result.release());\n    if (status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES_OK(context, status);\n    }\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nchar *curl_easy_escape(CURL *handle, const char *string, int inlength)\n{\n  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;\n  char *ns;\n  char *testing_ptr = NULL;\n  unsigned char in; \n  size_t newlen = alloc;\n  int strindex=0;\n  size_t length;\n  CURLcode res;\n\n  ns = malloc(alloc);\n  if(!ns)\n    return NULL;\n\n  length = alloc-1;\n  while(length--) {\n    in = *string;\n\n    if(Curl_isunreserved(in))\n      \n      ns[strindex++]=in;\n    else {\n      \n      newlen += 2; \n      if(newlen > alloc) {\n        alloc *= 2;\n        testing_ptr = realloc(ns, alloc);\n        if(!testing_ptr) {\n          free( ns );\n          return NULL;\n        }\n        else {\n          ns = testing_ptr;\n        }\n      }\n\n      res = Curl_convert_to_network(handle, &in, 1);\n      if(res) {\n        \n        free(ns);\n        return NULL;\n      }\n\n      snprintf(&ns[strindex], 4, \"%%%02X\", in);\n\n      strindex+=3;\n    }\n    string++;\n  }\n  ns[strindex]=0; \n  return ns;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "SQL Injection"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nnum_stmts(const node *n)\n{\n    int i, l;\n    node *ch;\n\n    switch (TYPE(n)) {\n        case single_input:\n            if (TYPE(CHILD(n, 0)) == NEWLINE)\n                return 0;\n            else\n                return num_stmts(CHILD(n, 0));\n        case file_input:\n            l = 0;\n            for (i = 0; i < NCH(n); i++) {\n                ch = CHILD(n, i);\n                if (TYPE(ch) == stmt)\n                    l += num_stmts(ch);\n            }\n            return l;\n        case stmt:\n            return num_stmts(CHILD(n, 0));\n        case compound_stmt:\n            return 1;\n        case simple_stmt:\n            return NCH(n) / 2; \n        case suite:\n            if (NCH(n) == 1)\n                return num_stmts(CHILD(n, 0));\n            else {\n                l = 0;\n                for (i = 2; i < (NCH(n) - 1); i++)\n                    l += num_stmts(CHILD(n, i));\n                return l;\n            }\n        default: {\n            char buf[128];\n\n            sprintf(buf, \"Non-statement found: %d %d\",\n                    TYPE(n), NCH(n));\n            Py_FatalError(buf);\n        }\n    }\n    Py_UNREACHABLE();\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic char* getPreferredTag(const char* gf_tag)\n{ \n\tchar* result = NULL;\n\tint grOffset = 0;\n\n\tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);\n\tif(grOffset < 0) {\n\t\treturn NULL;\n\t}\n\tif( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){\n\t\t\n\t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );\n\t} else {\n\t\t\n\t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );\n\t}\n\treturn result;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n\tstruct sk_buff *skb;\n\tint copied, error = -EINVAL;\n\n\tmsg->msg_namelen = 0;\n\n\tif (sock->state != SS_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\t\n\tif (flags & ~(MSG_DONTWAIT | MSG_PEEK))\n\t\treturn -EOPNOTSUPP;\n\n\tvcc = ATM_SD(sock);\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags) ||\n\t    !test_bit(ATM_VF_READY, &vcc->flags))\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &error);\n\tif (!skb)\n\t\treturn error;\n\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\terror = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (error)\n\t\treturn error;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\tpr_debug(\"%d -= %d\\n\", atomic_read(&sk->sk_rmem_alloc),\n\t\t\t skb->truesize);\n\t\tatm_return(vcc, skb->truesize);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTEST_P(ProtocolIntegrationTest, BufferContinue) {\n   if (upstreamProtocol() != Http::CodecType::HTTP2) {\n    return;\n  }\n  config_helper_.addConfigModifier(\n      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) -> void {\n        auto* route_config = hcm.mutable_route_config();\n        auto* virtual_host = route_config->mutable_virtual_hosts(0);\n        auto* header = virtual_host->mutable_response_headers_to_add()->Add()->mutable_header();\n        header->set_key(\"foo\");\n        header->set_value(\"bar\");\n      });\n\n  useAccessLog();\n  config_helper_.addFilter(\"{ name: buffer-continue-filter, typed_config: { \\\"@type\\\": \"\n                           \"type.googleapis.com/google.protobuf.Empty } }\");\n  config_helper_.setBufferLimits(1024, 1024);\n  initialize();\n\n   codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  auto downstream_request = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  Buffer::OwnedImpl data(\"HTTP body content goes here\");\n  codec_client_->sendData(*downstream_request, data, true);\n  waitForNextUpstreamRequest();\n\n   upstream_request_->encodeHeaders(default_response_headers_, false);\n\n    upstream_request_->encodeData(512, false);\n  upstream_request_->encodeData(1024 * 100, false);\n\n  if (upstreamProtocol() == Http::CodecType::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  ASSERT_TRUE(response->waitForEndStream());\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"500\", response->headers().getStatusValue());\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void show_object(struct object *object, const char *name, void *data)\n{\n\tstruct bitmap *base = data;\n\tbitmap_set(base, find_object_pos(object->oid.hash));\n\tmark_as_seen(object);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n\t\tboost::system::error_code make_error_code(error_code_enum e)\n\t\t{\n\t\t\treturn boost::system::error_code(e, get_bdecode_category());\n\t\t}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer *buf_in, const MOBIHuffCdic *huffcdic, size_t depth) {\n    if (depth > MOBI_HUFFMAN_MAXDEPTH) {\n        debug_print(\"Too many levels of recursion: %zu\\n\", depth);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    int8_t bitcount = 32;\n    \n    int bitsleft = (int) (buf_in->maxlen * 8);\n    uint8_t code_length = 0;\n    uint64_t buffer = mobi_buffer_fill64(buf_in);\n    while (ret == MOBI_SUCCESS) {\n        if (bitcount <= 0) {\n            bitcount += 32;\n            buffer = mobi_buffer_fill64(buf_in);\n        }\n        uint32_t code = (buffer >> bitcount) & 0xffffffffU;\n        \n        uint32_t t1 = huffcdic->table1[code >> 24];\n        \n        code_length = t1 & 0x1f;\n        uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;\n        \n        if (!(t1 & 0x80)) {\n            \n            while (code < huffcdic->mincode_table[code_length]) {\n                if (++code_length >= HUFF_CODETABLE_SIZE) {\n                    debug_print(\"Wrong offset to mincode table: %hhu\\n\", code_length);\n                    return MOBI_DATA_CORRUPT;\n                }\n            }\n            maxcode = huffcdic->maxcode_table[code_length];\n        }\n        bitcount -= code_length;\n        bitsleft -= code_length;\n        if (bitsleft < 0) {\n            break;\n        }\n        \n        uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);\n        \n        uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);\n        if (index >= huffcdic->index_count) {\n            debug_print(\"Wrong symbol offsets index: %u\\n\", index);\n            return MOBI_DATA_CORRUPT;\n        }\n        \n        uint32_t offset = huffcdic->symbol_offsets[index];\n        uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];\n        \n        int is_decompressed = symbol_length >> 15;\n        \n        symbol_length &= 0x7fff;\n        if (is_decompressed) {\n            \n            mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);\n            ret = buf_out->error;\n        } else {\n            \n            \n            MOBIBuffer buf_sym;\n            buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;\n            buf_sym.offset = 0;\n            buf_sym.maxlen = symbol_length;\n            buf_sym.error = MOBI_SUCCESS;\n            ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);\n        }\n    }\n    return ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nl2tp_framing_type_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nnv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n       if (cap->nchar == Ctrl_V)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n       if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n       if (VIsual_active)\n    {\n\tif (got_int)\n\t    reset_VIsual();\n\tif (had_ctrl_v)\n\t{\n\t   \t   \t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n       if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t   \t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n       ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    \n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n       if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t\n\t(void)del_chars(cap->count1, FALSE);\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t   \t   \t   \t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    \n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\n\t\t  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\t}\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   (long)cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t   \t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t   \tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid CClient::ReadLine(const CString& sData) {\n    CLanguageScope user_lang(GetUser() ? GetUser()->GetLanguage() : \"\");\n    CString sLine = sData;\n\n    sLine.Replace(\"\\n\", \"\");\n    sLine.Replace(\"\\r\", \"\");\n\n    DEBUG(\"(\" << GetFullName() << \") CLI -> ZNC [\"\n        << CDebug::Filter(sLine) << \"]\");\n\n    bool bReturn = false;\n    if (IsAttached()) {\n        NETWORKMODULECALL(OnUserRaw(sLine), m_pUser, m_pNetwork, this,\n                          &bReturn);\n    } else {\n        GLOBALMODULECALL(OnUnknownUserRaw(this, sLine), &bReturn);\n    }\n    if (bReturn) return;\n\n    CMessage Message(sLine);\n    Message.SetClient(this);\n\n    if (IsAttached()) {\n        NETWORKMODULECALL(OnUserRawMessage(Message), m_pUser, m_pNetwork, this,\n                          &bReturn);\n    } else {\n        GLOBALMODULECALL(OnUnknownUserRawMessage(Message), &bReturn);\n    }\n    if (bReturn) return;\n\n    CString sCommand = Message.GetCommand();\n\n    if (!IsAttached()) {\n               if (sCommand.Equals(\"PASS\")) {\n            m_bGotPass = true;\n\n            CString sAuthLine = Message.GetParam(0);\n            ParsePass(sAuthLine);\n\n            AuthUser();\n                       return;\n        } else if (sCommand.Equals(\"NICK\")) {\n            CString sNick = Message.GetParam(0);\n\n            m_sNick = sNick;\n            m_bGotNick = true;\n\n            AuthUser();\n                                  return;\n        } else if (sCommand.Equals(\"USER\")) {\n            CString sAuthLine = Message.GetParam(0);\n\n            if (m_sUser.empty() && !sAuthLine.empty()) {\n                ParseUser(sAuthLine);\n            }\n\n            m_bGotUser = true;\n            if (m_bGotPass) {\n                AuthUser();\n            } else if (!m_bInCap) {\n                SendRequiredPasswordNotice();\n            }\n\n                       return;\n        }\n    }\n\n    if (Message.GetType() == CMessage::Type::Capability) {\n        HandleCap(Message);\n\n                      return;\n    }\n\n    if (!m_pUser) {\n               return;\n    }\n\n    switch (Message.GetType()) {\n        case CMessage::Type::Action:\n            bReturn = OnActionMessage(Message);\n            break;\n        case CMessage::Type::CTCP:\n            bReturn = OnCTCPMessage(Message);\n            break;\n        case CMessage::Type::Join:\n            bReturn = OnJoinMessage(Message);\n            break;\n        case CMessage::Type::Mode:\n            bReturn = OnModeMessage(Message);\n            break;\n        case CMessage::Type::Notice:\n            bReturn = OnNoticeMessage(Message);\n            break;\n        case CMessage::Type::Part:\n            bReturn = OnPartMessage(Message);\n            break;\n        case CMessage::Type::Ping:\n            bReturn = OnPingMessage(Message);\n            break;\n        case CMessage::Type::Pong:\n            bReturn = OnPongMessage(Message);\n            break;\n        case CMessage::Type::Quit:\n            bReturn = OnQuitMessage(Message);\n            break;\n        case CMessage::Type::Text:\n            bReturn = OnTextMessage(Message);\n            break;\n        case CMessage::Type::Topic:\n            bReturn = OnTopicMessage(Message);\n            break;\n        default:\n            bReturn = OnOtherMessage(Message);\n            break;\n    }\n\n    if (bReturn) return;\n\n    PutIRC(Message.ToString(CMessage::ExcludePrefix | CMessage::ExcludeTags));\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nfolly::Optional<DumpFile> dump_file(const char* name) {\n  auto const path = folly::sformat(\"{}/{}\", RO::AdminDumpPath, name);\n\n   if (FileUtil::mkdir(path) != 0) return folly::none;\n\n    remove(path.c_str());\n\n    auto const fd = open(path.c_str(), O_CREAT|O_EXCL|O_RDWR, 0666);\n  if (fd < 0) return folly::none;\n\n  return DumpFile{path, folly::File(fd, true)};\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\n\t\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\t\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t}\n\n\tmsg->msg_namelen = sizeof(*sax);\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\treturn copied;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\npixFillMapHoles(PIX     *pix,\n                l_int32  nx,\n                l_int32  ny,\n                l_int32  filltype)\n{\nl_int32   w, h, y, nmiss, goodcol, i, j, found, ival, valtest;\nl_uint32  val, lastval;\nNUMA     *na;  \n\n    PROCNAME(\"pixFillMapHoles\");\n\n    if (!pix || pixGetDepth(pix) != 8)\n        return ERROR_INT(\"pix not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pix))\n        return ERROR_INT(\"pix is colormapped\", procName, 1);\n\n    \n    pixGetDimensions(pix, &w, &h, NULL);\n    na = numaCreate(0);  \n    nmiss = 0;\n    valtest = (filltype == L_FILL_WHITE) ? 255 : 0;\n    for (j = 0; j < nx; j++) {  \n        found = FALSE;\n        for (i = 0; i < ny; i++) {\n            pixGetPixel(pix, j, i, &val);\n            if (val != valtest) {\n                y = i;\n                found = TRUE;\n                break;\n            }\n        }\n        if (found == FALSE) {\n            numaAddNumber(na, 0);  \n            nmiss++;\n        }\n        else {\n            numaAddNumber(na, 1);  \n            for (i = y - 1; i >= 0; i--)  \n                pixSetPixel(pix, j, i, val);\n            pixGetPixel(pix, j, 0, &lastval);\n            for (i = 1; i < h; i++) {  \n                pixGetPixel(pix, j, i, &val);\n                if (val == valtest)\n                    pixSetPixel(pix, j, i, lastval);\n                else\n                    lastval = val;\n            }\n        }\n    }\n    numaAddNumber(na, 0);  \n\n    if (nmiss == nx) {  \n        numaDestroy(&na);\n        L_WARNING(\"no bg found; no data in any column\\n\", procName);\n        return 1;\n    }\n\n    \n    if (nmiss > 0) {  \n            \n        goodcol = 0;\n        for (j = 0; j < w; j++) {\n            numaGetIValue(na, j, &ival);\n            if (ival == 1) {\n                goodcol = j;\n                break;\n            }\n        }\n        if (goodcol > 0) {  \n            for (j = goodcol - 1; j >= 0; j--)\n                pixRasterop(pix, j, 0, 1, h, PIX_SRC, pix, j + 1, 0);\n        }\n        for (j = goodcol + 1; j < w; j++) {   \n            numaGetIValue(na, j, &ival);\n            if (ival == 0) {\n                    \n                pixRasterop(pix, j, 0, 1, h, PIX_SRC, pix, j - 1, 0);\n            }\n        }\n    }\n    if (w > nx) {  \n        for (i = 0; i < h; i++) {\n            pixGetPixel(pix, w - 2, i, &val);\n            pixSetPixel(pix, w - 1, i, val);\n        }\n    }\n\n    numaDestroy(&na);\n    return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_bitmap_updates(STREAM s)\n{\n\tint i;\n\tuint16 num_updates;\n\t\n\tin_uint16_le(s, num_updates);   \n\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tprocess_bitmap_data(s);\n\t}\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid RemoteFsDevice::serviceRemoved(const QString &name)\n{\n    if (name==details.serviceName && constSambaAvahiProtocol==details.url.scheme()) {\n        sub=tr(\"Not Available\");\n        updateStatus();\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ndecode_multicast_vpn(netdissect_options *ndo,\n                     const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t route_type, route_length, addr_length, sg_length;\n        u_int offset;\n\n\tND_TCHECK2(pptr[0], 2);\n        route_type = *pptr++;\n        route_length = *pptr++;\n\n        snprintf(buf, buflen, \"Route-Type: %s (%u), length: %u\",\n                 tok2str(bgp_multicast_vpn_route_type_values,\n                         \"Unknown\", route_type),\n                 route_type, route_length);\n\n        switch(route_type) {\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s, Originator %s\",\n                     bgp_vpn_rd_print(ndo, pptr),\n                     bgp_vpn_ip_print(ndo, pptr + BGP_VPN_RD_LEN,\n                                      (route_length - BGP_VPN_RD_LEN) << 3));\n            break;\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            sg_length = bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            addr_length =  route_length - sg_length;\n\n            ND_TCHECK2(pptr[0], addr_length);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", Originator %s\",\n                     bgp_vpn_ip_print(ndo, pptr, addr_length << 3));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN: \n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            pptr += BGP_VPN_RD_LEN + 4;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n            \n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF:\n        default:\n            break;\n        }\n\n        return route_length + 2;\n\ntrunc:\n\treturn -2;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ntTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n                                                tCompletePhysicalAddress *pDataPages,\n                                                ULONG ulDataLength,\n                                                ULONG ulStartOffset,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n\n    tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength);\n    if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)\n        return res;\n\n    if (res.ipStatus == ppresIPV4)\n    {\n        if (flags & pcrIpChecksum)\n            res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0);\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) \n            {\n                if(flags & pcrTcpV4Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum));\n                }\n            }\n            else \n            {\n                if (flags & pcrUdpV4Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum));\n                }\n            }\n        }\n    }\n    else if (res.ipStatus == ppresIPV6)\n    {\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) \n            {\n                if(flags & pcrTcpV6Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum));\n                }\n            }\n            else \n            {\n                if (flags & pcrUdpV6Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum));\n                }\n            }\n        }\n    }\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,\n\t\t\t\t    struct uffd_msg *msg)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct userfaultfd_wait_queue *uwq;\n\t\n\tLIST_HEAD(fork_event);\n\tstruct userfaultfd_ctx *fork_nctx = NULL;\n\n\t\n\tspin_lock(&ctx->fd_wqh.lock);\n\t__add_wait_queue(&ctx->fd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\tuwq = find_userfault(ctx);\n\t\tif (uwq) {\n\t\t\t\n\t\t\twrite_seqcount_begin(&ctx->refile_seq);\n\n\t\t\t\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->fault_wqh, &uwq->wq);\n\n\t\t\twrite_seqcount_end(&ctx->refile_seq);\n\n\t\t\t\n\t\t\t*msg = uwq->msg;\n\t\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tuwq = find_userfault_evt(ctx);\n\t\tif (uwq) {\n\t\t\t*msg = uwq->msg;\n\n\t\t\tif (uwq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tfork_nctx = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tuwq->msg.arg.reserved.reserved1;\n\t\t\t\tlist_move(&uwq->wq.entry, &fork_event);\n\t\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (no_wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fd_wqh.lock);\n\t\tschedule();\n\t\tspin_lock(&ctx->fd_wqh.lock);\n\t}\n\t__remove_wait_queue(&ctx->fd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->fd_wqh.lock);\n\n\tif (!ret && msg->event == UFFD_EVENT_FORK) {\n\t\tret = resolve_userfault_fork(ctx, fork_nctx, msg);\n\n\t\tif (!ret) {\n\t\t\tspin_lock(&ctx->event_wqh.lock);\n\t\t\tif (!list_empty(&fork_event)) {\n\t\t\t\tuwq = list_first_entry(&fork_event,\n\t\t\t\t\t\t       typeof(*uwq),\n\t\t\t\t\t\t       wq.entry);\n\t\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t\t__add_wait_queue(&ctx->event_wqh, &uwq->wq);\n\t\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\t}\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t}\n\t}\n\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_msnd *chip = dev_id;\n\tvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n\n\t\n\t\n\n\t\n\twhile (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {\n\t\tu16 wTmp;\n\n\t\tsnd_msnd_eval_dsp_msg(chip,\n\t\t\treadw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));\n\n\t\twTmp = readw(chip->DSPQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(chip->DSPQ + JQS_wSize))\n\t\t\twritew(0, chip->DSPQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp, chip->DSPQ + JQS_wHead);\n\t}\n\t\n\tinb(chip->io + HP_RXL);\n\treturn IRQ_HANDLED;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ninline void StringData::setSize(int64_t len) {\n  assertx(!isImmutable() && !hasMultipleRefs());\n  assertx(len >= 0 && len <= capacity());\n  mutableData()[len] = 0;\n  m_lenAndHash = len;\n  assertx(m_hash == 0);\n  assertx(checkSane());\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTRIO_PRIVATE void TrioWriteString TRIO_ARGS5((self, string, flags, width, precision),\n                                             trio_class_t* self, TRIO_CONST char* string,\n                                             trio_flags_t flags, int width, int precision)\n{\n\tint length = 0;\n\tint ch;\n\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\n\tif (string == NULL)\n\t{\n\t\tstring = internalNullString;\n\t\tlength = sizeof(internalNullString) - 1;\n#if TRIO_FEATURE_QUOTE\n\t\t\n\t\tflags &= (~FLAGS_QUOTE);\n#endif\n\t\twidth = 0;\n\t}\n\telse\n\t{\n\t\tif (precision <= 0)\n\t\t{\n\t\t\tlength = trio_length(string);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlength = trio_length_max(string, precision);\n\t\t}\n\t}\n\tif ((NO_PRECISION != precision) && (precision < length))\n\t{\n\t\tlength = precision;\n\t}\n\twidth -= length;\n\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n\n\tif (!(flags & FLAGS_LEFTADJUST))\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n\n\twhile (length-- > 0)\n\t{\n\t\t\n\t\tch = (int)((unsigned char)(*string++));\n\t\tTrioWriteStringCharacter(self, ch, flags);\n\t}\n\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n    if (!done) {\n    done = [] {};\n  }\n\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, indices_t.dim_size(0) == values_t.dim_size(0),\n      errors::InvalidArgument(\"The length of `values` (\", values_t.dim_size(0),\n                              \") must match the first dimension of `indices` (\",\n                              indices_t.dim_size(0), \").\"),\n      done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n    OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n\n\tmscfs_check_cache(priv->fs);\n\n\tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid = fs->cache.array[x].objectId.id;\n\t\tif (bufLen < 2)\n\t\t\tbreak;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n\t\t\tbuf[1] = oid[3];\n\t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; \n\t\t\tbuf += 2;\n\t\t\tcount += 2;\n\t\t\tbufLen -= 2;\n\t\t}\n\t}\n\treturn count;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct sockaddr_nl *addr = msg->msg_name;\n\tu32 dst_pid;\n\tu32 dst_group;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct scm_cookie scm;\n\n\tif (msg->msg_flags&MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &scm;\n\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (msg->msg_namelen) {\n\t\terr = -EINVAL;\n\t\tif (addr->nl_family != AF_NETLINK)\n\t\t\tgoto out;\n\t\tdst_pid = addr->nl_pid;\n\t\tdst_group = ffs(addr->nl_groups);\n\t\terr =  -EPERM;\n\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))\n\t\t\tgoto out;\n\t} else {\n\t\tdst_pid = nlk->dst_pid;\n\t\tdst_group = nlk->dst_group;\n\t}\n\n\tif (!nlk->pid) {\n\t\terr = netlink_autobind(sock);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tNETLINK_CB(skb).pid\t= nlk->pid;\n\tNETLINK_CB(skb).dst_group = dst_group;\n\tmemcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\terr = security_netlink_send(sk, skb);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (dst_group) {\n\t\tatomic_inc(&skb->users);\n\t\tnetlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);\n\t}\n\terr = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);\n\nout:\n\tscm_destroy(siocb->scm);\n\treturn err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Authentication"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int jpc_pi_nextcprl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\tpi->xstep = pi->picomp->hsamp * (1 << (pirlvl->prcwidthexpn +\n\t\t  pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (1 << (pirlvl->prcheightexpn +\n\t\t  pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp * (1 <<\n\t\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls -\n\t\t\t  rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp * (1 <<\n\t\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls -\n\t\t\t  rlvlno - 1)));\n\t\t}\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend;\n\t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;\n\t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,\n\t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||\n\t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||\n\t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind *\n\t\t\t\t\t\t  pi->pirlvl->numhprcs +\n\t\t\t\t\t\t  prchind;\n\t\t\t\t\t\tassert(pi->prcno <\n\t\t\t\t\t\t  pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmcs_parse_domain_params(STREAM s)\n{\n\tint length;\n\n\tber_parse_header(s, MCS_TAG_DOMAIN_PARAMS, &length);\n\tin_uint8s(s, length);\n\n\treturn s_check(s);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint __cil_build_ast_first_child_helper(__attribute__((unused)) struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = ast;\n\t}\n\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = ast;\n\t}\n\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = ast;\n\t}\n\n\tif (ast->flavor == CIL_OPTIONAL) {\n\t\targs->optional = ast;\n\t}\n\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = ast;\n\t}\n\n\treturn SEPOL_OK;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newbufsize;\n\tlong newpos;\n\n\tassert(buf);\n\tassert(cnt >= 0);\n\n\tJAS_DBGLOG(100, (\"mem_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\tnewbufsize <<= 1;\n\t\t\tassert(newbufsize >= 0);\n\t\t}\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %z\\n\", m->bufsize_,\n\t\t  newbufsize));\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %ul\\n\", m->bufsize_,\n\t\t  JAS_CAST(unsigned long, newbufsize)));\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\t\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char *buffer;\n\tint ret;\n\n\tbuffer = kmalloc(3, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\tkfree(buffer);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\n                                                     size_t xTriggerLevelBytes,\n                                                     BaseType_t xIsMessageBuffer )\n    {\n        uint8_t * pucAllocatedMemory;\n        uint8_t ucFlags;\n\n        \n        if( xIsMessageBuffer == pdTRUE )\n        {\n            \n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\n            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\n        }\n        else\n        {\n            \n            ucFlags = 0;\n            configASSERT( xBufferSizeBytes > 0 );\n        }\n\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\n\n        \n        if( xTriggerLevelBytes == ( size_t ) 0 )\n        {\n            xTriggerLevelBytes = ( size_t ) 1;\n        }\n\n        \n        xBufferSizeBytes++;\n        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); \n\n        if( pucAllocatedMemory != NULL )\n        {\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,         \n                                          pucAllocatedMemory + sizeof( StreamBuffer_t ),  \n                                          xBufferSizeBytes,\n                                          xTriggerLevelBytes,\n                                          ucFlags );\n\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\n        }\n        else\n        {\n            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\n        }\n\n        return ( StreamBufferHandle_t ) pucAllocatedMemory; \n    }\n\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsnmp_ber_encode_length(snmp_packet_t *snmp_packet, uint16_t length)\n{\n  if(length > 0xFF) {\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n\n    *snmp_packet->out-- = (uint8_t)length & 0xFF;\n    snmp_packet->used++;\n\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n\n    *snmp_packet->out-- = (uint8_t)(length >> 8) & 0xFF;\n    snmp_packet->used++;\n\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n\n    *snmp_packet->out-- = 0x82;\n    snmp_packet->used++;\n  } else if(length > 0x7F) {\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n\n    *snmp_packet->out-- = (uint8_t)length & 0xFF;\n    snmp_packet->used++;\n\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n\n    *snmp_packet->out-- = 0x81;\n    snmp_packet->used++;\n  } else {\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n\n    *snmp_packet->out-- = (uint8_t)length & 0x7F;\n    snmp_packet->used++;\n  }\n\n  return 1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  output->type = input->type;\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);\n  return context->ResizeTensor(context, output, output_size);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_plane(uint8 * in, int width, int height, uint8 * out, int size)\n{\n\tUNUSED(size);\n\tint indexw;\n\tint indexh;\n\tint code;\n\tint collen;\n\tint replen;\n\tint color;\n\tint x;\n\tint revcode;\n\tuint8 * last_line;\n\tuint8 * this_line;\n\tuint8 * org_in;\n\tuint8 * org_out;\n\n\torg_in = in;\n\torg_out = out;\n\tlast_line = 0;\n\tindexh = 0;\n\twhile (indexh < height)\n\t{\n\t\tout = (org_out + width * height * 4) - ((indexh + 1) * width * 4);\n\t\tcolor = 0;\n\t\tthis_line = out;\n\t\tindexw = 0;\n\t\tif (last_line == 0)\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (collen > 0)\n\t\t\t\t{\n\t\t\t\t\tcolor = CVAL(in);\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (replen > 0)\n\t\t\t\t{\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (collen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = CVAL(in);\n\t\t\t\t\tif (x & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tx = x + 1;\n\t\t\t\t\t\tcolor = -x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tcolor = x;\n\t\t\t\t\t}\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (replen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tindexh++;\n\t\tlast_line = this_line;\n\t}\n\treturn (int) (in - org_in);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus EvalLogic(TfLiteContext* context, TfLiteNode* node,\n                       OpContext* op_context, T init_value,\n                       T reducer(const T current, const T in)) {\n  int64_t num_axis = NumElements(op_context->axis);\n  TfLiteTensor* temp_index;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, 0, &temp_index));\n  TfLiteTensor* resolved_axis;\n  TF_LITE_ENSURE_OK(\n      context, GetTemporarySafe(context, node, 1, &resolved_axis));\n   if (IsDynamicTensor(op_context->output)) {\n    TF_LITE_ENSURE_OK(context,\n                      ResizeTempAxis(context, op_context, resolved_axis));\n    TF_LITE_ENSURE_OK(context, ResizeOutputTensor(context, op_context));\n  }\n  if (op_context->input->type == kTfLiteUInt8 ||\n      op_context->input->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, op_context->input->params.scale,\n                      op_context->output->params.scale);\n    TF_LITE_ENSURE_EQ(context, op_context->input->params.zero_point,\n                      op_context->output->params.zero_point);\n  }\n  TF_LITE_ENSURE(\n      context,\n      reference_ops::ReduceGeneric<T>(\n          GetTensorData<T>(op_context->input), op_context->input->dims->data,\n          op_context->input->dims->size, GetTensorData<T>(op_context->output),\n          op_context->output->dims->data, op_context->output->dims->size,\n          GetTensorData<int>(op_context->axis), num_axis,\n          op_context->params->keep_dims, GetTensorData<int>(temp_index),\n          GetTensorData<int>(resolved_axis), init_value, reducer));\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nerror_t dm9000UpdateMacAddrFilter(NetInterface *interface)\n{\n   uint_t i;\n   uint_t k;\n   uint32_t crc;\n   uint8_t hashTable[8];\n   MacFilterEntry *entry;\n\n     TRACE_DEBUG(\"Updating MAC filter...\\r\\n\");\n\n     osMemset(hashTable, 0, sizeof(hashTable));\n     hashTable[7] = 0x80;\n\n       for(i = 0; i < MAC_ADDR_FILTER_SIZE; i++)\n   {\n           entry = &interface->macAddrFilter[i];\n\n           if(entry->refCount > 0)\n      {\n                 crc = dm9000CalcCrc(&entry->addr, sizeof(MacAddr));\n                 k = crc & 0x3F;\n                 hashTable[k / 8] |= (1 << (k % 8));\n      }\n   }\n\n     for(i = 0; i < 8; i++)\n   {\n      dm9000WriteReg(DM9000_MAR0 + i, hashTable[i]);\n   }\n\n     TRACE_DEBUG(\"  MAR = %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" \"\n      \"%02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \"\\r\\n\",\n      dm9000ReadReg(DM9000_MAR0), dm9000ReadReg(DM9000_MAR1),\n      dm9000ReadReg(DM9000_MAR2), dm9000ReadReg(DM9000_MAR3),\n      dm9000ReadReg(DM9000_MAR4), dm9000ReadReg(DM9000_MAR5),\n      dm9000ReadReg(DM9000_MAR6), dm9000ReadReg(DM9000_MAR7));\n\n     return NO_ERROR;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\t\n\tcstate = 0;\n\n\tppm->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppm->ind)) {\n\t\tgoto error;\n\t}\n\n\tppm->len = ms->len - 1;\n\tif (ppm->len > 0) {\n\t\tif (!(ppm->data = jas_malloc(ppm->len))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (JAS_CAST(jas_uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppm->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppm_destroyparms(ms);\n\treturn -1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmain (int argc, char *argv[])\n{\n  unsigned cmdn;\n  int flags = IDN2_NONTRANSITIONAL;\n\n  setlocale (LC_ALL, \"\");\n  set_program_name (argv[0]);\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  if (cmdline_parser (argc, argv, &args_info) != 0)\n    return EXIT_FAILURE;\n\n  if (args_info.version_given)\n    {\n      version_etc (stdout, \"idn2\", PACKAGE_NAME, VERSION,\n\t\t   \"Simon Josefsson\", (char *) NULL);\n      return EXIT_SUCCESS;\n    }\n\n  if (args_info.help_given)\n    usage (EXIT_SUCCESS);\n\n  if (!args_info.quiet_given\n      && args_info.inputs_num == 0 && isatty (fileno (stdin)))\n    fprintf (stderr, \"%s %s\\n\" GREETING, PACKAGE, VERSION);\n\n  if (args_info.debug_given)\n    fprintf (stderr, _(\"Charset: %s\\n\"), locale_charset ());\n\n  if (!args_info.quiet_given\n      && args_info.inputs_num == 0 && isatty (fileno (stdin)))\n    fprintf (stderr, \"%s\", _(\"Type each input string on a line by itself, \"\n\t\t\t     \"terminated by a newline character.\\n\"));\n\n  if (args_info.tr46t_given)\n    flags = IDN2_TRANSITIONAL;\n  else if (args_info.tr46nt_given)\n    flags = IDN2_NONTRANSITIONAL;\n  else if (args_info.no_tr46_given)\n    flags = IDN2_NO_TR46;\n\n  if (flags && args_info.usestd3asciirules_given)\n    flags |= IDN2_USE_STD3_ASCII_RULES;\n\n  for (cmdn = 0; cmdn < args_info.inputs_num; cmdn++)\n    process_input (args_info.inputs[cmdn], flags | IDN2_NFC_INPUT);\n\n  if (!cmdn)\n    {\n      char *buf = NULL;\n      size_t bufsize = 0;\n\n      while (getline (&buf, &bufsize, stdin) > 0)\n\tprocess_input (buf, flags);\n\n      free (buf);\n    }\n\n  if (ferror (stdin))\n    error (EXIT_FAILURE, errno, \"%s\", _(\"input error\"));\n\n  cmdline_parser_free (&args_info);\n\n  return EXIT_SUCCESS;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  output->type = input->type;\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);\n  return context->ResizeTensor(context, output, output_size);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tUINT16 i;\n\tBYTE* rle;\n\tUINT32 planeSize;\n\tUINT32 originalSize;\n\n\tif (!context)\n\t\treturn FALSE;\n\n\trle = context->Planes;\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\toriginalSize = context->OrgByteCount[i];\n\t\tplaneSize = context->PlaneByteCount[i];\n\n\t\tif (planeSize == 0)\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\t}\n\t\telse if (planeSize < originalSize)\n\t\t{\n\t\t\tif (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i], context->priv->PlaneBuffersLength,\n\t\t\t                    originalSize))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\t\t}\n\n\t\trle += planeSize;\n\t}\n\n\treturn TRUE;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic RList *relocs(RBinFile *arch) {\n\tstruct r_bin_bflt_obj *obj = (struct r_bin_bflt_obj*)arch->o->bin_obj;\n\tRList *list = r_list_newf ((RListFree)free);\n\tint i, len, n_got, amount;\n\tif (!list || !obj) {\n\t\tr_list_free (list);\n\t\treturn NULL;\n\t}\n\tif (obj->hdr->flags & FLAT_FLAG_GOTPIC) {\n\t\tn_got = get_ngot_entries (obj);\n\t\tif (n_got) {\n\t\t\tamount = n_got *  sizeof (ut32);\n\t\t\tif (amount < n_got || amount > UT32_MAX) {\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tstruct reloc_struct_t *got_table = calloc (\n\t\t\t\t1, n_got * sizeof (struct reloc_struct_t));\n\t\t\tif (got_table) {\n\t\t\t\tut32 offset = 0;\n\t\t\t\tfor (i = 0; i < n_got ; offset += 4, i++) {\n\t\t\t\t\tut32 got_entry;\n\t\t\t\t\tif (obj->hdr->data_start + offset + 4 > obj->size ||\n\t\t\t\t\t    obj->hdr->data_start + offset + 4 < offset) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlen = r_buf_read_at (obj->b, obj->hdr->data_start + offset,\n\t\t\t\t\t\t\t\t(ut8 *)&got_entry, sizeof (ut32));\n\t\t\t\t\tif (!VALID_GOT_ENTRY (got_entry) || len != sizeof (ut32)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgot_table[i].addr_to_patch = got_entry;\n\t\t\t\t\tgot_table[i].data_offset = got_entry + BFLT_HDR_SIZE;\n\t\t\t\t}\n\t\t\t\tobj->n_got = n_got;\n\t\t\t\tobj->got_table = got_table;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (obj->hdr->reloc_count > 0) {\n\t\tint n_reloc = obj->hdr->reloc_count; \n\n\t\tamount = n_reloc * sizeof (struct reloc_struct_t);\n\t\tif (amount < n_reloc || amount > UT32_MAX) {\n\t\t\tgoto out_error;\t\n\t\t}\n\t\tstruct reloc_struct_t *reloc_table = calloc (1, amount + 1);\n\t\tif (!reloc_table) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tamount = n_reloc * sizeof (ut32);\n\t\tif (amount < n_reloc || amount > UT32_MAX) {\n\t\t\tfree (reloc_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tut32 *reloc_pointer_table = calloc (1, amount + 1);\n\t\tif (!reloc_pointer_table) {\n\t\t\tfree (reloc_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (obj->hdr->reloc_start + amount > obj->size ||\n\t\t    obj->hdr->reloc_start + amount < amount) {\n\t\t\tfree (reloc_table);\n\t\t\tfree (reloc_pointer_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tlen = r_buf_read_at (obj->b, obj->hdr->reloc_start,\n\t\t\t\t     (ut8 *)reloc_pointer_table, amount);\n\t\tif (len != amount) {\n\t\t\tfree (reloc_table);\n\t\t\tfree (reloc_pointer_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tfor (i = 0; i < obj->hdr->reloc_count; i++) {\n\t\t\t\t\tut32 reloc_offset =\n\t\t\t\tr_swap_ut32 (reloc_pointer_table[i]) +\n\t\t\t\tBFLT_HDR_SIZE;\n\n\t\t\tif (reloc_offset < obj->hdr->bss_end && reloc_offset < obj->size) {\n\t\t\t\tut32 reloc_fixed, reloc_data_offset;\n\t\t\t\tif (reloc_offset + sizeof (ut32) > obj->size ||\n\t\t\t\t    reloc_offset + sizeof (ut32) < reloc_offset) {\n\t\t\t\t\tfree (reloc_table);\n\t\t\t\t\tfree (reloc_pointer_table);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tlen = r_buf_read_at (obj->b, reloc_offset,\n\t\t\t\t\t\t     (ut8 *)&reloc_fixed,\n\t\t\t\t\t\t     sizeof (ut32));\n\t\t\t\tif (len != sizeof (ut32)) {\n\t\t\t\t\teprintf (\"problem while reading relocation entries\\n\");\n\t\t\t\t\tfree (reloc_table);\n\t\t\t\t\tfree (reloc_pointer_table);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\treloc_data_offset = r_swap_ut32 (reloc_fixed) + BFLT_HDR_SIZE;\n\t\t\t\treloc_table[i].addr_to_patch = reloc_offset;\n\t\t\t\treloc_table[i].data_offset = reloc_data_offset;\n\t\n\t\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\t\tif (reloc) {\n\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\treloc->paddr = reloc_table[i].addr_to_patch;\n\t\t\t\t\treloc->vaddr = reloc->paddr;\n\t\t\t\t\tr_list_append (list, reloc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (reloc_pointer_table);\n\t\tobj->reloc_table = reloc_table;\n\t}\n\treturn list;\nout_error:\n\tr_list_free (list);\n\treturn NULL;\t\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nhandle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg;\n    int i = start;\n    int j = 0; \n\n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    \n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; \n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                \n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void writeStats(Array& ) override {\n    fprintf(stderr, \"writeStats start\\n\");\n                fprintf(stderr, \"Count Function MinSerLen MaxSerLen RetSame HasThis \"\n            \"AllSame MemberCount\\n\");\n    for (auto& me : m_memos) {\n      if (me.second.m_ignore) continue;\n      if (me.second.m_count == 1) continue;\n      int min_ser_len = 999999999;\n      int max_ser_len = 0;\n      int count = 0;\n      int member_count = 0;\n      bool all_same = true;\n      if (me.second.m_has_this) {\n        bool any_multiple = false;\n        auto& fr = me.second.m_member_memos.begin()->second.m_return_value;\n        member_count = me.second.m_member_memos.size();\n        for (auto& mme : me.second.m_member_memos) {\n          if (mme.second.m_return_value != fr) all_same = false;\n          count += mme.second.m_count;\n          auto ser_len = mme.second.m_return_value.length();\n          min_ser_len = std::min<int64_t>(min_ser_len, ser_len);\n          max_ser_len = std::max<int64_t>(max_ser_len, ser_len);\n          if (mme.second.m_count > 1) any_multiple = true;\n        }\n        if (!any_multiple && !all_same) continue;\n      } else {\n        min_ser_len = max_ser_len = me.second.m_return_value.length();\n        count = me.second.m_count;\n        all_same = me.second.m_ret_tv_same;\n      }\n      fprintf(stderr, \"%d %s %d %d %s %s %s %d\\n\",\n              count, me.first.data(),\n              min_ser_len, max_ser_len,\n              me.second.m_ret_tv_same ? \" true\" : \"false\",\n              me.second.m_has_this ? \" true\" : \"false\",\n              all_same ? \" true\" : \"false\",\n              member_count\n             );\n    }\n    fprintf(stderr, \"writeStats end\\n\");\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_snmp_ureq *ureq;\n\tint req_len;\n\tstruct qeth_arp_query_info qinfo = {0, };\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\n\tif (card->info.guestlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    (!card->options.layer2)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\t\n\tif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\n\t\treturn -EFAULT;\n\tureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\n\tif (IS_ERR(ureq)) {\n\t\tQETH_CARD_TEXT(card, 2, \"snmpnome\");\n\t\treturn PTR_ERR(ureq);\n\t}\n\tqinfo.udata_len = ureq->hdr.data_len;\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tkfree(ureq);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\n\t\t\t\t   QETH_SNMP_SETADP_CMDLENGTH + req_len);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\n\trc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\n\t\t\t\t    qeth_snmp_command_cb, (void *)&qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on %s: (0x%x)\\n\",\n\t\t\t   QETH_CARD_IFNAME(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\n\tkfree(ureq);\n\tkfree(qinfo.udata);\n\treturn rc;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInput, &input));\n  const TfLiteTensor* axis;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kAxis, &axis));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  output->type = input->type;\n  if (IsConstantTensor(axis)) {\n    int axis_value;\n    TF_LITE_ENSURE_OK(context,\n                      GetAxisValueFromTensor(context, *axis, &axis_value));\n    return ExpandTensorDim(context, *input, axis_value, output);\n  }\n  SetTensorToDynamic(output);\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tint len;\n\n\tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n\t\trfcomm_dlc_accept(d);\n\t\tmsg->msg_namelen = 0;\n\t\treturn 0;\n\t}\n\n\tlen = bt_sock_stream_recvmsg(iocb, sock, msg, size, flags);\n\n\tlock_sock(sk);\n\tif (!(flags & MSG_PEEK) && len > 0)\n\t\tatomic_sub(len, &sk->sk_rmem_alloc);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= (sk->sk_rcvbuf >> 2))\n\t\trfcomm_dlc_unthrottle(rfcomm_pi(sk)->dlc);\n\trelease_sock(sk);\n\n\treturn len;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid SPECTRA::run( Session* session, const std::string& argument ){\n\n  \n\n  if( session->loglevel >= 3 ) (*session->logfile) << \"SPECTRA handler reached\" << endl;\n\n\n   this->session = session;\n  checkImage();\n\n\n   if( session->loglevel >= 2 ) command_timer.start();\n\n\n   string arg = argument;\n  int delimitter = arg.find( \",\" );\n  int resolution = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  int tile = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  int x = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  int y = atoi( arg.substr(0,arg.length()).c_str() );\n\n  if( session->loglevel >= 5 ){ \n    (*session->logfile) << \"SPECTRA :: resolution: \" << resolution\n\t\t\t<< \", tile: \" << tile\n\t\t\t<< \", x: \" << x\n\t\t\t<< \", y: \" << y << endl;\n  }\n\n   if( x < 0 || x >= (int)(*session->image)->getTileWidth() ||\n      y < 0 || y >= (int)(*session->image)->getTileHeight() ){\n    throw invalid_argument( \"SPECTRA :: Error: x,y coordinates outside of tile boundaries\" );\n  }\n  \n\n  TileManager tilemanager( session->tileCache, *session->image, session->watermark, session->jpeg, session->logfile, session->loglevel );\n\n   list <int> views = (*session->image)->getHorizontalViewsList();\n  list <int> :: const_iterator i;\n\n   list <float> spectrum;\n\n\n#ifndef DEBUG\n   stringstream header;\n  header << session->response->createHTTPHeader( \"xml\", (*session->image)->getTimestamp() );\n  session->out->putStr( (const char*) header.str().c_str(), header.tellp() );\n  session->out->flush();\n#endif\n\n  session->out->putS( \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" );\n  session->out->putS( \"<spectra>\\n\" );\n  session->out->flush();\n\n  for( i = views.begin(); i != views.end(); i++ ){\n\n    int n = *i;\n\n    RawTile rawtile = tilemanager.getTile( resolution, tile, n, session->view->yangle, session->view->getLayers(), UNCOMPRESSED );\n\n       if( x >= (int)rawtile.width || y >= (int)rawtile.height ){\n      if( session->loglevel >= 1 ){\n\t(*session->logfile) << \"SPECTRA :: Error: x,y coordinates outside of tile boundaries\" << endl;\n      }\n      break;\n    }\n\n\n    unsigned int tw = (*session->image)->getTileWidth();\n    unsigned int index = y*tw + x;\n\n    void *ptr;\n    float reflectance = 0.0;\n\n    if( session->loglevel >= 5 ) (*session->logfile) << \"SPECTRA :: \" << rawtile.bpc << \" bits per channel data\" << endl;\n\n       if( rawtile.bpc == 8 ){\n      ptr = (unsigned char*) (rawtile.data);\n      reflectance = static_cast<float>((float)((unsigned char*)ptr)[index]) / 255.0;\n    }\n    else if( rawtile.bpc == 16 ){\n      ptr = (unsigned short*) (rawtile.data);\n      reflectance = static_cast<float>((float)((unsigned short*)ptr)[index]) / 65535.0;\n    }\n    else if( rawtile.bpc == 32 ){\n      if( rawtile.sampleType == FIXEDPOINT ) {\n        ptr = (unsigned int*) rawtile.data;\n        reflectance = static_cast<float>((float)((unsigned int*)ptr)[index]);\n      }\n      else {\n        ptr = (float*) rawtile.data;\n        reflectance = static_cast<float>((float)((float*)ptr)[index]);\n      }\n    }\n\n    spectrum.push_front( reflectance );\n\n    string metadata = (*session->image)->getMetadata( \"subject\" );\n\n    char tmp[1024];\n    snprintf( tmp, 1024, \"\\t<point>\\n\\t\\t<wavelength>%d</wavelength>\\n\\t\\t<reflectance>%f</reflectance>\\n\\t</point>\\n\", n, reflectance );\n    session->out->putS( tmp );\n    session->out->flush();\n\n    if( session->loglevel >= 3 ) (*session->logfile) << \"SPECTRA :: Band: \" << n << \", reflectance: \" << reflectance << endl;\n  }\n\n\n  session->out->putS( \"</spectra>\" );\n\n  if( session->out->flush() == -1 ) {\n    if( session->loglevel >= 1 ){\n      *(session->logfile) << \"SPECTRA :: Error flushing XML\" << endl;\n    }\n  }\n\n\n   session->response->setImageSent();\n\n   if( session->loglevel >= 2 ){\n    *(session->logfile) << \"SPECTRA :: Total command time \" << command_timer.getTime() << \" microseconds\" << endl;\n  }\n\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteType output_type = GetOutput(context, node, kOutputTensor)->type;\n\n  switch (output_type) {     case kTfLiteFloat32:\n      EvalUnquantized<float>(context, node);\n      break;\n    case kTfLiteInt32:\n      EvalUnquantized<int32_t>(context, node);\n      break;\n    case kTfLiteUInt8:\n      EvalQuantizedUInt8(context, node);\n      break;\n    case kTfLiteInt8:\n      EvalUnquantized<int8_t>(context, node);\n      break;\n    case kTfLiteInt64:\n      EvalUnquantized<int64_t>(context, node);\n      break;\n\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, \"Op Concatenation does not currently support Type '%s'.\",\n          TfLiteTypeGetName(output_type));\n      return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nl2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int handle_invept(struct kvm_vcpu *vcpu)\n{\n\tu32 vmx_instruction_info, types;\n\tunsigned long type;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand;\n\tu64 eptp_mask = ((1ull << 51) - 1) & PAGE_MASK;\n\n\tif (!(nested_vmx_secondary_ctls_high & SECONDARY_EXEC_ENABLE_EPT) ||\n\t    !(nested_vmx_ept_caps & VMX_EPT_INVEPT_BIT)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!kvm_read_cr0_bits(vcpu, X86_CR0_PE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_read(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\n\ttypes = (nested_vmx_ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;\n\n\tif (!(types & (1UL << type))) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\treturn 1;\n\t}\n\n\t\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmx_instruction_info, &gva))\n\t\treturn 1;\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &operand,\n\t\t\t\tsizeof(operand), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase VMX_EPT_EXTENT_CONTEXT:\n\t\tif ((operand.eptp & eptp_mask) !=\n\t\t\t\t(nested_ept_get_cr3(vcpu) & eptp_mask))\n\t\t\tbreak;\n\tcase VMX_EPT_EXTENT_GLOBAL:\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_mmu_flush_tlb(vcpu);\n\t\tnested_vmx_succeed(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(1);\n\t\tbreak;\n\t}\n\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint __fsnotify_parent(const struct path *path, struct dentry *dentry, __u32 mask)\n{\n\tstruct dentry *parent;\n\tstruct inode *p_inode;\n\tint ret = 0;\n\n\tif (!dentry)\n\t\tdentry = path->dentry;\n\n\tif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\n\t\treturn 0;\n\n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\n\tif (unlikely(!fsnotify_inode_watches_children(p_inode)))\n\t\t__fsnotify_update_child_dentry_flags(p_inode);\n\telse if (p_inode->i_fsnotify_mask & mask) {\n\t\t\n\t\tmask |= FS_EVENT_ON_CHILD;\n\n\t\tif (path)\n\t\t\tret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,\n\t\t\t\t       dentry->d_name.name, 0);\n\t\telse\n\t\t\tret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,\n\t\t\t\t       dentry->d_name.name, 0);\n\t}\n\n\tdput(parent);\n\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nerror_t ksz8851ReceivePacket(NetInterface *interface)\n{\n   size_t n;\n   uint16_t status;\n   Ksz8851Context *context;\n   NetRxAncillary ancillary;\n\n     context = (Ksz8851Context *) interface->nicContext;\n\n     status = ksz8851ReadReg(interface, KSZ8851_REG_RXFHSR);\n\n     if((status & RXFHSR_RXFV) != 0)\n   {\n           if((status & (RXFHSR_RXMR | RXFHSR_RXFTL | RXFHSR_RXRF | RXFHSR_RXCE)) == 0)\n      {\n                 n = ksz8851ReadReg(interface, KSZ8851_REG_RXFHBCR) & RXFHBCR_RXBC_MASK;\n\n                 if(n > 0 && n <= ETH_MAX_FRAME_SIZE)\n         {\n                       ksz8851WriteReg(interface, KSZ8851_REG_RXFDPR, RXFDPR_RXFPAI);\n                       ksz8851SetBit(interface, KSZ8851_REG_RXQCR, RXQCR_SDA);\n                       ksz8851ReadFifo(interface, context->rxBuffer, n);\n                       ksz8851ClearBit(interface, KSZ8851_REG_RXQCR, RXQCR_SDA);\n\n                       ancillary = NET_DEFAULT_RX_ANCILLARY;\n\n                       nicProcessPacket(interface, context->rxBuffer, n, &ancillary);\n                       return NO_ERROR;\n         }\n      }\n   }\n\n     ksz8851SetBit(interface, KSZ8851_REG_RXQCR, RXQCR_RRXEF);\n     return ERROR_INVALID_PACKET;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\njuniper_monitor_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_monitor_header {\n            uint8_t pkt_type;\n            uint8_t padding;\n            uint8_t iif[2];\n            uint8_t service_id[4];\n        };\n        const struct juniper_monitor_header *mh;\n\n        l2info.pictype = DLT_JUNIPER_MONITOR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n        mh = (const struct juniper_monitor_header *)p;\n\n        ND_TCHECK(*mh);\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"service-id %u, iif %u, pkt-type %u: \",\n                   EXTRACT_32BITS(&mh->service_id),\n                   EXTRACT_16BITS(&mh->iif),\n                   mh->pkt_type));\n\n        \n        ip_heuristic_guess (ndo, p, l2info.length);\n\n        return l2info.header_len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool initialise_control(rzip_control *control)\n{\n\ttime_t now_t, tdiff;\n\tchar localeptr[] = \"./\", *eptr; \n\tsize_t len;\n\n\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = strdup(\".lrz\");\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\t\n\tcontrol->threads = PROCESSORS;\t\n\tcontrol->page_size = PAGE_SIZE;\n\tcontrol->nice_val = 19;\n\n\t\n\tif (unlikely((now_t = time(NULL)) == ((time_t)-1)))\n\t\tfatal_return((\"Failed to call time in main\\n\"), false);\n\tif (unlikely(now_t < T_ZERO)) {\n\t\tprint_output(\"Warning your time reads before the year 2011, check your system clock\\n\");\n\t\tnow_t = T_ZERO;\n\t}\n\t\n\ttdiff = (now_t - T_ZERO) / 4;\n\tnow_t = T_ZERO + tdiff;\n\tcontrol->secs = now_t;\n\tcontrol->encloops = nloops(control->secs, control->salt, control->salt + 1);\n\tif (unlikely(!get_rand(control, control->salt + 2, 6)))\n\t\treturn false;\n\n\t\n\teptr = getenv(\"TMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TMP\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMP\");\n\tif (!eptr)\n\t\teptr = localeptr;\n\tlen = strlen(eptr);\n\n\tcontrol->tmpdir = malloc(len + 2);\n\tif (control->tmpdir == NULL)\n\t\tfatal_return((\"Failed to allocate for tmpdir\\n\"), false);\n\tstrcpy(control->tmpdir, eptr);\n\tif (control->tmpdir[len - 1] != '/') {\n\t\tcontrol->tmpdir[len] = '/'; \n\t\tcontrol->tmpdir[len + 1] = '\\0';\n\t}\n\treturn true;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t   struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sk_buff\t\t*skb;\n\tstruct sock\t\t*sk = sock->sk;\n\tstruct sockaddr_mISDN\t*maddr;\n\n\tint\t\tcopied, err;\n\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: len %d, flags %x ch.nr %d, proto %x\\n\",\n\t\t       __func__, (int)len, flags, _pms(sk)->ch.nr,\n\t\t       sk->sk_protocol);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state == MISDN_CLOSED)\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tif (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {\n\t\tmsg->msg_namelen = sizeof(struct sockaddr_mISDN);\n\t\tmaddr = (struct sockaddr_mISDN *)msg->msg_name;\n\t\tmaddr->family = AF_ISDN;\n\t\tmaddr->dev = _pms(sk)->dev->id;\n\t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n\t\t    (sk->sk_protocol == ISDN_P_LAPD_NT)) {\n\t\t\tmaddr->channel = (mISDN_HEAD_ID(skb) >> 16) & 0xff;\n\t\t\tmaddr->tei =  (mISDN_HEAD_ID(skb) >> 8) & 0xff;\n\t\t\tmaddr->sapi = mISDN_HEAD_ID(skb) & 0xff;\n\t\t} else {\n\t\t\tmaddr->channel = _pms(sk)->ch.nr;\n\t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n\t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n\t\t}\n\t} else {\n\t\tif (msg->msg_namelen)\n\t\t\tprintk(KERN_WARNING \"%s: too small namelen %d\\n\",\n\t\t\t       __func__, msg->msg_namelen);\n\t\tmsg->msg_namelen = 0;\n\t}\n\n\tcopied = skb->len + MISDN_HEADER_LEN;\n\tif (len < copied) {\n\t\tif (flags & MSG_PEEK)\n\t\t\tatomic_dec(&skb->users);\n\t\telse\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -ENOSPC;\n\t}\n\tmemcpy(skb_push(skb, MISDN_HEADER_LEN), mISDN_HEAD_P(skb),\n\t       MISDN_HEADER_LEN);\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tmISDN_sock_cmsg(sk, msg, skb);\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nchar *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Path Traversal"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nMap1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            \n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic bool download_and_write(SPDBDownloaderOpt *opt, const char *file) {\n\tchar *dir = r_str_newf (\"%s%s%s%s%s\",\n\t\topt->symbol_store_path, R_SYS_DIR,\n\t\topt->dbg_file, R_SYS_DIR,\n\t\topt->guid);\n\tif (!r_sys_mkdirp (dir)) {\n\t\tfree (dir);\n\t\treturn false;\n\t}\n\tchar *url = r_str_newf (\"%s/%s/%s/%s\", opt->symbol_server, opt->dbg_file, opt->guid, file);\n\tint len;\n\tchar *file_buf = r_socket_http_get (url, NULL, &len);\n\tfree (url);\n\tif (!len || R_STR_ISEMPTY (file_buf)) {\n\t\tfree (dir);\n\t\tfree (file_buf);\n\t\treturn false;\n\t}\n\tchar *path = r_str_newf (\"%s%s%s\", dir, R_SYS_DIR, opt->dbg_file);\n\tFILE *f = fopen (path, \"wb\");\n\tif (f) {\n\t\tfwrite (file_buf, sizeof (char), (size_t)len, f);\n\t\tfclose (f);\n\t}\n\tfree (dir);\n\tfree (path);\n\tfree (file_buf);\n\treturn true;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\naodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n{\n\tconst struct aodv_hello *ah;\n\n\tND_TCHECK(*ep);\n\tswitch (ep->type) {\n\tcase AODV_EXT_HELLO:\n\t\tah = (const struct aodv_hello *)(const void *)ep;\n\t\tND_TCHECK(*ah);\n\t\tif (length < sizeof(struct aodv_hello))\n\t\t\tgoto trunc;\n\t\tif (ep->length < 4) {\n\t\t\tND_PRINT((ndo, \"\\n\\text HELLO - bad length %u\", ep->length));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n\t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n\t\tbreak;\n\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool test_r_str_escape_sh(void) {\n\tchar *escaped = r_str_escape_sh (\"Hello, \\\"World\\\"\");\n\tmu_assert_streq (escaped, \"Hello, \\\\\\\"World\\\\\\\"\", \"escaped \\\"double quotes\\\"\");\n\tfree (escaped);\n\tescaped = r_str_escape_sh (\"Hello, \\\\World\\\\\");\n\tmu_assert_streq (escaped, \"Hello, \\\\\\\\World\\\\\\\\\", \"escaped backspace\");\n\tfree (escaped);\n#if __UNIX__\n\tescaped = r_str_escape_sh (\"Hello, $(World)\");\n\tmu_assert_streq (escaped, \"Hello, \\\\$(World)\", \"escaped $(command)\");\n\tfree (escaped);\n\tescaped = r_str_escape_sh (\"Hello, `World`\");\n\tmu_assert_streq (escaped, \"Hello, \\\\`World\\\\`\", \"escaped `command`\");\n\tfree (escaped);\n#endif\n\tmu_end;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150) \n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    if(reasonLen > 1<<20) {\n      rfbClientLog(\"VNC connection failed, but sent reason length of %u exceeds limit of 1MB\",(unsigned int)reasonLen);\n      return;\n    }\n    reason = malloc(reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int msg_parse_fetch (IMAP_HEADER *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS (s);\n\n    if (ascii_strncasecmp (\"FLAGS\", s, 5) == 0)\n    {\n      if ((s = msg_parse_flags (h, s)) == NULL)\n        return -1;\n    }\n    else if (ascii_strncasecmp (\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS (s);\n      if (mutt_atoui (s, &h->data->uid) < 0)\n        return -1;\n\n      s = imap_next_word (s);\n    }\n    else if (ascii_strncasecmp (\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS (s);\n      if (*s != '\\\"')\n      {\n        dprint (1, (debugfile, \"msg_parse_fetch(): bogus INTERNALDATE entry: %s\\n\", s));\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; \n      *ptmp = 0;\n      h->received = imap_parse_date (tmp);\n    }\n    else if (ascii_strncasecmp (\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS (s);\n      ptmp = tmp;\n      while (isdigit ((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = 0;\n      if (mutt_atol (tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if (!ascii_strncasecmp (\"BODY\", s, 4) ||\n      !ascii_strncasecmp (\"RFC822.HEADER\", s, 13))\n    {\n      \n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      \n      imap_error (\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n\n  return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic TEE_Result tee_svc_copy_param(struct tee_ta_session *sess,\n\t\t\t\t     struct tee_ta_session *called_sess,\n\t\t\t\t     struct utee_params *callee_params,\n\t\t\t\t     struct tee_ta_param *param,\n\t\t\t\t     void *tmp_buf_va[TEE_NUM_PARAMS],\n\t\t\t\t     struct mobj **mobj_tmp)\n{\n\tsize_t n;\n\tTEE_Result res;\n\tsize_t req_mem = 0;\n\tsize_t s;\n\tuint8_t *dst = 0;\n\tbool ta_private_memref[TEE_NUM_PARAMS];\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tvoid *va;\n\tsize_t dst_offs;\n\n\t\n\tif (!callee_params) {\n\t\tmemset(param, 0, sizeof(*param));\n\t} else {\n\t\tres = tee_mmu_check_access_rights(utc,\n\t\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t(uaddr_t)callee_params, sizeof(struct utee_params));\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tres = utee_param_to_param(utc, param, callee_params);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {\n\t\t\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tta_private_memref[n] = false;\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\ts = param->u[n].mem.size;\n\t\t\tif (!va) {\n\t\t\t\tif (s)\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (tee_mmu_is_vbuf_inside_ta_private(utc, va, s)) {\n\n\t\t\t\ts = ROUNDUP(s, sizeof(uint32_t));\n\t\t\t\tif (ADD_OVERFLOW(req_mem, s, &req_mem))\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tta_private_memref[n] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tres = tee_mmu_vbuf_to_mobj_offs(utc, va, s,\n\t\t\t\t\t\t\t&param->u[n].mem.mobj,\n\t\t\t\t\t\t\t&param->u[n].mem.offs);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (req_mem == 0)\n\t\treturn TEE_SUCCESS;\n\n\tres = alloc_temp_sec_mem(req_mem, mobj_tmp, &dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdst_offs = 0;\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tif (!ta_private_memref[n])\n\t\t\tcontinue;\n\n\t\ts = ROUNDUP(param->u[n].mem.size, sizeof(uint32_t));\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tres = tee_svc_copy_from_user(dst, va,\n\t\t\t\t\t\tparam->u[n].mem.size);\n\t\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\t\treturn res;\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int do_timer_create(clockid_t which_clock, struct sigevent *event,\n\t\t\t   timer_t __user *created_timer_id)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct k_itimer *new_timer;\n\tint error, new_timer_id;\n\tint it_id_set = IT_ID_NOT_SET;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->timer_create)\n\t\treturn -EOPNOTSUPP;\n\n\tnew_timer = alloc_posix_timer();\n\tif (unlikely(!new_timer))\n\t\treturn -EAGAIN;\n\n\tspin_lock_init(&new_timer->it_lock);\n\tnew_timer_id = posix_timer_add(new_timer);\n\tif (new_timer_id < 0) {\n\t\terror = new_timer_id;\n\t\tgoto out;\n\t}\n\n\tit_id_set = IT_ID_SET;\n\tnew_timer->it_id = (timer_t) new_timer_id;\n\tnew_timer->it_clock = which_clock;\n\tnew_timer->kclock = kc;\n\tnew_timer->it_overrun = -1LL;\n\n\tif (event) {\n\t\trcu_read_lock();\n\t\tnew_timer->it_pid = get_pid(good_sigevent(event));\n\t\trcu_read_unlock();\n\t\tif (!new_timer->it_pid) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_timer->it_sigev_notify     = event->sigev_notify;\n\t\tnew_timer->sigq->info.si_signo = event->sigev_signo;\n\t\tnew_timer->sigq->info.si_value = event->sigev_value;\n\t} else {\n\t\tnew_timer->it_sigev_notify     = SIGEV_SIGNAL;\n\t\tnew_timer->sigq->info.si_signo = SIGALRM;\n\t\tmemset(&new_timer->sigq->info.si_value, 0, sizeof(sigval_t));\n\t\tnew_timer->sigq->info.si_value.sival_int = new_timer->it_id;\n\t\tnew_timer->it_pid = get_pid(task_tgid(current));\n\t}\n\n\tnew_timer->sigq->info.si_tid   = new_timer->it_id;\n\tnew_timer->sigq->info.si_code  = SI_TIMER;\n\n\tif (copy_to_user(created_timer_id,\n\t\t\t &new_timer_id, sizeof (new_timer_id))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terror = kc->timer_create(new_timer);\n\tif (error)\n\t\tgoto out;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tnew_timer->it_signal = current->signal;\n\tlist_add(&new_timer->list, &current->signal->posix_timers);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn 0;\n\t\nout:\n\trelease_posix_timer(new_timer, it_id_set);\n\treturn error;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\n\t\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\t\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid * pvPortMalloc( size_t xWantedSize )\n{\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\n    static BaseType_t xHeapHasBeenInitialised = pdFALSE;\n    void * pvReturn = NULL;\n\n    vTaskSuspendAll();\n    {\n        \n        if( xHeapHasBeenInitialised == pdFALSE )\n        {\n            prvHeapInit();\n            xHeapHasBeenInitialised = pdTRUE;\n        }\n\n        \n        if( ( xWantedSize > 0 ) && \n            ( ( xWantedSize + heapSTRUCT_SIZE ) >  xWantedSize ) ) \n        {\n            xWantedSize += heapSTRUCT_SIZE;\n\n            \n            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) \n                    > xWantedSize )\n            {\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n                configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\n            }\n            else\n            {\n                xWantedSize = 0;\n            }       \n        }\n        else \n        {\n            xWantedSize = 0; \n        }\n\n\n        if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\n        {\n            \n            pxPreviousBlock = &xStart;\n            pxBlock = xStart.pxNextFreeBlock;\n\n            while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\n            {\n                pxPreviousBlock = pxBlock;\n                pxBlock = pxBlock->pxNextFreeBlock;\n            }\n\n            \n            if( pxBlock != &xEnd )\n            {\n                \n                pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );\n\n                \n                pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\n\n                \n                if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\n                {\n                    \n                    pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\n\n                    \n                    pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\n                    pxBlock->xBlockSize = xWantedSize;\n\n                    \n                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\n                }\n\n                xFreeBytesRemaining -= pxBlock->xBlockSize;\n            }\n        }\n\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n\n    return pvReturn;\n}\n\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  static const int kOutputUniqueTensor = 0;\n  static const int kOutputIndexTensor = 1;\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 2);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output_unique_tensor =\n      GetOutput(context, node, kOutputUniqueTensor);\n  TfLiteTensor* output_index_tensor =\n      GetOutput(context, node, kOutputIndexTensor);\n\n   TF_LITE_ENSURE_EQ(context, NumDimensions(input), 1);\n  TfLiteIntArray* output_index_shape = TfLiteIntArrayCopy(input->dims);\n    SetTensorToDynamic(output_unique_tensor);\n  return context->ResizeTensor(context, output_index_tensor,\n                               output_index_shape);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n          const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n\n    const auto num_indices = indices->NumElements();\n    const auto num_values = values->NumElements();\n    if (num_indices == 0 || num_values == 0) {\n      OP_REQUIRES(ctx, num_indices == num_values,\n                  errors::InvalidArgument(\n                      \"If indices or values are empty, the other one must also \"\n                      \"be. Got indices of shape \",\n                      indices->shape().DebugString(), \" and values of shape \",\n                      values->shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n\n                      int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64_t>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64_t, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64_t>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nqedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t     const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t       nfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\n\tva_end(va);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nber_parse_header(STREAM s, int tagval, int *length)\n{\n\tint tag, len;\n\n\tif (tagval > 0xff)\n\t{\n\t\tin_uint16_be(s, tag);\n\t}\n\telse\n\t{\n\t\tin_uint8(s, tag);\n\t}\n\n\tif (tag != tagval)\n\t{\n\t\tlogger(Core, Error, \"ber_parse_header(), expected tag %d, got %d\", tagval, tag);\n\t\treturn False;\n\t}\n\n\tin_uint8(s, len);\n\n\tif (len & 0x80)\n\t{\n\t\tlen &= ~0x80;\n\t\t*length = 0;\n\t\twhile (len--)\n\t\t\tnext_be(s, *length);\n\t}\n\telse\n\t\t*length = len;\n\n\treturn s_check(s);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstring_object_to_c_ast(const char *s, PyObject *filename, int start,\n                             PyCompilerFlags *flags, int feature_version,\n                             PyArena *arena)\n{\n    mod_ty mod;\n    PyCompilerFlags localflags;\n    perrdetail err;\n    int iflags = PARSER_FLAGS(flags);\n\n    node *n = Ta3Parser_ParseStringObject(s, filename,\n                                         &_Ta3Parser_Grammar, start, &err,\n                                         &iflags);\n    if (flags == NULL) {\n        localflags.cf_flags = 0;\n        flags = &localflags;\n    }\n    if (n) {\n        flags->cf_flags |= iflags & PyCF_MASK;\n        mod = Ta3AST_FromNodeObject(n, flags, filename, feature_version, arena);\n        Ta3Node_Free(n);\n    }\n    else {\n        err_input(&err);\n        mod = NULL;\n    }\n    err_free(&err);\n    return mod;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int http_read_stream(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int err, new_location, read_ret;\n    int64_t seek_ret;\n\n    if (!s->hd)\n        return AVERROR_EOF;\n\n    if (s->end_chunked_post && !s->end_header) {\n        err = http_read_header(h, &new_location);\n        if (err < 0)\n            return err;\n    }\n\n    if (s->chunksize >= 0) {\n        if (!s->chunksize) {\n            char line[32];\n\n                do {\n                    if ((err = http_get_line(s, line, sizeof(line))) < 0)\n                        return err;\n                } while (!*line);    \n\n                s->chunksize = strtoll(line, NULL, 16);\n\n                av_log(NULL, AV_LOG_TRACE, \"Chunked encoding data size: %\"PRId64\"'\\n\",\n                        s->chunksize);\n\n                if (!s->chunksize)\n                    return 0;\n        }\n        size = FFMIN(size, s->chunksize);\n    }\n#if CONFIG_ZLIB\n    if (s->compressed)\n        return http_buf_read_compressed(h, buf, size);\n#endif \n    read_ret = http_buf_read(h, buf, size);\n    if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)\n        || (read_ret == 0 && s->reconnect_at_eof && (!h->is_streamed || s->reconnect_streamed))) {\n        int64_t target = h->is_streamed ? 0 : s->off;\n\n        if (s->reconnect_delay > s->reconnect_delay_max)\n            return AVERROR(EIO);\n\n        av_log(h, AV_LOG_INFO, \"Will reconnect at %\"PRId64\" error=%s.\\n\", s->off, av_err2str(read_ret));\n        av_usleep(1000U*1000*s->reconnect_delay);\n        s->reconnect_delay = 1 + 2*s->reconnect_delay;\n        seek_ret = http_seek_internal(h, target, SEEK_SET, 1);\n        if (seek_ret != target) {\n            av_log(h, AV_LOG_ERROR, \"Failed to reconnect at %\"PRId64\".\\n\", target);\n            return read_ret;\n        }\n\n        read_ret = http_buf_read(h, buf, size);\n    } else\n        s->reconnect_delay = 0;\n\n    return read_ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n    int overrun(int itemSize, int nItems, bool wait) { throw EndOfStream(); }\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ntranslate_hex_string(char *s, char *saved_orphan)\n{\n  int c1 = *saved_orphan;\n  char *start = s;\n  char *t = s;\n  for (; *s; s++) {\n    if (isspace((unsigned char) *s))\n      continue;\n    if (c1) {\n      *t++ = (hexval(c1) << 4) + hexval(*s);\n      c1 = 0;\n    } else\n      c1 = *s;\n  }\n  *saved_orphan = c1;\n  return t - start;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint len = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t\n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tlen = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tmutex_unlock(&dev->io_mutex);\n\n\treturn simple_read_from_buffer(buffer, count, ppos, in_buffer, len);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (input1->type) {\n    case kTfLiteInt32: {\n      return EvalImpl<int32_t>(context, data->requires_broadcast, input1,\n                               input2, output);\n    }\n    case kTfLiteInt64: {\n      return EvalImpl<int64_t>(context, data->requires_broadcast, input1,\n                               input2, output);\n    }\n    case kTfLiteFloat32: {\n      return EvalImpl<float>(context, data->requires_broadcast, input1, input2,\n                             output);\n    }\n    default: {\n      context->ReportError(context, \"Type '%s' is not supported by floor_mod.\",\n                           TfLiteTypeGetName(input1->type));\n      return kTfLiteError;\n    }\n  }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  ruy::profiler::ScopeLabel label(\"SquaredDifference\");\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type == kTfLiteFloat32) {\n    EvalSquaredDifference<float>(context, node, data, input1, input2, output);\n  } else if (output->type == kTfLiteInt32) {\n    EvalSquaredDifference<int32_t>(context, node, data, input1, input2, output);\n  } else {\n    context->ReportError(\n        context,\n        \"SquaredDifference only supports FLOAT32 and INT32 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int lookup_attr_id(PyObject *v, _Py_Identifier *name, PyObject **result)\n{\n    PyObject *oname = _PyUnicode_FromId(name); \n    if (!oname) {\n        *result = NULL;\n        return -1;\n    }\n    *result = PyObject_GetAttr(v, oname);\n    if (*result == NULL) {\n        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {\n            return -1;\n        }\n        PyErr_Clear();\n    }\n    return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTEST_F(QuantizedConv2DTest, SmallWithNoZero) {\n  const int stride = 1;\n  TF_ASSERT_OK(NodeDefBuilder(\"quantized_conv_op\", \"QuantizedConv2D\")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"out_type\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"strides\", {1, stride, stride, 1})\n                   .Attr(\"padding\", \"SAME\")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  const int depth = 1;\n  const int image_width = 4;\n  const int image_height = 3;\n  const int image_batch_count = 1;\n     const float image_min = 1.0f;\n  const float image_max = 12.0f;\n  Tensor image_float(DT_FLOAT,\n                     {image_batch_count, image_height, image_width, depth});\n  test::FillValues<float>(&image_float,\n                          {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});\n  Tensor image_quantized =\n      FloatTensorToQuantized<quint8>(image_float, image_min, image_max);\n  const int filter_size = 3;\n  const int filter_count = 1;\n  const float filter_min = 1.0f;\n  const float filter_max = 9.0f;\n  Tensor filter_float(DT_FLOAT,\n                      {filter_size, filter_size, depth, filter_count});\n  test::FillValues<float>(&filter_float, {1, 4, 7, 2, 5, 8, 3, 6, 9});\n  Tensor filter_quantized =\n      FloatTensorToQuantized<quint8>(filter_float, filter_min, filter_max);\n  AddInputFromArray<quint8>(image_quantized.shape(),\n                            image_quantized.flat<quint8>());\n  AddInputFromArray<quint8>(filter_quantized.shape(),\n                            filter_quantized.flat<quint8>());\n  AddInputFromArray<float>(TensorShape({}), {image_min});\n  AddInputFromArray<float>(TensorShape({}), {image_max});\n  AddInputFromArray<float>(TensorShape({}), {filter_min});\n  AddInputFromArray<float>(TensorShape({}), {filter_max});\n  TF_ASSERT_OK(RunOpKernel());\n  const int expected_width = image_width;\n  const int expected_height = image_height * filter_count;\n  Tensor expected_float(\n      DT_FLOAT, TensorShape({image_batch_count, expected_height, expected_width,\n                             filter_count}));\n  test::FillValues<float>(&expected_float, {105, 150, 183, 95, 235, 312, 357,\n                                            178, 187, 234, 261, 121});\n  const Tensor& output_quantized = *GetOutput(0);\n  const float output_min = GetOutput(1)->flat<float>()(0);\n  const float output_max = GetOutput(2)->flat<float>()(0);\n  Tensor output_float =\n      QuantizedTensorToFloat<qint32>(output_quantized, output_min, output_max);\n  test::ExpectTensorNear<float>(expected_float, output_float, 1.0);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteAddParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  output->type = input2->type;\n\n  const bool requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n    bool pot_scale_int16 = true;\n\n  bool input1_scale_is_pot = false;\n  bool input2_scale_is_pot = false;\n  bool output_scale_is_pot = false;\n\n  int input1_scale_log2_rounded{0};\n  int input2_scale_log2_rounded{0};\n  int output_scale_log2_rounded{0};\n\n  if (input1->type == kTfLiteInt16 && input2->type == kTfLiteInt16 &&\n      output->type == kTfLiteInt16) {\n                pot_scale_int16 = (input1->params.zero_point == 0) &&\n                      (input2->params.zero_point == 0) &&\n                      (output->params.zero_point == 0);\n\n    input1_scale_is_pot =\n        CheckedLog2(input1->params.scale, &input1_scale_log2_rounded);\n\n    input2_scale_is_pot =\n        CheckedLog2(input2->params.scale, &input2_scale_log2_rounded);\n\n    output_scale_is_pot =\n        CheckedLog2(output->params.scale, &output_scale_log2_rounded);\n\n    pot_scale_int16 &=\n        input1_scale_is_pot && input2_scale_is_pot && output_scale_is_pot;\n  }\n\n  data->pot_scale_int16 = pot_scale_int16;\n\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||\n      !pot_scale_int16) {\n          data->input1_offset = -input1->params.zero_point;\n    data->input2_offset = -input2->params.zero_point;\n    data->output_offset = output->params.zero_point;\n\n             data->left_shift = !pot_scale_int16 ? 15 : 20;\n    const double twice_max_input_scale =\n        2 * std::max(input1->params.scale, input2->params.scale);\n    const double real_input1_multiplier =\n        input1->params.scale / twice_max_input_scale;\n    const double real_input2_multiplier =\n        input2->params.scale / twice_max_input_scale;\n    const double real_output_multiplier =\n        twice_max_input_scale /\n        ((1 << data->left_shift) * output->params.scale);\n\n    QuantizeMultiplierSmallerThanOneExp(\n        real_input1_multiplier, &data->input1_multiplier, &data->input1_shift);\n\n    QuantizeMultiplierSmallerThanOneExp(\n        real_input2_multiplier, &data->input2_multiplier, &data->input2_shift);\n\n    QuantizeMultiplierSmallerThanOneExp(\n        real_output_multiplier, &data->output_multiplier, &data->output_shift);\n\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, params->activation, output, &data->output_activation_min,\n        &data->output_activation_max));\n  } else if (output->type == kTfLiteInt16) {\n                            TF_LITE_ENSURE_EQ(context, input1->params.zero_point, 0);\n    TF_LITE_ENSURE_EQ(context, input2->params.zero_point, 0);\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);\n\n    TF_LITE_ENSURE(context, input1_scale_is_pot);\n    TF_LITE_ENSURE(context, input2_scale_is_pot);\n    TF_LITE_ENSURE(context, output_scale_is_pot);\n\n    data->input1_shift = input1_scale_log2_rounded - output_scale_log2_rounded;\n    data->input2_shift = input2_scale_log2_rounded - output_scale_log2_rounded;\n\n          TF_LITE_ENSURE(context, data->input1_shift == 0 || data->input2_shift == 0);\n    TF_LITE_ENSURE(context, data->input1_shift <= 0);\n    TF_LITE_ENSURE(context, data->input2_shift <= 0);\n\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, params->activation, output, &data->output_activation_min,\n        &data->output_activation_max));\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic Jsi_RC ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_Interp *interp = tree->opts.interp;\n    Jsi_Obj *obj = (Jsi_Obj*)data;\n    int n;\n    if (!hPtr->f.bits.dontenum) {\n        char *ep = NULL, *cp = (char*)Jsi_TreeKeyGet(hPtr);\n        if (!cp || !isdigit(*cp))\n            return JSI_OK;\n        n = (int)strtol(cp, &ep, 0);\n        if (n<0 || (uint)n >= interp->maxArrayList)\n            return JSI_OK;\n        hPtr->f.bits.isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, obj, n) <= 0) \n            return Jsi_LogError(\"too long\");\n        obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n          }\n    return JSI_OK;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid flush_tlb_page(struct vm_area_struct *vma, unsigned long start)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpreempt_disable();\n\n\tif (current->active_mm == mm) {\n\t\tif (current->mm)\n\t\t\t__flush_tlb_one(start);\n\t\telse\n\t\t\tleave_mm(smp_processor_id());\n\t}\n\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, 0UL);\n\n\tpreempt_enable();\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid Filter::onDownstreamEvent(Network::ConnectionEvent event) {\n  if (event == Network::ConnectionEvent::LocalClose ||\n      event == Network::ConnectionEvent::RemoteClose) {\n    downstream_closed_ = true;\n  }\n\n  ENVOY_CONN_LOG(trace, \"on downstream event {}, has upstream = {}\", read_callbacks_->connection(),\n                 static_cast<int>(event), upstream_ == nullptr);\n\n  if (upstream_) {\n    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));\n    if (conn_data != nullptr &&\n        conn_data->connection().state() != Network::Connection::State::Closed) {\n      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),\n                                  std::move(upstream_callbacks_), std::move(idle_timer_),\n                                  read_callbacks_->upstreamHost());\n    }\n    if (event != Network::ConnectionEvent::Connected) {\n      upstream_.reset();\n      disableIdleTimer();\n    }\n  }\n  if (generic_conn_pool_) {\n    if (event == Network::ConnectionEvent::LocalClose ||\n        event == Network::ConnectionEvent::RemoteClose) {\n           generic_conn_pool_.reset();\n    }\n  }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbuiltin_compile_impl(PyObject *module, PyObject *source, PyObject *filename,\n                     const char *mode, int flags, int dont_inherit,\n                     int optimize)\n\n{\n    PyObject *source_copy;\n    const char *str;\n    int compile_mode = -1;\n    int is_ast;\n    PyCompilerFlags cf;\n    int start[] = {Py_file_input, Py_eval_input, Py_single_input, Py_func_type_input};\n    PyObject *result;\n\n    cf.cf_flags = flags | PyCF_SOURCE_IS_UTF8;\n\n    if (flags &\n        ~(PyCF_MASK | PyCF_MASK_OBSOLETE | PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST | PyCF_TYPE_COMMENTS))\n    {\n        PyErr_SetString(PyExc_ValueError,\n                        \"compile(): unrecognised flags\");\n        goto error;\n    }\n    \n\n    if (optimize < -1 || optimize > 2) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"compile(): invalid optimize value\");\n        goto error;\n    }\n\n    if (!dont_inherit) {\n        PyEval_MergeCompilerFlags(&cf);\n    }\n\n    if (strcmp(mode, \"exec\") == 0)\n        compile_mode = 0;\n    else if (strcmp(mode, \"eval\") == 0)\n        compile_mode = 1;\n    else if (strcmp(mode, \"single\") == 0)\n        compile_mode = 2;\n    else if (strcmp(mode, \"func_type\") == 0) {\n        if (!(flags & PyCF_ONLY_AST)) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"compile() mode 'func_type' requires flag PyCF_ONLY_AST\");\n            goto error;\n        }\n        compile_mode = 3;\n    }\n    else {\n        const char *msg;\n        if (flags & PyCF_ONLY_AST)\n            msg = \"compile() mode must be 'exec', 'eval', 'single' or 'func_type'\";\n        else\n            msg = \"compile() mode must be 'exec', 'eval' or 'single'\";\n        PyErr_SetString(PyExc_ValueError, msg);\n        goto error;\n    }\n\n    is_ast = PyAST_Check(source);\n    if (is_ast == -1)\n        goto error;\n    if (is_ast) {\n        if (flags & PyCF_ONLY_AST) {\n            Py_INCREF(source);\n            result = source;\n        }\n        else {\n            PyArena *arena;\n            mod_ty mod;\n\n            arena = PyArena_New();\n            if (arena == NULL)\n                goto error;\n            mod = PyAST_obj2mod(source, arena, compile_mode);\n            if (mod == NULL) {\n                PyArena_Free(arena);\n                goto error;\n            }\n            if (!PyAST_Validate(mod)) {\n                PyArena_Free(arena);\n                goto error;\n            }\n            result = (PyObject*)PyAST_CompileObject(mod, filename,\n                                                    &cf, optimize, arena);\n            PyArena_Free(arena);\n        }\n        goto finally;\n    }\n\n    str = source_as_string(source, \"compile\", \"string, bytes or AST\", &cf, &source_copy);\n    if (str == NULL)\n        goto error;\n\n    result = Py_CompileStringObject(str, filename, start[compile_mode], &cf, optimize);\n    Py_XDECREF(source_copy);\n    goto finally;\n\nerror:\n    result = NULL;\nfinally:\n    Py_DECREF(filename);\n    return result;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ncleanup_pathname(struct archive_write_disk *a)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = a->name;\n\tif (*src == '\\0') {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\t\n\tif (*src == '/') {\n\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t                  \"Path is absolute\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\tseparator = *src++;\n\t}\n\n\t\n\tfor (;;) {\n\t\t\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t\n\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t\n\t\tseparator = *src++;\n\t}\n\t\n\tif (dest == a->name) {\n\t\t\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    PadContext *s = inlink->dst->priv;\n    AVFrame *out;\n    int needs_copy = frame_needs_copy(s, in);\n\n    if (needs_copy) {\n        av_log(inlink->dst, AV_LOG_DEBUG, \"Direct padding impossible allocating new frame\\n\");\n        out = ff_get_video_buffer(inlink->dst->outputs[0],\n                                  FFMAX(inlink->w, s->w),\n                                  FFMAX(inlink->h, s->h));\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n\n        av_frame_copy_props(out, in);\n    } else {\n        int i;\n\n        out = in;\n        for (i = 0; i < 4 && out->data[i]; i++) {\n            int hsub = s->draw.hsub[i];\n            int vsub = s->draw.vsub[i];\n            out->data[i] -= (s->x >> hsub) * s->draw.pixelstep[i] +\n                            (s->y >> vsub) * out->linesize[i];\n        }\n    }\n\n    \n    if (s->y) {\n        ff_fill_rectangle(&s->draw, &s->color,\n                          out->data, out->linesize,\n                          0, 0, s->w, s->y);\n    }\n\n    \n    if (s->h > s->y + s->in_h) {\n        ff_fill_rectangle(&s->draw, &s->color,\n                          out->data, out->linesize,\n                          0, s->y + s->in_h, s->w, s->h - s->y - s->in_h);\n    }\n\n    \n    ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,\n                      0, s->y, s->x, in->height);\n\n    if (needs_copy) {\n        ff_copy_rectangle2(&s->draw,\n                          out->data, out->linesize, in->data, in->linesize,\n                          s->x, s->y, 0, 0, in->width, in->height);\n    }\n\n    \n    ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,\n                      s->x + s->in_w, s->y, s->w - s->x - s->in_w,\n                      in->height);\n\n    out->width  = s->w;\n    out->height = s->h;\n\n    if (in != out)\n        av_frame_free(&in);\n    return ff_filter_frame(inlink->dst->outputs[0], out);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *address, int mode)\n{\n\tint size, ct, err;\n\n\tif (m->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tvoid __user *namep;\n\t\t\tnamep = (void __user __force *) m->msg_name;\n\t\t\terr = move_addr_to_kernel(namep, m->msg_namelen,\n\t\t\t\t\t\t  address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (m->msg_name)\n\t\t\tm->msg_name = address;\n\t} else {\n\t\tm->msg_name = NULL;\n\t}\n\n\tsize = m->msg_iovlen * sizeof(struct iovec);\n\tif (copy_from_user(iov, (void __user __force *) m->msg_iov, size))\n\t\treturn -EFAULT;\n\n\tm->msg_iov = iov;\n\terr = 0;\n\n\tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n\t\tsize_t len = iov[ct].iov_len;\n\n\t\tif (len > INT_MAX - err) {\n\t\t\tlen = INT_MAX - err;\n\t\t\tiov[ct].iov_len = len;\n\t\t}\n\t\terr += len;\n\t}\n\n\treturn err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstd::string Url::DecodeUnsafe(string_view encoded) {\n  std::string raw;\n  if (Decode(encoded, &raw)) {\n    return raw;\n  }\n  return ToString(encoded);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid RegKey::getBinary(const TCHAR* valname, void** data, size_t* length, void* def, size_t deflen) const {\n  try {\n    getBinary(valname, data, length);\n  } catch(rdr::Exception&) {\n    if (deflen) {\n      *data = new char[deflen];\n      memcpy(*data, def, deflen);\n    } else\n      *data = 0;\n    *length = deflen;\n  }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmcs_recv_connect_response(STREAM mcs_data)\n{\n\tUNUSED(mcs_data);\n\tuint8 result;\n\tuint32 length;\n\tSTREAM s;\n\tstruct stream packet;\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\t\n\tpacket = *s;\n\n\tber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\n\n\tber_parse_header(s, BER_TAG_RESULT, &length);\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);\n\t\treturn False;\n\t}\n\n\tber_parse_header(s, BER_TAG_INTEGER, &length);\n\tin_uint8s(s, length);\t\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\trdp_protocol_error(\"mcs_recv_connect_response(), consume connect id from stream would overrun\", &packet);\n\t}\n\n\tmcs_parse_domain_params(s);\n\n\tber_parse_header(s, BER_TAG_OCTET_STRING, &length);\n\n\tsec_process_mcs_data(s);\n\t\n\treturn s_check_end(s);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nnext_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\t\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\n\t\t\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ntok_new(void)\n{\n    struct tok_state *tok = (struct tok_state *)PyMem_MALLOC(\n                                            sizeof(struct tok_state));\n    if (tok == NULL)\n        return NULL;\n    tok->buf = tok->cur = tok->end = tok->inp = tok->start = NULL;\n    tok->done = E_OK;\n    tok->fp = NULL;\n    tok->input = NULL;\n    tok->tabsize = TABSIZE;\n    tok->indent = 0;\n    tok->indstack[0] = 0;\n\n    tok->atbol = 1;\n    tok->pendin = 0;\n    tok->prompt = tok->nextprompt = NULL;\n    tok->lineno = 0;\n    tok->level = 0;\n    tok->altindstack[0] = 0;\n    tok->decoding_state = STATE_INIT;\n    tok->decoding_erred = 0;\n    tok->read_coding_spec = 0;\n    tok->enc = NULL;\n    tok->encoding = NULL;\n    tok->cont_line = 0;\n#ifndef PGEN\n    tok->filename = NULL;\n    tok->decoding_readline = NULL;\n    tok->decoding_buffer = NULL;\n#endif\n    tok->type_comments = 0;\n\n    return tok;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int pgx_gethdr(jas_stream_t *in, pgx_hdr_t *hdr)\n{\n\tint c;\n\tjas_uchar buf[2];\n\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\tgoto error;\n\t}\n\tbuf[0] = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\tgoto error;\n\t}\n\tbuf[1] = c;\n\thdr->magic = buf[0] << 8 | buf[1];\n\tif (hdr->magic != PGX_MAGIC) {\n\t\tjas_eprintf(\"invalid PGX signature\\n\");\n\t\tgoto error;\n\t}\n\tif ((c = pgx_getc(in)) == EOF || !isspace(c)) {\n\t\tgoto error;\n\t}\n\tif (pgx_getbyteorder(in, &hdr->bigendian)) {\n\t\tjas_eprintf(\"cannot get byte order\\n\");\n\t\tgoto error;\n\t}\n\tif (pgx_getsgnd(in, &hdr->sgnd)) {\n\t\tjas_eprintf(\"cannot get signedness\\n\");\n\t\tgoto error;\n\t}\n\tif (pgx_getuint32(in, &hdr->prec)) {\n\t\tjas_eprintf(\"cannot get precision\\n\");\n\t\tgoto error;\n\t}\n\tif (pgx_getuint32(in, &hdr->width)) {\n\t\tjas_eprintf(\"cannot get width\\n\");\n\t\tgoto error;\n\t}\n\tif (pgx_getuint32(in, &hdr->height)) {\n\t\tjas_eprintf(\"cannot get height\\n\");\n\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\treturn -1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nrdpdr_process(STREAM s)\n{\n\tuint32 handle;\n\tuint16 vmin;\n\tuint16 component;\n\tuint16 pakid;\n\tstruct stream packet = *s;\n\n\tlogger(Protocol, Debug, \"rdpdr_process()\");\n\t\n\n\tin_uint16(s, component);\n\tin_uint16(s, pakid);\n\n\tif (component == RDPDR_CTYP_CORE)\n\t{\n\t\tswitch (pakid)\n\t\t{\n\t\t\tcase PAKID_CORE_DEVICE_IOREQUEST:\n\t\t\t\trdpdr_process_irp(s);\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_SERVER_ANNOUNCE:\n\t\t\t\t\n\t\t\t\tin_uint8s(s, 2);\t\n\t\t\t\tin_uint16_le(s, vmin);\t\n\n\t\t\t\tin_uint32_le(s, g_client_id);\t\n\n\t\t\t\t\n\t\t\t\tif (!s_check(s))\n\t\t\t\t{\n\t\t\t\t\trdp_protocol_error(\"rdpdr_process(), consume of g_client_id from stream did overrun\", &packet);\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tif (vmin < 0x000c)\n\t\t\t\t\tg_client_id = 0x815ed39d;\t\n\t\t\t\tg_epoch++;\n\n#if WITH_SCARD\n\t\t\t\t\n\t\t\t\tscard_release_all_contexts();\n\n\t\t\t\t\n\n#endif\n\n\t\t\t\trdpdr_send_client_announce_reply();\n\t\t\t\trdpdr_send_client_name_request();\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_CLIENTID_CONFIRM:\n\t\t\t\trdpdr_send_client_device_list_announce();\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_DEVICE_REPLY:\n\t\t\t\tin_uint32(s, handle);\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), server connected to resource %d\", handle);\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_SERVER_CAPABILITY:\n\t\t\t\trdpdr_send_client_capability_response();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), pakid 0x%x of component 0x%x\", pakid,\n\t\t\t\t       component);\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\telse if (component == RDPDR_CTYP_PRN)\n\t{\n\t\tif (pakid == PAKID_PRN_CACHE_DATA)\n\t\t\tprintercache_process(s);\n\t}\n\telse\n\t\tlogger(Protocol, Warning, \"rdpdr_process(), unhandled component 0x%x\", component);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int x509_crt_verify_child(\n                mbedtls_x509_crt *child, mbedtls_x509_crt *parent,\n                mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,\n                const mbedtls_x509_crt_profile *profile,\n                int path_cnt, int self_cnt, uint32_t *flags,\n                int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                void *p_vrfy )\n{\n    int ret;\n    uint32_t parent_flags = 0;\n    unsigned char hash[MBEDTLS_MD_MAX_SIZE];\n    mbedtls_x509_crt *grandparent;\n    const mbedtls_md_info_t *md_info;\n\n    \n    if( ( path_cnt != 0 ) && x509_name_cmp( &child->issuer, &child->subject ) == 0 )\n        self_cnt++;\n\n    \n    if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )\n    {\n        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n    }\n\n    if( mbedtls_x509_time_is_past( &child->valid_to ) )\n        *flags |= MBEDTLS_X509_BADCERT_EXPIRED;\n\n    if( mbedtls_x509_time_is_future( &child->valid_from ) )\n        *flags |= MBEDTLS_X509_BADCERT_FUTURE;\n\n    if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_MD;\n\n    if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    md_info = mbedtls_md_info_from_type( child->sig_md );\n    if( md_info == NULL )\n    {\n        \n        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n    }\n    else\n    {\n        mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash );\n\n        if( x509_profile_check_key( profile, child->sig_pk, &parent->pk ) != 0 )\n            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n        if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,\n                           child->sig_md, hash, mbedtls_md_get_size( md_info ),\n                           child->sig.p, child->sig.len ) != 0 )\n        {\n            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n        }\n    }\n\n#if defined(MBEDTLS_X509_CRL_PARSE_C)\n    \n    *flags |= x509_crt_verifycrl(child, parent, ca_crl, profile );\n#endif\n\n    \n    for( grandparent = trust_ca;\n         grandparent != NULL;\n         grandparent = grandparent->next )\n    {\n        if( x509_crt_check_parent( parent, grandparent,\n                                   0, path_cnt == 0 ) == 0 )\n            break;\n    }\n\n    if( grandparent != NULL )\n    {\n        ret = x509_crt_verify_top( parent, grandparent, ca_crl, profile,\n                                path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            return( ret );\n    }\n    else\n    {\n        \n        for( grandparent = parent->next;\n             grandparent != NULL;\n             grandparent = grandparent->next )\n        {\n            \n            if( grandparent->max_pathlen > 0 &&\n                grandparent->max_pathlen < 2 + path_cnt - self_cnt )\n            {\n                continue;\n            }\n\n            if( x509_crt_check_parent( parent, grandparent,\n                                       0, path_cnt == 0 ) == 0 )\n                break;\n        }\n\n        \n        if( grandparent != NULL )\n        {\n            ret = x509_crt_verify_child( parent, grandparent, trust_ca, ca_crl,\n                                         profile, path_cnt + 1, self_cnt, &parent_flags,\n                                         f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n        {\n            ret = x509_crt_verify_top( parent, trust_ca, ca_crl, profile,\n                                       path_cnt + 1, self_cnt, &parent_flags,\n                                       f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n    }\n\n    \n    if( NULL != f_vrfy )\n        if( ( ret = f_vrfy( p_vrfy, child, path_cnt, flags ) ) != 0 )\n            return( ret );\n\n    *flags |= parent_flags;\n\n    return( 0 );\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Authentication"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint inet6_sk_rebuild_header(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dst_entry *dst;\n\n\tdst = __sk_dst_check(sk, np->dst_cookie);\n\n\tif (!dst) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = sk->sk_protocol;\n\t\tfl6.daddr = sk->sk_v6_daddr;\n\t\tfl6.saddr = np->saddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\t\tfl6.fl6_dport = inet->inet_dport;\n\t\tfl6.fl6_sport = inet->inet_sport;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst)) {\n\t\t\tsk->sk_route_caps = 0;\n\t\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\t\treturn PTR_ERR(dst);\n\t\t}\n\n\t\t__ip6_dst_store(sk, dst, NULL, NULL);\n\t}\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_bitmap_updates(STREAM s)\n{\n\tint i;\n\tuint16 num_updates;\n\t\n\tin_uint16_le(s, num_updates);   \n\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tprocess_bitmap_data(s);\n\t}\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = CLI_HASHLEN_SHA1;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASHLEN_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tsize_t req_size = 0;\n\tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n\n\tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmem->offs = READ_ONCE(rmem->offs);\n\tmem->size = READ_ONCE(rmem->size);\n\n\t\n\tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||\n\t    mem->mobj->size < req_size)\n\t\treturn TEE_ERROR_SECURITY;\n\n\treturn TEE_SUCCESS;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nCAMLprim value caml_bitvect_test(value bv, value n)\n{\n  int pos = Int_val(n);\n  return Val_int(Byte_u(bv, pos >> 3) & (1 << (pos & 7)));\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint imap_subscribe (char *path, int subscribe)\n{\n  IMAP_DATA *idata;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  BUFFER err, token;\n  IMAP_MBOX mx;\n\n  if (!mx_is_imap (path) || imap_parse_path (path, &mx) || !mx.mbox)\n  {\n    mutt_error (_(\"Bad mailbox name\"));\n    return -1;\n  }\n  if (!(idata = imap_conn_find (&(mx.account), 0)))\n    goto fail;\n\n  imap_fix_path (idata, mx.mbox, buf, sizeof (buf));\n  if (!*buf)\n    strfcpy (buf, \"INBOX\", sizeof (buf));\n\n  if (option (OPTIMAPCHECKSUBSCRIBED))\n  {\n    mutt_buffer_init (&token);\n    mutt_buffer_init (&err);\n    err.data = errstr;\n    err.dsize = sizeof (errstr);\n    snprintf (mbox, sizeof (mbox), \"%smailboxes \\\"%s\\\"\",\n              subscribe ? \"\" : \"un\", path);\n    if (mutt_parse_rc_line (mbox, &token, &err))\n      dprint (1, (debugfile, \"Error adding subscribed mailbox: %s\\n\", errstr));\n    FREE (&token.data);\n  }\n\n  if (subscribe)\n    mutt_message (_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message (_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name (idata, mbox, sizeof(mbox), buf);\n\n  snprintf (buf, sizeof (buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n\n  if (imap_exec (idata, buf, 0) < 0)\n    goto fail;\n\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message (_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message (_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE (&mx.mbox);\n  return 0;\n\n fail:\n  FREE (&mx.mbox);\n  return -1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "OS Command Injection"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_plane(uint8 * in, int width, int height, uint8 * out, int size)\n{\n\tUNUSED(size);\n\tint indexw;\n\tint indexh;\n\tint code;\n\tint collen;\n\tint replen;\n\tint color;\n\tint x;\n\tint revcode;\n\tuint8 * last_line;\n\tuint8 * this_line;\n\tuint8 * org_in;\n\tuint8 * org_out;\n\n\torg_in = in;\n\torg_out = out;\n\tlast_line = 0;\n\tindexh = 0;\n\twhile (indexh < height)\n\t{\n\t\tout = (org_out + width * height * 4) - ((indexh + 1) * width * 4);\n\t\tcolor = 0;\n\t\tthis_line = out;\n\t\tindexw = 0;\n\t\tif (last_line == 0)\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tcolor = CVAL(in);\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = CVAL(in);\n\t\t\t\t\tif (x & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tx = x + 1;\n\t\t\t\t\t\tcolor = -x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tcolor = x;\n\t\t\t\t\t}\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tindexh++;\n\t\tlast_line = this_line;\n\t}\n\treturn (int) (in - org_in);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic size_t socket_slurp(RSocket *s, RBuffer *buf) {\n\tsize_t i;\n\tif (r_socket_ready (s, 1, 0) != 1) {\n\t\treturn 0;\n\t}\n\tr_socket_block_time (s, 1, 0, 1000);\n\tfor (i = 0; i < SOCKET_HTTP_MAX_HEADER_LENGTH; i += 1) {\n\t\tut8 c;\n\t\tint olen = r_socket_read_block (s, &c, 1);\n\t\tif (olen != 1) {\n\t\t\tr_buf_append_bytes (buf, (ut8 *)\"\", 1);\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_append_bytes (buf, &c, 1);\n\t}\n\treturn i;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nMG_INTERNAL int parse_mqtt(struct mbuf *io, struct mg_mqtt_message *mm) {\n  uint8_t header;\n  size_t len = 0, len_len = 0;\n  const char *p, *end;\n  unsigned char lc = 0;\n  int cmd;\n\n  if (io->len < 2) return MG_MQTT_ERROR_INCOMPLETE_MSG;\n  header = io->buf[0];\n  cmd = header >> 4;\n\n  \n  len = len_len = 0;\n  p = io->buf + 1;\n  while ((size_t)(p - io->buf) < io->len) {\n    lc = *((const unsigned char *) p++);\n    len += (lc & 0x7f) << 7 * len_len;\n    len_len++;\n    if (!(lc & 0x80)) break;\n    if (len_len > 4) return MG_MQTT_ERROR_MALFORMED_MSG;\n  }\n\n  end = p + len;\n  if (lc & 0x80 || len > (io->len - (p - io->buf))) {\n    return MG_MQTT_ERROR_INCOMPLETE_MSG;\n  }\n\n  mm->cmd = cmd;\n  mm->qos = MG_MQTT_GET_QOS(header);\n\n  switch (cmd) {\n    case MG_MQTT_CMD_CONNECT: {\n      p = scanto(p, &mm->protocol_name);\n      if (p > end - 4) return MG_MQTT_ERROR_MALFORMED_MSG;\n      mm->protocol_version = *(uint8_t *) p++;\n      mm->connect_flags = *(uint8_t *) p++;\n      mm->keep_alive_timer = getu16(p);\n      p += 2;\n      if (p >= end) return MG_MQTT_ERROR_MALFORMED_MSG;\n      p = scanto(p, &mm->client_id);\n      if (p > end) return MG_MQTT_ERROR_MALFORMED_MSG;\n      if (mm->connect_flags & MG_MQTT_HAS_WILL) {\n        if (p >= end) return MG_MQTT_ERROR_MALFORMED_MSG;\n        p = scanto(p, &mm->will_topic);\n      }\n      if (mm->connect_flags & MG_MQTT_HAS_WILL) {\n        if (p >= end) return MG_MQTT_ERROR_MALFORMED_MSG;\n        p = scanto(p, &mm->will_message);\n      }\n      if (mm->connect_flags & MG_MQTT_HAS_USER_NAME) {\n        if (p >= end) return MG_MQTT_ERROR_MALFORMED_MSG;\n        p = scanto(p, &mm->user_name);\n      }\n      if (mm->connect_flags & MG_MQTT_HAS_PASSWORD) {\n        if (p >= end) return MG_MQTT_ERROR_MALFORMED_MSG;\n        p = scanto(p, &mm->password);\n      }\n      if (p != end) return MG_MQTT_ERROR_MALFORMED_MSG;\n\n      LOG(LL_DEBUG,\n          (\"%d %2x %d proto [%.*s] client_id [%.*s] will_topic [%.*s] \"\n           \"will_msg [%.*s] user_name [%.*s] password [%.*s]\",\n           (int) len, (int) mm->connect_flags, (int) mm->keep_alive_timer,\n           (int) mm->protocol_name.len, mm->protocol_name.p,\n           (int) mm->client_id.len, mm->client_id.p, (int) mm->will_topic.len,\n           mm->will_topic.p, (int) mm->will_message.len, mm->will_message.p,\n           (int) mm->user_name.len, mm->user_name.p, (int) mm->password.len,\n           mm->password.p));\n      break;\n    }\n    case MG_MQTT_CMD_CONNACK:\n      if (end - p < 2) return MG_MQTT_ERROR_MALFORMED_MSG;\n      mm->connack_ret_code = p[1];\n      break;\n    case MG_MQTT_CMD_PUBACK:\n    case MG_MQTT_CMD_PUBREC:\n    case MG_MQTT_CMD_PUBREL:\n    case MG_MQTT_CMD_PUBCOMP:\n    case MG_MQTT_CMD_SUBACK:\n      mm->message_id = getu16(p);\n      break;\n    case MG_MQTT_CMD_PUBLISH: {\n      p = scanto(p, &mm->topic);\n      if (p > end) return MG_MQTT_ERROR_MALFORMED_MSG;\n      if (mm->qos > 0) {\n        if (end - p < 2) return MG_MQTT_ERROR_MALFORMED_MSG;\n        mm->message_id = getu16(p);\n        p += 2;\n      }\n      mm->payload.p = p;\n      mm->payload.len = end - p;\n      break;\n    }\n    case MG_MQTT_CMD_SUBSCRIBE:\n      if (end - p < 2) return MG_MQTT_ERROR_MALFORMED_MSG;\n      mm->message_id = getu16(p);\n      p += 2;\n      \n      mm->payload.p = p;\n      mm->payload.len = end - p;\n      break;\n    default:\n      \n      break;\n  }\n\n  mm->len = end - io->buf;\n  return mm->len;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void get_over(struct SYMBOL *s)\n{\n\tstruct VOICE_S *p_voice, *p_voice2, *p_voice3;\n\tint range, voice, voice2, voice3;\nstatic char tx_wrong_dur[] = \"Wrong duration in voice overlay\";\nstatic char txt_no_note[] = \"No note in voice overlay\";\n\n\t\n\tp_voice = curvoice;\n\tif (p_voice->ignore)\n\t\treturn;\n\tif (s->abc_type == ABC_T_BAR\n\t || s->u.v_over.type == V_OVER_E)  {\n\t\tif (!p_voice->last_sym) {\n\t\t\terror(1, s, txt_no_note);\n\t\t\treturn;\n\t\t}\n\t\tp_voice->last_sym->sflags |= S_BEAM_END;\n\t\tover_bar = 0;\n\t\tif (over_time < 0) {\n\t\t\terror(1, s, \"Erroneous end of voice overlap\");\n\t\t\treturn;\n\t\t}\n\t\tcurvoice = &voice_tb[over_voice];\n\t\tif (p_voice->time != over_mxtime) {\n\t\t\terror(1, s, tx_wrong_dur);\n\t\t\tif (p_voice->time > over_mxtime)\n\t\t\t\tcurvoice->time = p_voice->time;\n\t\t\telse\n\t\t\t\tp_voice->time = curvoice->time;\n\t\t}\n\t\tover_mxtime = 0;\n\t\tover_voice = -1;\n\t\tover_time = -1;\n\t\treturn;\n\t}\n\n\t\n\tif (s->u.v_over.type == V_OVER_S) {\n\t\tover_voice = p_voice - voice_tb;\n\t\tover_time = p_voice->time;\n\t\treturn;\n\t}\n\n\t\n\t\n\tif (!p_voice->last_sym) {\n\t\terror(1, s, txt_no_note);\n\t\treturn;\n\t}\n\tp_voice->last_sym->sflags |= S_BEAM_END;\n\tvoice2 = s->u.v_over.voice;\n\tp_voice2 = &voice_tb[voice2];\n\tif (parsys->voice[voice2].range < 0) {\n\t\tint clone;\n\n\t\tif (cfmt.abc2pscompat) {\n\t\t\terror(1, s, \"Cannot have %%%%abc2pscompat\");\n\t\t\tcfmt.abc2pscompat = 0;\n\t\t}\n\t\tclone = p_voice->clone >= 0;\n\t\tp_voice2->id[0] = '&';\n\t\tp_voice2->id[1] = '\\0';\n\t\tp_voice2->second = 1;\n\t\tparsys->voice[voice2].second = 1;\n\t\tp_voice2->scale = p_voice->scale;\n\t\tp_voice2->octave = p_voice->octave;\n\t\tp_voice2->transpose = p_voice->transpose;\n\t\tmemcpy(&p_voice2->key, &p_voice->key,\n\t\t\t\t\tsizeof p_voice2->key);\n\t\tmemcpy(&p_voice2->ckey, &p_voice->ckey,\n\t\t\t\t\tsizeof p_voice2->ckey);\n\t\tmemcpy(&p_voice2->okey, &p_voice->okey,\n\t\t\t\t\tsizeof p_voice2->okey);\n\t\tp_voice2->posit = p_voice->posit;\n\t\tp_voice2->staff = p_voice->staff;\n\t\tp_voice2->cstaff = p_voice->cstaff;\n\t\tp_voice2->color = p_voice->color;\n\t\tp_voice2->map_name = p_voice->map_name;\n\t\trange = parsys->voice[p_voice - voice_tb].range;\n\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\t\tif (parsys->voice[voice].range > range)\n\t\t\t\tparsys->voice[voice].range += clone + 1;\n\t\t}\n\t\tparsys->voice[voice2].range = range + 1;\n\t\tvoice_link(p_voice2);\n\t\tif (clone) {\n\t\t\tfor (voice3 = MAXVOICE; --voice3 >= 0; ) {\n\t\t\t\tif (parsys->voice[voice3].range < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (voice3 > 0) {\n\t\t\t\tp_voice3 = &voice_tb[voice3];\n\t\t\t\tstrcpy(p_voice3->id, p_voice2->id);\n\t\t\t\tp_voice3->second = 1;\n\t\t\t\tparsys->voice[voice3].second = 1;\n\t\t\t\tp_voice3->scale = voice_tb[p_voice->clone].scale;\n\t\t\t\tparsys->voice[voice3].range = range + 2;\n\t\t\t\tvoice_link(p_voice3);\n\t\t\t\tp_voice2->clone = voice3;\n\t\t\t} else {\n\t\t\t\terror(1, s,\n\t\t\t\t      \"Too many voices for overlay cloning\");\n\t\t\t}\n\t\t}\n\t}\n\tvoice = p_voice - voice_tb;//\t\t\t= parsys->voice[voice].staff;//\t\tp_voice3 = &voice_tb[voice3];//\t\t\t\t= parsys->voice[voice3].staff//\t}\n\n\tif (over_time < 0) {\t\t\t\n\t\tint time;\n\n\t\tover_bar = 1;\n\t\tover_mxtime = p_voice->time;\n\t\tover_voice = voice;\n\t\ttime = p_voice2->time;\n\t\tfor (s = p_voice->last_sym; ; s = s->prev) {\n\t\t\tif (s->type == BAR\n\t\t\t || s->time <= time)\t\n\t\t\t\tbreak;\n\t\t}\n\t\tover_time = s->time;\n\t} else {\n\t\tif (over_mxtime == 0)\n\t\t\tover_mxtime = p_voice->time;\n\t\telse if (p_voice->time != over_mxtime)\n\t\t\terror(1, s, tx_wrong_dur);\n\t}\n\tp_voice2->time = over_time;\n\tcurvoice = p_voice2;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void oinf_entry_dump(GF_OperatingPointsInformation *ptr, FILE * trace)\n{\n\tu32 i, count;\n\n\tif (!ptr) {\n\t\tfprintf(trace, \"<OperatingPointsInformation scalability_mask=\\\"Multiview|Spatial scalability|Auxilary|unknown\\\" num_profile_tier_level=\\\"\\\" num_operating_points=\\\"\\\" dependency_layers=\\\"\\\">\\n\");\n\n\t\tfprintf(trace, \" <ProfileTierLevel general_profile_space=\\\"\\\" general_tier_flag=\\\"\\\" general_profile_idc=\\\"\\\" general_profile_compatibility_flags=\\\"\\\" general_constraint_indicator_flags=\\\"\\\" />\\n\");\n\n\t\tfprintf(trace, \"<OperatingPoint output_layer_set_idx=\\\"\\\" max_temporal_id=\\\"\\\" layer_count=\\\"\\\" minPicWidth=\\\"\\\" minPicHeight=\\\"\\\" maxPicWidth=\\\"\\\" maxPicHeight=\\\"\\\" maxChromaFormat=\\\"\\\" maxBitDepth=\\\"\\\" frame_rate_info_flag=\\\"\\\" bit_rate_info_flag=\\\"\\\" avgFrameRate=\\\"\\\" constantFrameRate=\\\"\\\" maxBitRate=\\\"\\\" avgBitRate=\\\"\\\"/>\\n\");\n\n\t\tfprintf(trace, \"<Layer dependent_layerID=\\\"\\\" num_layers_dependent_on=\\\"\\\" dependent_on_layerID=\\\"\\\" dimension_identifier=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</OperatingPointsInformation>\\n\");\n\t\treturn;\n\t}\n\n\n\tfprintf(trace, \"<OperatingPointsInformation\");\n\tfprintf(trace, \" scalability_mask=\\\"%u (\", ptr->scalability_mask);\n\tswitch (ptr->scalability_mask) {\n\tcase 2:\n\t\tfprintf(trace, \"Multiview\");\n\t\tbreak;\n\tcase 4:\n\t\tfprintf(trace, \"Spatial scalability\");\n\t\tbreak;\n\tcase 8:\n\t\tfprintf(trace, \"Auxilary\");\n\t\tbreak;\n\tdefault:\n\t\tfprintf(trace, \"unknown\");\n\t}\n\tfprintf(trace, \")\\\" num_profile_tier_level=\\\"%u\\\"\", gf_list_count(ptr->profile_tier_levels) );\n\tfprintf(trace, \" num_operating_points=\\\"%u\\\" dependency_layers=\\\"%u\\\"\", gf_list_count(ptr->operating_points), gf_list_count(ptr->dependency_layers));\n\tfprintf(trace, \">\\n\");\n\n\n\tcount=gf_list_count(ptr->profile_tier_levels);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, i);\n\t\tfprintf(trace, \" <ProfileTierLevel general_profile_space=\\\"%u\\\" general_tier_flag=\\\"%u\\\" general_profile_idc=\\\"%u\\\" general_profile_compatibility_flags=\\\"%X\\\" general_constraint_indicator_flags=\\\"\"LLX\"\\\" />\\n\", ptl->general_profile_space, ptl->general_tier_flag, ptl->general_profile_idc, ptl->general_profile_compatibility_flags, ptl->general_constraint_indicator_flags);\n\t}\n\n\n\tcount=gf_list_count(ptr->operating_points);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);\n\t\tfprintf(trace, \"<OperatingPoint output_layer_set_idx=\\\"%u\\\"\", op->output_layer_set_idx);\n\t\tfprintf(trace, \" max_temporal_id=\\\"%u\\\" layer_count=\\\"%u\\\"\", op->max_temporal_id, op->layer_count);\n\t\tfprintf(trace, \" minPicWidth=\\\"%u\\\" minPicHeight=\\\"%u\\\"\", op->minPicWidth, op->minPicHeight);\n\t\tfprintf(trace, \" maxPicWidth=\\\"%u\\\" maxPicHeight=\\\"%u\\\"\", op->maxPicWidth, op->maxPicHeight);\n\t\tfprintf(trace, \" maxChromaFormat=\\\"%u\\\" maxBitDepth=\\\"%u\\\"\", op->maxChromaFormat, op->maxBitDepth);\n\t\tfprintf(trace, \" frame_rate_info_flag=\\\"%u\\\" bit_rate_info_flag=\\\"%u\\\"\", op->frame_rate_info_flag, op->bit_rate_info_flag);\n\t\tif (op->frame_rate_info_flag) \n\t\t\tfprintf(trace, \" avgFrameRate=\\\"%u\\\" constantFrameRate=\\\"%u\\\"\", op->avgFrameRate, op->constantFrameRate);\n\t\tif (op->bit_rate_info_flag) \n\t\t\tfprintf(trace, \" maxBitRate=\\\"%u\\\" avgBitRate=\\\"%u\\\"\", op->maxBitRate, op->avgBitRate);\n\t\tfprintf(trace, \"/>\\n\");\n\t}\n\tcount=gf_list_count(ptr->dependency_layers);\n\tfor (i = 0; i < count; i++) {\n\t\tu32 j;\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);\n\t\tfprintf(trace, \"<Layer dependent_layerID=\\\"%u\\\" num_layers_dependent_on=\\\"%u\\\"\", dep->dependent_layerID, dep->num_layers_dependent_on);\n\t\tif (dep->num_layers_dependent_on) {\n\t\t\tfprintf(trace, \" dependent_on_layerID=\\\"\");\n\t\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\t\tfprintf(trace, \"%d \", dep->dependent_on_layerID[j]);\n\t\t\tfprintf(trace, \"\\\"\");\n\t\t}\n\t\tfprintf(trace, \" dimension_identifier=\\\"\");\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tfprintf(trace, \"%d \", dep->dimension_identifier[j]);\n\t\tfprintf(trace, \"\\\"/>\\n\");\n\t}\n\tfprintf(trace, \"</OperatingPointsInformation>\\n\");\n\treturn;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nerror_t enc28j60ReceivePacket(NetInterface *interface)\n{\n   error_t error;\n   uint16_t n;\n   uint16_t status;\n   Enc28j60Context *context;\n\n     context = (Enc28j60Context *) interface->nicContext;\n\n     if(enc28j60ReadReg(interface, ENC28J60_REG_EPKTCNT))\n   {\n           enc28j60WriteReg(interface, ENC28J60_REG_ERDPTL, LSB(context->nextPacket));\n      enc28j60WriteReg(interface, ENC28J60_REG_ERDPTH, MSB(context->nextPacket));\n\n           enc28j60ReadBuffer(interface, (uint8_t *) &context->nextPacket, sizeof(uint16_t));\n           enc28j60ReadBuffer(interface, (uint8_t *) &n, sizeof(uint16_t));\n           enc28j60ReadBuffer(interface, (uint8_t *) &status, sizeof(uint16_t));\n\n           if((status & RSV_RECEIVED_OK) != 0)\n      {\n                 n = MIN(n, ETH_MAX_FRAME_SIZE);\n                 enc28j60ReadBuffer(interface, context->rxBuffer, n);\n                 error = NO_ERROR;\n      }\n      else\n      {\n                 error = ERROR_INVALID_PACKET;\n      }\n\n                if(context->nextPacket == ENC28J60_RX_BUFFER_START)\n      {\n         enc28j60WriteReg(interface, ENC28J60_REG_ERXRDPTL, LSB(ENC28J60_RX_BUFFER_STOP));\n         enc28j60WriteReg(interface, ENC28J60_REG_ERXRDPTH, MSB(ENC28J60_RX_BUFFER_STOP));\n      }\n      else\n      {\n         enc28j60WriteReg(interface, ENC28J60_REG_ERXRDPTL, LSB(context->nextPacket - 1));\n         enc28j60WriteReg(interface, ENC28J60_REG_ERXRDPTH, MSB(context->nextPacket - 1));\n      }\n\n           enc28j60SetBit(interface, ENC28J60_REG_ECON2, ECON2_PKTDEC);\n   }\n   else\n   {\n           error = ERROR_BUFFER_EMPTY;\n   }\n\n     if(!error)\n   {\n      NetRxAncillary ancillary;\n\n           ancillary = NET_DEFAULT_RX_ANCILLARY;\n\n           nicProcessPacket(interface, context->rxBuffer, n, &ancillary);\n   }\n\n     return error;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_plane(uint8 * in, int width, int height, uint8 * out, int size)\n{\n\tUNUSED(size);\n\tint indexw;\n\tint indexh;\n\tint code;\n\tint collen;\n\tint replen;\n\tint color;\n\tint x;\n\tint revcode;\n\tuint8 * last_line;\n\tuint8 * this_line;\n\tuint8 * org_in;\n\tuint8 * org_out;\n\n\torg_in = in;\n\torg_out = out;\n\tlast_line = 0;\n\tindexh = 0;\n\twhile (indexh < height)\n\t{\n\t\tout = (org_out + width * height * 4) - ((indexh + 1) * width * 4);\n\t\tcolor = 0;\n\t\tthis_line = out;\n\t\tindexw = 0;\n\t\tif (last_line == 0)\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tcolor = CVAL(in);\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = CVAL(in);\n\t\t\t\t\tif (x & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tx = x + 1;\n\t\t\t\t\t\tcolor = -x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tcolor = x;\n\t\t\t\t\t}\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tindexh++;\n\t\tlast_line = this_line;\n\t}\n\treturn (int) (in - org_in);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (output->type) {\n    case kTfLiteInt32: {\n           TF_LITE_ENSURE_OK(context, CheckValue(context, input2));\n      PowImpl<int32_t>(input1, input2, output, data->requires_broadcast);\n      break;\n    }\n    case kTfLiteFloat32: {\n      PowImpl<float>(input1, input2, output, data->requires_broadcast);\n      break;\n    }\n    default: {\n      context->ReportError(context, \"Unsupported data type: %d\", output->type);\n      return kTfLiteError;\n    }\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n\n\tif (!addr)\n\t\treturn -ENODEV;\n\n\tio->io_cleanup = port_cleanup;\n\n\t\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, DEVICE_NAME) == NULL) {\n\t\t\t\n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool IsReshapeOpSupported(const TfLiteRegistration* registration,\n                          const TfLiteNode* node, TfLiteContext* context,\n                          int coreml_version) {\n  if (coreml_version >= 3) {\n    return false;\n  }\n  if (node->inputs->size == 1) {\n    const auto* params =\n        reinterpret_cast<TfLiteReshapeParams*>(node->builtin_data);\n    return params->num_dimensions == 3 || params->num_dimensions == 4;\n  }\n\n  const int kShapeTensor = 1;\n  const TfLiteTensor* shape;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kShapeTensor, &shape));\n  if (shape->allocation_type != kTfLiteMmapRo) {\n    TF_LITE_KERNEL_LOG(context, \"Reshape has non-const shape.\");\n    return false;\n  }\n  const bool is_shape_tensor =\n      shape->dims->size == 1 && shape->type == kTfLiteInt32;\n  return is_shape_tensor &&\n         (shape->dims->data[0] == 3 || shape->dims->data[0] == 4);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,\n                errors::InvalidArgument(\"key must not be empty\"));\n\n       Tensor key(*key_tensor);\n\n       for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n\n       OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nget_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)\n{\n\tint\t\t\t\ttmp;\n\tstruct usb_host_interface\t*alt;\n\tstruct usb_host_endpoint\t*in, *out;\n\tstruct usb_host_endpoint\t*iso_in, *iso_out;\n\tstruct usb_host_endpoint\t*int_in, *int_out;\n\tstruct usb_device\t\t*udev;\n\n\tfor (tmp = 0; tmp < intf->num_altsetting; tmp++) {\n\t\tunsigned\tep;\n\n\t\tin = out = NULL;\n\t\tiso_in = iso_out = NULL;\n\t\tint_in = int_out = NULL;\n\t\talt = intf->altsetting + tmp;\n\n\t\tif (override_alt >= 0 &&\n\t\t\t\toverride_alt != alt->desc.bAlternateSetting)\n\t\t\tcontinue;\n\n\t\t\n\t\tfor (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {\n\t\t\tstruct usb_host_endpoint\t*e;\n\t\t\tint edi;\n\n\t\t\te = alt->endpoint + ep;\n\t\t\tedi = usb_endpoint_dir_in(&e->desc);\n\n\t\t\tswitch (usb_endpoint_type(&e->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tendpoint_update(edi, &in, &out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (dev->info->intr)\n\t\t\t\t\tendpoint_update(edi, &int_in, &int_out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t\tif (dev->info->iso)\n\t\t\t\t\tendpoint_update(edi, &iso_in, &iso_out, e);\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((in && out)  ||  iso_in || iso_out || int_in || int_out)\n\t\t\tgoto found;\n\t}\n\treturn -EINVAL;\n\nfound:\n\tudev = testdev_to_usbdev(dev);\n\tdev->info->alt = alt->desc.bAlternateSetting;\n\tif (alt->desc.bAlternateSetting != 0) {\n\t\ttmp = usb_set_interface(udev,\n\t\t\t\talt->desc.bInterfaceNumber,\n\t\t\t\talt->desc.bAlternateSetting);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t}\n\n\tif (in)\n\t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n\t\t\tin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\tif (out)\n\t\tdev->out_pipe = usb_sndbulkpipe(udev,\n\t\t\tout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\n\tif (iso_in) {\n\t\tdev->iso_in = &iso_in->desc;\n\t\tdev->in_iso_pipe = usb_rcvisocpipe(udev,\n\t\t\t\tiso_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (iso_out) {\n\t\tdev->iso_out = &iso_out->desc;\n\t\tdev->out_iso_pipe = usb_sndisocpipe(udev,\n\t\t\t\tiso_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_in) {\n\t\tdev->int_in = &int_in->desc;\n\t\tdev->in_int_pipe = usb_rcvintpipe(udev,\n\t\t\t\tint_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_out) {\n\t\tdev->int_out = &int_out->desc;\n\t\tdev->out_int_pipe = usb_sndintpipe(udev,\n\t\t\t\tint_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline int xsave_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XSAVES\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t     xstate_fault\n\t\t\t: \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XSAVE\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t     xstate_fault\n\t\t\t: \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\treturn err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, Utils::String::toHtmlEscaped(message) };\n    m_messages.push_back(temp);\n\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n\n    emit newLogMessage(temp);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPl_AES_PDF::flush(bool strip_padding)\n{\n    assert(this->offset == this->buf_size);\n\n    if (first)\n    {\n\tfirst = false;\n        bool return_after_init = false;\n\tif (this->cbc_mode)\n\t{\n\t    if (encrypt)\n\t    {\n\t\t\t\tinitializeVector();\n                if (! (this->use_zero_iv || this->use_specified_iv))\n                {\n                    getNext()->write(this->cbc_block, this->buf_size);\n                }\n\t    }\n\t    else if (this->use_zero_iv || this->use_specified_iv)\n            {\n                                              initializeVector();\n            }\n            else\n\t    {\n\t\t\t\tmemcpy(this->cbc_block, this->inbuf, this->buf_size);\n\t\tthis->offset = 0;\n                return_after_init = true;\n\t    }\n\t}\n        this->crypto->rijndael_init(\n            encrypt, this->key.get(), key_bytes,\n            this->cbc_mode, this->cbc_block);\n        if (return_after_init)\n        {\n            return;\n        }\n    }\n\n    if (this->encrypt)\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    else\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    unsigned int bytes = this->buf_size;\n    if (strip_padding)\n    {\n\tunsigned char last = this->outbuf[this->buf_size - 1];\n\tif (last <= this->buf_size)\n\t{\n\t    bool strip = true;\n\t    for (unsigned int i = 1; i <= last; ++i)\n\t    {\n\t\tif (this->outbuf[this->buf_size - i] != last)\n\t\t{\n\t\t    strip = false;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (strip)\n\t    {\n\t\tbytes -= last;\n\t    }\n\t}\n    }\n    this->offset = 0;\n    getNext()->write(this->outbuf, bytes);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ncleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = path;\n\tif (*src == '\\0') {\n\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\tif (error_string)\n\t\t    archive_string_sprintf(error_string,\n\t\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\t\n\tif (*src == '/') {\n\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n\t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\t\tif (error_string)\n\t\t\t    archive_string_sprintf(error_string,\n\t\t\t\t    \"Path is absolute\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\tseparator = *src++;\n\t}\n\n\t\n\tfor (;;) {\n\t\t\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t\n\t\t\t\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\t\t\t\t\tif (error_string)\n\t\t\t\t\t\t    archive_string_sprintf(error_string,\n\t\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t\n\t\tseparator = *src++;\n\t}\n\t\n\tif (dest == path) {\n\t\t\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int8_t sn_coap_parser_add_u16_limit(uint16_t a, uint16_t b, uint16_t *result)\n{\n    uint16_t c;\n\n    c = a + b;\n    if (c < a || c < b)\n    {\n        return -1;\n    }\n\n    *result = c;\n\n    return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, 0);\n\n  switch (input->type) {\n    case kTfLiteFloat32:\n      return EvalImpl<kernel_type, kTfLiteFloat32>(context, node);\n    case kTfLiteUInt8:\n      return EvalImpl<kernel_type, kTfLiteUInt8>(context, node);\n    case kTfLiteInt8:\n      return EvalImpl<kernel_type, kTfLiteInt8>(context, node);\n    case kTfLiteInt16:\n      return EvalImpl<kernel_type, kTfLiteInt16>(context, node);\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Cross Site Scripting"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid addReply(redisClient *c, robj *obj) {\n    if (_installWriteEvent(c) != REDIS_OK) return;\n    redisAssert(!server.ds_enabled || obj->storage == REDIS_VM_MEMORY);\n\n    \n    if (obj->encoding == REDIS_ENCODING_RAW) {\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n    } else {\n        \n        obj = getDecodedObject(obj);\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n        decrRefCount(obj);\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ndecode_NXAST_RAW_ENCAP(const struct nx_action_encap *nae,\n                       enum ofp_version ofp_version OVS_UNUSED,\n                       struct ofpbuf *out)\n{\n    struct ofpact_encap *encap;\n    const struct ofp_ed_prop_header *ofp_prop;\n    const size_t encap_ofs = out->size;\n    size_t props_len;\n    uint16_t n_props = 0;\n    int err;\n\n    encap = ofpact_put_ENCAP(out);\n    encap->ofpact.raw = NXAST_RAW_ENCAP;\n    switch (ntohl(nae->new_pkt_type)) {\n    case PT_ETH:\n    case PT_NSH:\n        \n        break;\n    default:\n        return OFPERR_NXBAC_BAD_HEADER_TYPE;\n    }\n    encap->new_pkt_type = nae->new_pkt_type;\n    encap->hdr_size = ntohs(nae->hdr_size);\n\n    ofp_prop = nae->props;\n    props_len = ntohs(nae->len) - offsetof(struct nx_action_encap, props);\n    n_props = 0;\n    while (props_len > 0) {\n        err = decode_ed_prop(&ofp_prop, out, &props_len);\n        if (err) {\n            return err;\n        }\n        n_props++;\n    }\n    encap = ofpbuf_at_assert(out, encap_ofs, sizeof *encap);\n    encap->n_props = n_props;\n    out->header = &encap->ofpact;\n    ofpact_finish_ENCAP(out, &encap);\n\n    return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\njas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\tbmp_dec_importopts_t opts;\n\tsize_t num_samples;\n\n\timage = 0;\n\tinfo = 0;\n\n\tif (bmp_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n\t\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\tgoto error;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\"cannot get info\\n\");\n\t\tgoto error;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\"BMP information: len %ld; width %ld; height %ld; numplanes %d; \"\n\t  \"depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \"\n\t  \"mincolors %ld\\n\", JAS_CAST(long, info->len),\n\t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),\n\t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),\n\t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),\n\t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),\n\t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));\n\n\tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||\n\t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {\n\t\tjas_eprintf(\"corrupt bit stream\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!jas_safe_size_mul3(info->width, info->height, info->numplanes,\n\t  &num_samples)) {\n\t\tjas_eprintf(\"image size too large\\n\");\n\t\tgoto error;\n\t}\n\n\tif (opts.max_samples > 0 && num_samples > opts.max_samples) {\n\t\tjas_eprintf(\"maximum number of pixels exceeded (%zu)\\n\",\n\t\t  opts.max_samples);\n\t\tgoto error;\n\t}\n\n\t\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\tgoto error;\n\t}\n\n\t\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\tgoto error;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tgoto error;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t\n\tif (bmp_getdata(in, info, image)) {\n\t\tgoto error;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n\nerror:\n\tif (info) {\n\t\tbmp_info_destroy(info);\n\t}\n\tif (image) {\n\t\tjas_image_destroy(image);\n\t}\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  const TfLiteTensor* axis = GetInput(context, node, kAxis);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  output->type = input->type;\n  if (IsConstantTensor(axis)) {\n    int axis_value;\n    TF_LITE_ENSURE_OK(context,\n                      GetAxisValueFromTensor(context, *axis, &axis_value));\n    return ExpandTensorDim(context, *input, axis_value, output);\n  }\n  SetTensorToDynamic(output);\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct ion_client *client = filp->private_data;\n\tstruct ion_device *dev = client->dev;\n\tstruct ion_handle *cleanup_handle = NULL;\n\tint ret = 0;\n\tunsigned int dir;\n\n\tunion {\n\t\tstruct ion_fd_data fd;\n\t\tstruct ion_allocation_data allocation;\n\t\tstruct ion_handle_data handle;\n\t\tstruct ion_custom_data custom;\n\t} data;\n\n\tdir = ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_ALLOC:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_alloc(client, data.allocation.len,\n\t\t\t\t\t\tdata.allocation.align,\n\t\t\t\t\t\tdata.allocation.heap_id_mask,\n\t\t\t\t\t\tdata.allocation.flags);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\n\t\tdata.allocation.handle = handle->id;\n\n\t\tcleanup_handle = handle;\n\t\tbreak;\n\t}\n\tcase ION_IOC_FREE:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t\tion_free(client, handle);\n\t\tion_handle_put(handle);\n\t\tbreak;\n\t}\n\tcase ION_IOC_SHARE:\n\tcase ION_IOC_MAP:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t\tdata.fd.fd = ion_share_dma_buf_fd(client, handle);\n\t\tion_handle_put(handle);\n\t\tif (data.fd.fd < 0)\n\t\t\tret = data.fd.fd;\n\t\tbreak;\n\t}\n\tcase ION_IOC_IMPORT:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_import_dma_buf_fd(client, data.fd.fd);\n\t\tif (IS_ERR(handle))\n\t\t\tret = PTR_ERR(handle);\n\t\telse\n\t\t\tdata.handle.handle = handle->id;\n\t\tbreak;\n\t}\n\tcase ION_IOC_SYNC:\n\t{\n\t\tret = ion_sync_for_device(client, data.fd.fd);\n\t\tbreak;\n\t}\n\tcase ION_IOC_CUSTOM:\n\t{\n\t\tif (!dev->custom_ioctl)\n\t\t\treturn -ENOTTY;\n\t\tret = dev->custom_ioctl(client, data.custom.cmd,\n\t\t\t\t\t\tdata.custom.arg);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (dir & _IOC_READ) {\n\t\tif (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {\n\t\t\tif (cleanup_handle)\n\t\t\t\tion_free(client, cleanup_handle);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n\t\tconst iw_byte *d, size_t d_len)\n{\n\tstruct iw_exif_state e;\n\tiw_uint32 ifd;\n\n\tif(d_len<8) return;\n\n\tiw_zeromem(&e,sizeof(struct iw_exif_state));\n\te.d = d;\n\te.d_len = d_len;\n\n\te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n\n\tifd = iw_get_ui32_e(&d[4],e.endian);\n\n\tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nZlibInStream::ZlibInStream(int bufSize_)\n  : underlying(0), bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0),\n    zs(NULL), bytesIn(0)\n{\n  ptr = end = start = new U8[bufSize];\n  init();\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nGF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto out_pernet;\n\n\terr = xfrm6_tunnel_register(&ip4ip6_handler, AF_INET);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\tgoto out_ip4ip6;\n\t}\n\n\terr = xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\tgoto out_ip6ip6;\n\t}\n\n\treturn 0;\n\nout_ip6ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout_ip4ip6:\n\tunregister_pernet_device(&ip6_tnl_net_ops);\nout_pernet:\n\treturn err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  output->type = input2->type;\n\n  data->requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (data->requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic struct sock *dccp_v6_request_recv_sock(const struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst,\n\t\t\t\t\t      struct request_sock *req_unhash,\n\t\t\t\t\t      bool *own_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t\t  req_unhash, own_req);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t\n\n\t\t\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tstruct flowi6 fl6;\n\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_DCCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t\n\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr\t= ireq->ir_v6_rmt_addr;\n\tnewnp->saddr\t\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if\t= ireq->ir_iif;\n\n\t\n\tnewinet->inet_opt = NULL;\n\n\t\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t\n\tif (np->opt != NULL)\n\t\tnewnp->opt = ipv6_dup_options(newsk, np->opt);\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt != NULL)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\tdccp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\t\n\tif (*own_req && ireq->pktopts) {\n\t\tnewnp->pktoptions = skb_clone(ireq->pktopts, GFP_ATOMIC);\n\t\tconsume_skb(ireq->pktopts);\n\t\tireq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  int batches = input->dims->data[0];\n  int height = input->dims->data[1];\n  int width = input->dims->data[2];\n  int channels_out = input->dims->data[3];\n\n   auto padding = params->padding;\n  int out_width, out_height;\n\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width, 1, 1, height, width,\n      params->filter_height, params->filter_width, padding, &out_height,\n      &out_width);\n\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    if (pool_type == kAverage || pool_type == kMax) {\n      TFLITE_DCHECK_LE(std::abs(input->params.scale - output->params.scale),\n                       1.0e-6);\n      TFLITE_DCHECK_EQ(input->params.zero_point, output->params.zero_point);\n    }\n    if (pool_type == kL2) {\n           TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n    }\n  }\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = batches;\n  output_size->data[1] = out_height;\n  output_size->data[2] = out_width;\n  output_size->data[3] = channels_out;\n  return context->ResizeTensor(context, output, output_size);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool DNP3_Base::ProcessData(int len, const u_char* data, bool orig)\n\t{\n\tEndpoint* endp = orig ? &orig_state : &resp_state;\n\n\twhile ( len )\n\t\t{\n\t\tif ( endp->in_hdr )\n\t\t\t{\n\t\t\t\t\tint res = AddToBuffer(endp, PSEUDO_APP_LAYER_INDEX, &data, &len);\n\n\t\t\tif ( res == 0 )\n\t\t\t\treturn true;\n\n\t\t\tif ( res < 0 )\n\t\t\t\treturn false;\n\n\t\t\t\t\tif( endp->buffer[0] != 0x05 || endp->buffer[1] != 0x64 )\n\t\t\t\t{\n\t\t\t\tanalyzer->Weird(\"dnp3_header_lacks_magic\");\n\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t\tif ( ! CheckCRC(PSEUDO_LINK_LAYER_LEN, endp->buffer, endp->buffer + PSEUDO_LINK_LAYER_LEN, \"header\") )\n\t\t\t\t{\n\t\t\t\tanalyzer->ProtocolViolation(\"broken_checksum\");\n\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t\tanalyzer->ProtocolConfirmation();\n\n\t\t\t\t\t\t\tif ( (endp->buffer[PSEUDO_LENGTH_INDEX] + 3) == (char)PSEUDO_LINK_LAYER_LEN  )\n\t\t\t\t{\n\t\t\t\tClearEndpointState(orig);\n\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t\t\t\tu_char ctrl = endp->buffer[PSEUDO_CONTROL_FIELD_INDEX];\n\n\t\t\tif ( orig != (bool)(ctrl & 0x80) )\n\t\t\t\tanalyzer->Weird(\"dnp3_unexpected_flow_direction\");\n\n\t\t\t\t\tendp->pkt_length = endp->buffer[PSEUDO_LENGTH_INDEX];\n\t\t\tendp->tpflags = endp->buffer[PSEUDO_TRANSPORT_INDEX];\n\t\t\tendp->in_hdr = false;\n\t\t\t\t\t\t\tif ( ++endp->pkt_cnt == 1 )\n\t\t\t\tinterp->NewData(orig, endp->buffer, endp->buffer + PSEUDO_LINK_LAYER_LEN);\n\t\t\t}\n\n\t\tif ( ! endp->in_hdr )\n\t\t\t{\n\t\t\tif ( endp->pkt_length <= 0 )\n\t\t\t\t{\n\t\t\t\tanalyzer->Weird(\"dnp3_negative_or_zero_length_link_layer\");\n\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint n = PSEUDO_APP_LAYER_INDEX + (endp->pkt_length - 5) + ((endp->pkt_length - 5) / 16) * 2\n\t\t\t\t\t+ 2 * ( ((endp->pkt_length - 5) % 16 == 0) ? 0 : 1) - 1 ;\n\n\t\t\tint res = AddToBuffer(endp, n, &data, &len);\n\n\t\t\tif ( res == 0 )\n\t\t\t\treturn true;\n\n\t\t\tif ( res < 0 )\n\t\t\t\treturn false;\n\n\t\t\t\t\tif ( ! ParseAppLayer(endp) )\n\t\t\t\treturn false;\n\n\t\t\t\t\tendp->buffer_len = 0;\n\t\t\tendp->in_hdr = true;\n\t\t\t}\n\t\t}\n\n\treturn true;\n\t}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\npimv1_print(netdissect_options *ndo,\n            register const u_char *bp, register u_int len)\n{\n\tregister u_char type;\n\n\tND_TCHECK(bp[1]);\n\ttype = bp[1];\n\n\tND_PRINT((ndo, \" %s\", tok2str(pimv1_type_str, \"[type %u]\", type)));\n\tswitch (type) {\n\tcase PIMV1_TYPE_QUERY:\n\t\tif (ND_TTEST(bp[8])) {\n\t\t\tswitch (bp[8] >> 4) {\n\t\t\tcase 0:\n\t\t\t\tND_PRINT((ndo, \" Dense-mode\"));\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tND_PRINT((ndo, \" Sparse-mode\"));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tND_PRINT((ndo, \" Sparse-Dense-mode\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" mode-%d\", bp[8] >> 4));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK2(bp[10],2);\n\t\t\tND_PRINT((ndo, \" (Hold-time \"));\n\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[10]));\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t}\n\t\tbreak;\n\n\tcase PIMV1_TYPE_REGISTER:\n\t\tND_TCHECK2(bp[8], 20);\t\t\t\n\t\tND_PRINT((ndo, \" for %s > %s\", ipaddr_string(ndo, &bp[20]),\n\t\t    ipaddr_string(ndo, &bp[24])));\n\t\tbreak;\n\tcase PIMV1_TYPE_REGISTER_STOP:\n\t\tND_TCHECK2(bp[12], sizeof(struct in_addr));\n\t\tND_PRINT((ndo, \" for %s > %s\", ipaddr_string(ndo, &bp[8]),\n\t\t    ipaddr_string(ndo, &bp[12])));\n\t\tbreak;\n\tcase PIMV1_TYPE_RP_REACHABILITY:\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK2(bp[22], 2);\n\t\t\tND_PRINT((ndo, \" group %s\", ipaddr_string(ndo, &bp[8])));\n\t\t\tif (EXTRACT_32BITS(&bp[12]) != 0xffffffff)\n\t\t\t\tND_PRINT((ndo, \"/%s\", ipaddr_string(ndo, &bp[12])));\n\t\t\tND_PRINT((ndo, \" RP %s hold \", ipaddr_string(ndo, &bp[16])));\n\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[22]));\n\t\t}\n\t\tbreak;\n\tcase PIMV1_TYPE_ASSERT:\n\t\tND_TCHECK2(bp[16], sizeof(struct in_addr));\n\t\tND_PRINT((ndo, \" for %s > %s\", ipaddr_string(ndo, &bp[16]),\n\t\t    ipaddr_string(ndo, &bp[8])));\n\t\tif (EXTRACT_32BITS(&bp[12]) != 0xffffffff)\n\t\t\tND_PRINT((ndo, \"/%s\", ipaddr_string(ndo, &bp[12])));\n\t\tND_TCHECK2(bp[24], 4);\n\t\tND_PRINT((ndo, \" %s pref %d metric %d\",\n\t\t    (bp[20] & 0x80) ? \"RP-tree\" : \"SPT\",\n\t\tEXTRACT_32BITS(&bp[20]) & 0x7fffffff,\n\t\tEXTRACT_32BITS(&bp[24])));\n\t\tbreak;\n\tcase PIMV1_TYPE_JOIN_PRUNE:\n\tcase PIMV1_TYPE_GRAFT:\n\tcase PIMV1_TYPE_GRAFT_ACK:\n\t\tif (ndo->ndo_vflag) {\n\t\t\tif (len < 8)\n\t\t\t\tgoto trunc;\n\t\t\tpimv1_join_prune_print(ndo, &bp[8], len - 8);\n\t\t}\n\t\tbreak;\n\t}\n\tND_TCHECK(bp[4]);\n\tif ((bp[4] >> 4) != 1)\n\t\tND_PRINT((ndo, \" [v%d]\", bp[4] >> 4));\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pim]\"));\n\treturn;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool CSecurityTLS::processMsg(CConnection* cc)\n{\n  rdr::InStream* is = cc->getInStream();\n  rdr::OutStream* os = cc->getOutStream();\n  client = cc;\n\n  initGlobal();\n\n  if (!session) {\n    if (!is->checkNoWait(1))\n      return false;\n\n    if (is->readU8() == 0) {\n      rdr::U32 result = is->readU32();\n      CharArray reason;\n      if (result == secResultFailed || result == secResultTooMany)\n        reason.buf = is->readString();\n      else\n        reason.buf = strDup(\"Authentication failure (protocol error)\");\n      throw AuthFailureException(reason.buf);\n    }\n\n    if (gnutls_init(&session, GNUTLS_CLIENT) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n\n    setParam();\n  }\n\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n\n    if (!gnutls_error_is_fatal(err))\n      return false;\n\n    vlog.error(\"TLS Handshake failed: %s\\n\", gnutls_strerror (err));\n    shutdown(false);\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n\n  checkSession();\n\n  cc->setStreams(fis = tlsis, fos = tlsos);\n\n  return true;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  req::ptr<XMLDocumentData> doc() const { return m_node->doc(); }\n```\n\nResponse:\n", "label": true, "cwe_name": "Path Traversal"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nFUNC_DECODER(dissector_postgresql)\n{\n   DECLARE_DISP_PTR(ptr);\n   struct ec_session *s = NULL;\n   void *ident = NULL;\n   char tmp[MAX_ASCII_ADDR_LEN];\n   struct postgresql_status *conn_status;\n\n   \n   (void) DECODE_DATA; \n   (void) DECODE_DATALEN;\n   (void) DECODED_LEN;\n   \n   if (FROM_CLIENT(\"postgresql\", PACKET)) {\n      if (PACKET->DATA.len < 4)\n         return NULL;\n\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      \n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {\n         \n         unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);\n         unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);\n         if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {\n            \n            dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));\n\n            \n            SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));\n\n            conn_status = (struct postgresql_status *) s->data;\n            conn_status->status = WAIT_AUTH;\n\n            \n            strncpy((char*)conn_status->user, (char*)(u + 5), 65);\n            conn_status->user[64] = 0;\n\n            \n            strncpy((char*)conn_status->database, (char*)(d + 9), 65);\n            conn_status->database[64] = 0;\n\n            \n            session_put(s);\n         }\n      } else {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_RESPONSE) {\n\n            \n            if (ptr[0] == 'p' && conn_status->type == MD5) {\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");\n               if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               if (PACKET->DATA.len < 40) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               memcpy(conn_status->hash, ptr + 5 + 3, 32);\n               conn_status->hash[32] = 0;\n               DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n            else if (ptr[0] == 'p' && conn_status->type == CT) {\n               int length;\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");\n               GET_ULONG_BE(length, ptr, 1);\n               strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4);\n               conn_status->password[length - 4] = 0;\n               DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n         }\n      }\n   } else { \n      if (PACKET->DATA.len < 9)\n         return NULL;\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {\n\n            conn_status->status = WAIT_RESPONSE;\n\n            conn_status->type = MD5;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");\n            hex_encode(ptr + 9, 4, conn_status->salt); \n         }\n         else if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {\n            conn_status->status = WAIT_RESPONSE;\n            conn_status->type = CT;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");\n         }\n      }\n   }\n\n   SAFE_FREE(ident);\n   return NULL;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast2obj_slice(void* _o)\n{\n    slice_ty o = (slice_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    switch (o->kind) {\n    case Slice_kind:\n        result = PyType_GenericNew(Slice_type, NULL, NULL);\n        if (!result) goto failed;\n        value = ast2obj_expr(o->v.Slice.lower);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_lower, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        value = ast2obj_expr(o->v.Slice.upper);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_upper, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        value = ast2obj_expr(o->v.Slice.step);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_step, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        break;\n    case ExtSlice_kind:\n        result = PyType_GenericNew(ExtSlice_type, NULL, NULL);\n        if (!result) goto failed;\n        value = ast2obj_list(o->v.ExtSlice.dims, ast2obj_slice);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_dims, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        break;\n    case Index_kind:\n        result = PyType_GenericNew(Index_type, NULL, NULL);\n        if (!result) goto failed;\n        value = ast2obj_expr(o->v.Index.value);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        break;\n    }\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsec_decrypt(uint8 * data, int length)\n{\n\tif (length <= 0)\n\t\treturn;\n\n\tif (g_sec_decrypt_use_count == 4096)\n\t{\n\t\tsec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);\n\t\trdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);\n\t\tg_sec_decrypt_use_count = 0;\n\t}\n\n\trdssl_rc4_crypt(&g_rc4_decrypt_key, data, data, length);\n\tg_sec_decrypt_use_count++;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void fanout_release(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f;\n\n\tmutex_lock(&fanout_mutex);\n\tf = po->fanout;\n\tif (f) {\n\t\tpo->fanout = NULL;\n\n\t\tif (atomic_dec_and_test(&f->sk_ref)) {\n\t\t\tlist_del(&f->list);\n\t\t\tdev_remove_pack(&f->prot_hook);\n\t\t\tfanout_release_data(f);\n\t\t\tkfree(f);\n\t\t}\n\n\t\tif (po->rollover)\n\t\t\tkfree_rcu(po->rollover, rcu);\n\t}\n\tmutex_unlock(&fanout_mutex);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nhorizontalDifference16(unsigned short *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From14)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n\n#undef   CLAMP\n#define  CLAMP(v) From14[(v) >> 2]\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n\t    ip += n - 1;\t\n\t    wp += n - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nuint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return NULL;\n\n\tuint32_t *MP4buffer = NULL;\n\tif (index < mp4->indexcount && mp4->mediafp)\n\t{\n\t\tMP4buffer = (uint32_t *)realloc((void *)lastpayload, mp4->metasizes[index]);\n\n\t\tif (MP4buffer)\n\t\t{\n\t\t\tif (mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index])\n\t\t\t{\n\t\t\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n\t\t\t\tfread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);\n\t\t\t\tmp4->filepos = mp4->metaoffsets[index] + mp4->metasizes[index];\n\t\t\t\treturn MP4buffer;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nget_line_and_copy(linenr_T lnum, char_u *buf)\n{\n    char_u *line = ml_get(lnum);\n\n    vim_strncpy(buf, line, LSIZE - 1);\n    return buf;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic ssize_t ucma_process_join(struct ucma_file *file,\n\t\t\t\t struct rdma_ucm_join_mcast *cmd,  int out_len)\n{\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct ucma_multicast *mc;\n\tstruct sockaddr *addr;\n\tint ret;\n\tu8 join_state;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\taddr = (struct sockaddr *) &cmd->addr;\n\tif (cmd->addr_size != rdma_addr_size(addr))\n\t\treturn -EINVAL;\n\n\tif (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)\n\t\tjoin_state = BIT(FULLMEMBER_JOIN);\n\telse if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)\n\t\tjoin_state = BIT(SENDONLY_FULLMEMBER_JOIN);\n\telse\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx_dev(file, cmd->id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&file->mut);\n\tmc = ucma_alloc_multicast(ctx);\n\tif (!mc) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tmc->join_state = join_state;\n\tmc->uid = cmd->uid;\n\tmemcpy(&mc->addr, addr, cmd->addr_size);\n\tret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,\n\t\t\t\t  join_state, mc);\n\tif (ret)\n\t\tgoto err2;\n\n\tresp.id = mc->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd->response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n\t\tgoto err3;\n\t}\n\n\tmutex_lock(&mut);\n\tidr_replace(&multicast_idr, mc, mc->id);\n\tmutex_unlock(&mut);\n\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn 0;\n\nerr3:\n\trdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tucma_cleanup_mc_events(mc);\nerr2:\n\tmutex_lock(&mut);\n\tidr_remove(&multicast_idr, mc->id);\n\tmutex_unlock(&mut);\n\tlist_del(&mc->list);\n\tkfree(mc);\nerr1:\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\n\tif (!server)\n\t\treturn -1;\n\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\n\tserver->capture = shadow_capture_new(server);\n\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\n\t\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tfree(list);\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteTensor* hits;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 1, &hits));\n  const TfLiteTensor* lookup;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &lookup));\n  const TfLiteTensor* key;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &key));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &value));\n\n  const int num_rows = SizeOfDimension(value, 0);\n  const int row_bytes = value->bytes / num_rows;\n  void* pointer = nullptr;\n  DynamicBuffer buf;\n\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = -1;\n    pointer = bsearch(&(lookup->data.i32[i]), key->data.i32, num_rows,\n                      sizeof(int32_t), greater);\n    if (pointer != nullptr) {\n      idx = (reinterpret_cast<char*>(pointer) - (key->data.raw)) /\n            sizeof(int32_t);\n    }\n\n    if (idx >= num_rows || idx < 0) {\n      if (output->type == kTfLiteString) {\n        buf.AddString(nullptr, 0);\n      } else {\n        memset(output->data.raw + i * row_bytes, 0, row_bytes);\n      }\n      hits->data.uint8[i] = 0;\n    } else {\n      if (output->type == kTfLiteString) {\n        buf.AddString(GetString(value, idx));\n      } else {\n        memcpy(output->data.raw + i * row_bytes,\n               value->data.raw + idx * row_bytes, row_bytes);\n      }\n      hits->data.uint8[i] = 1;\n    }\n  }\n  if (output->type == kTfLiteString) {\n    buf.WriteToTensorAsVector(output);\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nfrag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)\n{\n\tregister const struct ip6_frag *dp;\n\tregister const struct ip6_hdr *ip6;\n\n\tdp = (const struct ip6_frag *)bp;\n\tip6 = (const struct ip6_hdr *)bp2;\n\n\tND_TCHECK(*dp);\n\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT((ndo, \"frag (0x%08x:%d|%ld)\",\n\t\t       EXTRACT_32BITS(&dp->ip6f_ident),\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t} else {\n\t\tND_PRINT((ndo, \"frag (%d|%ld)\",\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t}\n\n\t\n\tif ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tND_PRINT((ndo, \" \"));\n\t\treturn sizeof(struct ip6_frag);\n\t}\ntrunc:\n\tND_PRINT((ndo, \"[|frag]\"));\n\treturn -1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nfree_buf_options(\n    buf_T\t*buf,\n    int\t\tfree_p_ff)\n{\n    if (free_p_ff)\n    {\n\tclear_string_option(&buf->b_p_fenc);\n\tclear_string_option(&buf->b_p_ff);\n\tclear_string_option(&buf->b_p_bh);\n\tclear_string_option(&buf->b_p_bt);\n    }\n#ifdef FEAT_FIND_ID\n    clear_string_option(&buf->b_p_def);\n    clear_string_option(&buf->b_p_inc);\n# ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_inde);\n    clear_string_option(&buf->b_p_indk);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n    clear_string_option(&buf->b_p_cm);\n#endif\n    clear_string_option(&buf->b_p_fp);\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n# ifdef FEAT_SODIUM\n    if ((buf->b_p_key != NULL) && (*buf->b_p_key != NUL) &&\n\t\t\t\t(crypt_get_method_nr(buf) == CRYPT_M_SOD))\n\tcrypt_sodium_munlock(buf->b_p_key, STRLEN(buf->b_p_key));\n# endif\n    clear_string_option(&buf->b_p_key);\n#endif\n    clear_string_option(&buf->b_p_kp);\n    clear_string_option(&buf->b_p_mps);\n    clear_string_option(&buf->b_p_fo);\n    clear_string_option(&buf->b_p_flp);\n    clear_string_option(&buf->b_p_isk);\n#ifdef FEAT_VARTABS\n    clear_string_option(&buf->b_p_vsts);\n    vim_free(buf->b_p_vsts_nopaste);\n    buf->b_p_vsts_nopaste = NULL;\n    VIM_CLEAR(buf->b_p_vsts_array);\n    clear_string_option(&buf->b_p_vts);\n    VIM_CLEAR(buf->b_p_vts_array);\n#endif\n#ifdef FEAT_KEYMAP\n    clear_string_option(&buf->b_p_keymap);\n    keymap_clear(&buf->b_kmap_ga);\n    ga_clear(&buf->b_kmap_ga);\n#endif\n    clear_string_option(&buf->b_p_com);\n#ifdef FEAT_FOLDING\n    clear_string_option(&buf->b_p_cms);\n#endif\n    clear_string_option(&buf->b_p_nf);\n#ifdef FEAT_SYN_HL\n    clear_string_option(&buf->b_p_syn);\n    clear_string_option(&buf->b_s.b_syn_isk);\n#endif\n#ifdef FEAT_SPELL\n    clear_string_option(&buf->b_s.b_p_spc);\n    clear_string_option(&buf->b_s.b_p_spf);\n    vim_regfree(buf->b_s.b_cap_prog);\n    buf->b_s.b_cap_prog = NULL;\n    clear_string_option(&buf->b_s.b_p_spl);\n    clear_string_option(&buf->b_s.b_p_spo);\n#endif\n#ifdef FEAT_SEARCHPATH\n    clear_string_option(&buf->b_p_sua);\n#endif\n    clear_string_option(&buf->b_p_ft);\n#ifdef FEAT_CINDENT\n    clear_string_option(&buf->b_p_cink);\n    clear_string_option(&buf->b_p_cino);\n#endif\n#if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)\n    clear_string_option(&buf->b_p_cinw);\n#endif\n    clear_string_option(&buf->b_p_cpt);\n#ifdef FEAT_COMPL_FUNC\n    clear_string_option(&buf->b_p_cfu);\n    free_callback(&buf->b_cfu_cb);\n    clear_string_option(&buf->b_p_ofu);\n    free_callback(&buf->b_ofu_cb);\n    clear_string_option(&buf->b_p_tsrfu);\n    free_callback(&buf->b_tsrfu_cb);\n#endif\n#ifdef FEAT_QUICKFIX\n    clear_string_option(&buf->b_p_gp);\n    clear_string_option(&buf->b_p_mp);\n    clear_string_option(&buf->b_p_efm);\n#endif\n    clear_string_option(&buf->b_p_ep);\n    clear_string_option(&buf->b_p_path);\n    clear_string_option(&buf->b_p_tags);\n    clear_string_option(&buf->b_p_tc);\n#ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_tfu);\n    free_callback(&buf->b_tfu_cb);\n#endif\n    clear_string_option(&buf->b_p_dict);\n    clear_string_option(&buf->b_p_tsr);\n#ifdef FEAT_TEXTOBJ\n    clear_string_option(&buf->b_p_qe);\n#endif\n    buf->b_p_ar = -1;\n    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n#ifdef FEAT_LISP\n    clear_string_option(&buf->b_p_lw);\n#endif\n    clear_string_option(&buf->b_p_bkc);\n    clear_string_option(&buf->b_p_menc);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nSQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n\n    if ( !in )\n    {\n        return NULL;\n    }\n    \n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));\n\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    chr[ len ++ ] = 0;\n\n    return chr;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;\n\tstruct net *net = sock_net(sk);\n\t__be32 v4addr = 0;\n\tint addr_type;\n\tint err;\n\n\tif (addr->l2tp_family != AF_INET6)\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->l2tp_addr);\n\n\t\n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\t\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip6_lock);\n\tif (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,\n\t\t\t\t   sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip6_lock);\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out_unlock;\n\n\tif (sk->sk_state != TCP_CLOSE)\n\t\tgoto out_unlock;\n\n\t\n\trcu_read_lock();\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t    addr->l2tp_scope_id) {\n\t\t\t\t\n\t\t\t\tsk->sk_bound_dev_if = addr->l2tp_scope_id;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (!sk->sk_bound_dev_if)\n\t\t\t\tgoto out_unlock_rcu;\n\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock_rcu;\n\t\t}\n\n\t\t\n\t\tv4addr = LOOPBACK4_IPV6;\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))\n\t\t\tgoto out_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n\tsk->sk_v6_rcv_saddr = addr->l2tp_addr;\n\tnp->saddr = addr->l2tp_addr;\n\n\tl2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\treturn 0;\n\nout_unlock_rcu:\n\trcu_read_unlock();\nout_unlock:\n\trelease_sock(sk);\n\treturn err;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip6_lock);\n\treturn err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus L2Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  switch (input->type) {     case kTfLiteFloat32:\n      L2EvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:\n          default:\n      context->ReportError(context, \"Type %d not currently supported.\",\n                           input->type);\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n\n    switch (op_context.output->type) {\n      case kTfLiteFloat32:\n        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n        break;\n      case kTfLiteUInt8:\n        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt8:\n        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n        break;\n      case kTfLiteInt32:\n        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt64:\n        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt16:\n        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      default:\n        context->ReportError(context,\n                             \"Type %d is currently not supported by Maximum.\",\n                             op_context.output->type);\n        return kTfLiteError;\n    }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  explicit UnravelIndexOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void add_password(AUTH_HDR *request, unsigned char type, CONST char *password, char *secret)\n{\n\tMD5_CTX md5_secret, my_md5;\n\tunsigned char misc[AUTH_VECTOR_LEN];\n\tint i;\n\tint length = strlen(password);\n\tunsigned char hashed[256 + AUTH_PASS_LEN];\t\n\tunsigned char *vector;\n\tattribute_t *attr;\n\n\tif (length > MAXPASS) {\t\t\t\t\n\t\tlength = MAXPASS;\n\t}\n\n\tif (length == 0) {\n\t\tlength = AUTH_PASS_LEN;\t\t\t\n\t} if ((length & (AUTH_PASS_LEN - 1)) != 0) {\n\t\tlength += (AUTH_PASS_LEN - 1);\t\t\n\t\tlength &= ~(AUTH_PASS_LEN - 1);\t\t\n\t}\t\t\t\t\t\t\n\n\tmemset(hashed, 0, length);\n\tmemcpy(hashed, password, strlen(password));\n\n\tattr = find_attribute(request, PW_PASSWORD);\n\n\tif (type == PW_PASSWORD) {\n\t\tvector = request->vector;\n\t} else {\n\t\tvector = attr->data;\t\t\t\n\t}\n\n\t\n\t\n\t\n\tMD5Init(&md5_secret);\n\tMD5Update(&md5_secret, (unsigned char *) secret, strlen(secret));\n\tmy_md5 = md5_secret;\t\t\t\t\n\tMD5Update(&my_md5, vector, AUTH_VECTOR_LEN);\n\tMD5Final(misc, &my_md5);\t\t\t\n\txor(hashed, misc, AUTH_PASS_LEN);\n\n\t\n\tfor (i = 1; i < (length >> 4); i++) {\n\t\tmy_md5 = md5_secret;\t\t\t\n\t\tMD5Update(&my_md5, &hashed[(i-1) * AUTH_PASS_LEN], AUTH_PASS_LEN);\n\t\tMD5Final(misc, &my_md5);\t\t\t\n\t\txor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);\n\t}\n\n\tif (type == PW_OLD_PASSWORD) {\n\t\tattr = find_attribute(request, PW_OLD_PASSWORD);\n\t}\n\n\tif (!attr) {\n\t\tadd_attribute(request, type, hashed, length);\n\t} else {\n\t\tmemcpy(attr->data, hashed, length); \n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nf_pyeval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (p_pyx == 0)\n\tp_pyx = 2;\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_pyeval(str, rettv);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)\n{\n\tint result = parse_rock_ridge_inode_internal(de, inode, 0);\n\n\t\n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode, 14);\n\t}\n\treturn result;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int pfkey_recvmsg(struct kiocb *kiocb,\n\t\t\t struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\n\tmsg->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\terr = (flags & MSG_TRUNC) ? skb->len : copied;\n\n\tif (pfk->dump.dump != NULL &&\n\t    3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\tpfkey_do_dump(pfk);\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\tif(needs_sorting)\n\t\tsort_directory(dir);\n\n\t\n\tif(check_directory(dir) == FALSE) {\n\t\tif(needs_sorting)\n\t\t\tERROR(\"File system corrupted: directory has duplicate names\\n\");\n\t\telse\n\t\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic RList *r_bin_wasm_get_element_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmElementEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && r < count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmElementEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->num_elem, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tut32 j = 0;\n\t\twhile (i < len && j < ptr->num_elem\t) {\n\t\t\t\t\tut32 e;\n\t\t\tif (!(consume_u32 (buf + i, buf + len, &e, &i))) {\n\t\t\t\tfree (ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* input,\n                                 const TfLiteTensor* size_splits,\n                                 const TfLiteTensor* axis) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n\n  std::vector<int64_t> size_splits_vector;\n  if (size_splits->type == kTfLiteInt32) {\n    GetSizeSplitsVector<int32_t>(size_splits, &size_splits_vector);\n  } else if (size_splits->type == kTfLiteInt64) {\n    GetSizeSplitsVector<int64_t>(size_splits, &size_splits_vector);\n  } else {\n    context->ReportError(context, \"size_splits only support type int32|int64.\");\n    return kTfLiteError;\n  }\n\n  int minus_one_index = -1;\n  int64_t size_splits_sum = 0;\n\n  for (int i = 0; i < size_splits_vector.size(); ++i) {\n    if (size_splits_vector.at(i) == -1) {\n      if (minus_one_index == -1) {\n        minus_one_index = i;\n      } else {\n        context->ReportError(context,\n                             \"The size_splits contains more than one -1.\");\n      }\n    } else {\n      size_splits_sum += size_splits_vector.at(i);\n    }\n  }\n\n  const int input_size = SizeOfDimension(input, axis_value);\n\n  if (minus_one_index != -1) {\n    if (size_splits_sum > input_size) {\n      context->ReportError(\n          context,\n          \"The sum of size_splits must be less than the dimension of value.\");\n    } else {\n      size_splits_vector[minus_one_index] = input_size - size_splits_sum;\n    }\n  } else if (size_splits_sum != input_size) {\n    context->ReportError(\n        context,\n        \"The size_splits must sum to the dimension of value along axis.\");\n  }\n\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = size_splits_vector.at(i);\n    TfLiteTensor* output = GetOutput(context, node, i);\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPlainPasswd::PlainPasswd(int len) : CharArray(len) {\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic std::string PatchPattern(const std::string& pattern) {\n  const std::string fixed_prefix =\n      pattern.substr(0, pattern.find_first_of(kGlobbingChars));\n\n   if (io::Dirname(fixed_prefix).empty()) {\n    return io::JoinPath(\".\", pattern);\n  }\n\n   return pattern;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsasl_handle_login(struct sasl_session *const restrict p, struct user *const u, struct myuser *mu)\n{\n\tbool was_killed = false;\n\n\tif (! mu)\n\t{\n\t\tif (! *p->authzeid)\n\t\t{\n\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an authzeid (BUG)\",\n\t\t\t                     MOWGLI_FUNC_NAME, u->nick);\n\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (! (mu = myuser_find_uid(p->authzeid)))\n\t\t{\n\t\t\tif (*p->authzid)\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account %s dropped; login cancelled\",\n\t\t\t\t                                      p->authzid);\n\t\t\telse\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account dropped; login cancelled\");\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (u->myuser && u->myuser != mu)\n\t{\n\t\tif (is_soper(u->myuser))\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_ADMIN, \"DESOPER: \\2%s\\2 as \\2%s\\2\",\n\t\t\t                                                 u->nick, entity(u->myuser)->name);\n\n\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGOUT\");\n\n\t\tif (! (was_killed = ircd_on_logout(u, entity(u->myuser)->name)))\n\t\t{\n\t\t\tmowgli_node_t *n;\n\n\t\t\tMOWGLI_ITER_FOREACH(n, u->myuser->logins.head)\n\t\t\t{\n\t\t\t\tif (n->data == u)\n\t\t\t\t{\n\t\t\t\t\t(void) mowgli_node_delete(n, &u->myuser->logins);\n\t\t\t\t\t(void) mowgli_node_free(n);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tu->myuser = NULL;\n\t\t}\n\t}\n\n\tif (! was_killed)\n\t{\n\t\tif (u->myuser != mu)\n\t\t{\n\t\t\t\t\t(void) myuser_login(saslsvs, u, mu, false);\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGIN (%s)\", p->mechptr->name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\t\tmu->lastlogin = CURRTIME;\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"REAUTHENTICATE (%s)\", p->mechptr->name);\n\t\t}\n\t}\n\n\treturn true;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Authentication"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n    inline size_t check(size_t itemSize, size_t nItems=1)\n    {\n      if (ptr + itemSize * nItems > end) {\n        if (ptr + itemSize > end)\n          return overrun(itemSize, nItems);\n\n        nItems = (end - ptr) / itemSize;\n      }\n      return nItems;\n    }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nisis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n\n    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nAP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n       unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n\n       m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        if (cursor+2 <= payload_size) {\n            AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n            cursor += 2;\n            if (cursor + param_length < payload_size) {\n                m_SequenceParameters.Append(AP4_DataBuffer());\n                m_SequenceParameters[i].SetData(&payload[cursor], param_length);\n                cursor += param_length;\n            }\n        }\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        if (cursor+2 <= payload_size) {\n            AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n            cursor += 2;\n            if (cursor + param_length < payload_size) {\n                m_PictureParameters.Append(AP4_DataBuffer());\n                m_PictureParameters[i].SetData(&payload[cursor], param_length);\n                cursor += param_length;\n            }\n        }\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  Status FillCollectiveParams(CollectiveParams* col_params,\n                              CollectiveType collective_type,\n                              const Tensor& group_size, const Tensor& group_key,\n                              const Tensor& instance_key) {\n    if (group_size.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_size, got \",\n                              group_size.shape().DebugString());\n    }\n    if (group_key.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_key, got \",\n                              group_key.shape().DebugString());\n    }\n    if (instance_key.dims() > 0) {\n      return errors::Internal(\n          \"Unexpected dimensions on input instance_key, got \",\n          instance_key.shape().DebugString());\n    }\n    col_params->name = name_;\n    col_params->group.device_type = device_type_;\n    col_params->group.group_size = group_size.unaligned_flat<int32>()(0);\n    if (col_params->group.group_size <= 0) {\n      return errors::InvalidArgument(\n          \"group_size must be positive integer but got \",\n          col_params->group.group_size);\n    }\n    col_params->group.group_key = group_key.unaligned_flat<int32>()(0);\n    col_params->instance.type = collective_type;\n    col_params->instance.instance_key = instance_key.unaligned_flat<int32>()(0);\n    col_params->instance.data_type = data_type_;\n    col_params->instance.impl_details.communication_hint = communication_hint_;\n    col_params->instance.impl_details.timeout_seconds = timeout_seconds_;\n    return Status::OK();\n  }\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ninline void StringData::setSize(int64_t len) {\n  assertx(!isImmutable() && !hasMultipleRefs());\n  assertx(len >= 0 && len <= capacity());\n  mutableData()[len] = 0;\n  m_lenAndHash = len;\n  assertx(m_hash == 0);\n  assertx(checkSane());\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nuint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator)\n{\n    mp4object *mp4 = (mp4object *)handle;\n    if (mp4 == NULL) return GPMF_ERROR_MEMORY;\n    \n    if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in_numerator == NULL || out_numerator == NULL) return GPMF_ERROR_MEMORY;\n\n\t*in_numerator = (uint32_t)(index * mp4->basemetadataduration);\n\t*out_numerator = (uint32_t)((index + 1) * mp4->basemetadataduration);\n\t*denominator = (uint32_t)mp4->meta_clockdemon;\n    \n    return GPMF_OK;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  char * unescape(char * dest, const char * src)\n  {\n    while (*src) {\n      if (*src == '\\\\' && src[1]) {\n\t++src;\n\tswitch (*src) {\n\tcase 'n': *dest = '\\n'; break;\n\tcase 'r': *dest = '\\r'; break;\n\tcase 't': *dest = '\\t'; break;\n\tcase 'f': *dest = '\\f'; break;\n\tcase 'v': *dest = '\\v'; break;\n\tdefault: *dest = *src;\n\t}\n      } else {\n\t*dest = *src;\n      }\n      ++src;\n      ++dest;\n    }\n    *dest = '\\0';\n    return dest;\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid lpc546xxEthWritePhyReg(uint8_t opcode, uint8_t phyAddr,\n   uint8_t regAddr, uint16_t data)\n{\n   uint32_t temp;\n\n     if(opcode == SMI_OPCODE_WRITE)\n   {\n           temp = ENET->MAC_MDIO_ADDR & ENET_MAC_MDIO_ADDR_CR_MASK;\n           temp |= ENET_MAC_MDIO_ADDR_MOC(1) | ENET_MAC_MDIO_ADDR_MB_MASK;\n           temp |= ENET_MAC_MDIO_ADDR_PA(phyAddr);\n           temp |= ENET_MAC_MDIO_ADDR_RDA(regAddr);\n\n           ENET->MAC_MDIO_DATA = data & ENET_MAC_MDIO_DATA_MD_MASK;\n\n           ENET->MAC_MDIO_ADDR = temp;\n           while((ENET->MAC_MDIO_ADDR & ENET_MAC_MDIO_ADDR_MB_MASK) != 0)\n      {\n      }\n   }\n   else\n   {\n        }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid imap_quote_string_and_backquotes (char *dest, size_t dlen, const char *src)\n{\n  _imap_quote_string (dest, dlen, src, \"\\\"\\\\`\");\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic UINT serial_process_irp_create(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tDWORD DesiredAccess;\n\tDWORD SharedAccess;\n\tDWORD CreateDisposition;\n\tUINT32 PathLength;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);     \n\tStream_Seek_UINT64(irp->input);                    \n\tStream_Seek_UINT32(irp->input);                    \n\tStream_Read_UINT32(irp->input, SharedAccess);      \n\tStream_Read_UINT32(irp->input, CreateDisposition); \n\tStream_Seek_UINT32(irp->input);                    \n\tStream_Read_UINT32(irp->input, PathLength);        \n\n\tif (Stream_GetRemainingLength(irp->input) < PathLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Seek(irp->input, PathLength); \n\tassert(PathLength == 0);             \n#ifndef _WIN32\n\t\n\tWLog_Print(serial->log, WLOG_DEBUG,\n\t           \"DesiredAccess: 0x%\" PRIX32 \", SharedAccess: 0x%\" PRIX32\n\t           \", CreateDisposition: 0x%\" PRIX32 \"\",\n\t           DesiredAccess, SharedAccess, CreateDisposition);\n\t\n\tDesiredAccess = GENERIC_READ | GENERIC_WRITE;\n\tSharedAccess = 0;\n\tCreateDisposition = OPEN_EXISTING;\n#endif\n\tserial->hComm =\n\t    CreateFile(serial->device.name, DesiredAccess, SharedAccess, NULL, \n\t               CreateDisposition, 0,                                   \n\t               NULL);                                                  \n\n\tif (!serial->hComm || (serial->hComm == INVALID_HANDLE_VALUE))\n\t{\n\t\tWLog_Print(serial->log, WLOG_WARN, \"CreateFile failure: %s last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, GetLastError());\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tgoto error_handle;\n\t}\n\n\t_comm_setServerSerialDriver(serial->hComm, serial->ServerSerialDriverId);\n\t_comm_set_permissive(serial->hComm, serial->permissive);\n\t\n\t\n\t\n\t\n\t\n\t\n\tassert(irp->FileId == 0);\n\tirp->FileId = irp->devman->id_sequence++; \n\tirp->IoStatus = STATUS_SUCCESS;\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%s (DeviceId: %\" PRIu32 \", FileId: %\" PRIu32 \") created.\",\n\t           serial->device.name, irp->device->id, irp->FileId);\nerror_handle:\n\tStream_Write_UINT32(irp->output, irp->FileId); \n\tStream_Write_UINT8(irp->output, 0);            \n\treturn CHANNEL_RC_OK;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nasmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\t\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret) {\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n\t\tif (ret || request != PTRACE_DETACH)\n\t\t\tptrace_unfreeze_traced(child);\n\t}\n\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int http_read_header(URLContext *h, int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    char line[MAX_URL_SIZE];\n    int err = 0;\n\n    s->chunksize = UINT64_MAX;\n\n    for (;;) {\n        if ((err = http_get_line(s, line, sizeof(line))) < 0)\n            return err;\n\n        av_log(h, AV_LOG_TRACE, \"header='%s'\\n\", line);\n\n        err = process_line(h, line, s->line_count, new_location);\n        if (err < 0)\n            return err;\n        if (err == 0)\n            break;\n        s->line_count++;\n    }\n\n    if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000)\n        h->is_streamed = 1; \n\n       cookie_string(s->cookie_dict, &s->cookies);\n    av_dict_free(&s->cookie_dict);\n\n    return err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI;\n\tint ret;\n\n\tif (!is_irq_none(vdev))\n\t\treturn -EINVAL;\n\n\tvdev->ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);\n\tif (!vdev->ctx)\n\t\treturn -ENOMEM;\n\n\t\n\tret = pci_alloc_irq_vectors(pdev, 1, nvec, flag);\n\tif (ret < nvec) {\n\t\tif (ret > 0)\n\t\t\tpci_free_irq_vectors(pdev);\n\t\tkfree(vdev->ctx);\n\t\treturn ret;\n\t}\n\n\tvdev->num_ctx = nvec;\n\tvdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :\n\t\t\t\tVFIO_PCI_MSI_IRQ_INDEX;\n\n\tif (!msix) {\n\t\t\n\t\tvdev->msi_qmax = fls(nvec * 2 - 1) - 1;\n\t}\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n\tstruct sk_buff *skb;\n\tint copied, error = -EINVAL;\n\n\tmsg->msg_namelen = 0;\n\n\tif (sock->state != SS_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\t\n\tif (flags & ~(MSG_DONTWAIT | MSG_PEEK))\n\t\treturn -EOPNOTSUPP;\n\n\tvcc = ATM_SD(sock);\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags) ||\n\t    !test_bit(ATM_VF_READY, &vcc->flags))\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &error);\n\tif (!skb)\n\t\treturn error;\n\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\terror = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (error)\n\t\treturn error;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\tpr_debug(\"%d -= %d\\n\", atomic_read(&sk->sk_rmem_alloc),\n\t\t\t skb->truesize);\n\t\tatm_return(vcc, skb->truesize);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n\n    wpc->version_five = 1;     \n    wpc->file_format = wpc->config.qmode = wpc->channel_layout = 0;\n\n    if (wpc->channel_reordering) {\n        free (wpc->channel_reordering);\n        wpc->channel_reordering = NULL;\n    }\n\n   \n    if (bytecnt >= 2) {\n        wpc->file_format = *byteptr++;\n        wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n        bytecnt -= 2;\n\n       \n        if (bytecnt) {\n            int nchans, i;\n\n            wpc->channel_layout = (int32_t) *byteptr++ << 16;\n            bytecnt--;\n\n           \n            if (bytecnt) {\n                wpc->channel_layout += nchans = *byteptr++;\n                bytecnt--;\n\n               \n                if (bytecnt) {\n                    if (bytecnt > nchans)\n                        return FALSE;\n\n                    wpc->channel_reordering = malloc (nchans);\n\n                   \n                    if (wpc->channel_reordering) {\n                        for (i = 0; i < nchans; ++i)\n                            if (bytecnt) {\n                                wpc->channel_reordering [i] = *byteptr++;\n\n                                if (wpc->channel_reordering [i] >= nchans)                                     wpc->channel_reordering [i] = 0;\n\n                                bytecnt--;\n                            }\n                            else\n                                wpc->channel_reordering [i] = i;\n                    }\n                }\n            }\n            else\n                wpc->channel_layout += wpc->config.num_channels;\n        }\n    }\n\n    return TRUE;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nobj2ast_type_ignore(PyObject* obj, type_ignore_ty* out, PyArena* arena)\n{\n    int isinstance;\n\n    PyObject *tmp = NULL;\n\n    if (obj == Py_None) {\n        *out = NULL;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)TypeIgnore_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        int lineno;\n\n        if (_PyObject_LookupAttrId(obj, &PyId_lineno, &tmp) < 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"required field \\\"lineno\\\" missing from TypeIgnore\");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_int(tmp, &lineno, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = TypeIgnore(lineno, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n\n    PyErr_Format(PyExc_TypeError, \"expected some sort of type_ignore, but got %R\", obj);\n    failed:\n    Py_XDECREF(tmp);\n    return 1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid sctp_assoc_update(struct sctp_association *asoc,\n\t\t       struct sctp_association *new)\n{\n\tstruct sctp_transport *trans;\n\tstruct list_head *pos, *temp;\n\n\t\n\tasoc->c = new->c;\n\tasoc->peer.rwnd = new->peer.rwnd;\n\tasoc->peer.sack_needed = new->peer.sack_needed;\n\tasoc->peer.auth_capable = new->peer.auth_capable;\n\tasoc->peer.i = new->peer.i;\n\tsctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,\n\t\t\t asoc->peer.i.initial_tsn, GFP_ATOMIC);\n\n\t\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttrans = list_entry(pos, struct sctp_transport, transports);\n\t\tif (!sctp_assoc_lookup_paddr(new, &trans->ipaddr)) {\n\t\t\tsctp_assoc_rm_peer(asoc, trans);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (asoc->state >= SCTP_STATE_ESTABLISHED)\n\t\t\tsctp_transport_reset(trans);\n\t}\n\n\t\n\tif (asoc->state >= SCTP_STATE_ESTABLISHED) {\n\t\tasoc->next_tsn = new->next_tsn;\n\t\tasoc->ctsn_ack_point = new->ctsn_ack_point;\n\t\tasoc->adv_peer_ack_point = new->adv_peer_ack_point;\n\n\t\t\n\t\tsctp_ssnmap_clear(asoc->ssnmap);\n\n\t\t\n\t\tsctp_ulpq_flush(&asoc->ulpq);\n\n\t\t\n\t\tasoc->overall_error_count = 0;\n\n\t} else {\n\t\t\n\t\tlist_for_each_entry(trans, &new->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tif (!sctp_assoc_lookup_paddr(asoc, &trans->ipaddr))\n\t\t\t\tsctp_assoc_add_peer(asoc, &trans->ipaddr,\n\t\t\t\t\t\t    GFP_ATOMIC, trans->state);\n\t\t}\n\n\t\tasoc->ctsn_ack_point = asoc->next_tsn - 1;\n\t\tasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\n\t\tif (!asoc->ssnmap) {\n\t\t\t\n\t\t\tasoc->ssnmap = new->ssnmap;\n\t\t\tnew->ssnmap = NULL;\n\t\t}\n\n\t\tif (!asoc->assoc_id) {\n\t\t\t\n\t\t\tsctp_assoc_set_id(asoc, GFP_ATOMIC);\n\t\t}\n\t}\n\n\t\n\tkfree(asoc->peer.peer_random);\n\tasoc->peer.peer_random = new->peer.peer_random;\n\tnew->peer.peer_random = NULL;\n\n\tkfree(asoc->peer.peer_chunks);\n\tasoc->peer.peer_chunks = new->peer.peer_chunks;\n\tnew->peer.peer_chunks = NULL;\n\n\tkfree(asoc->peer.peer_hmacs);\n\tasoc->peer.peer_hmacs = new->peer.peer_hmacs;\n\tnew->peer.peer_hmacs = NULL;\n\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tsctp_auth_asoc_init_active_key(asoc, GFP_ATOMIC);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ntChecksumCheckResult ParaNdis_CheckRxChecksum(\n                                            PARANDIS_ADAPTER *pContext,\n                                            ULONG virtioFlags,\n                                            tCompletePhysicalAddress *pPacketPages,\n                                            ULONG ulPacketLength,\n                                            ULONG ulDataOffset)\n{\n    tOffloadSettingsFlags f = pContext->Offload.flags;\n    tChecksumCheckResult res, resIp;\n    tTcpIpPacketParsingResult ppr;\n    ULONG flagsToCalculate = 0;\n    res.value = 0;\n    resIp.value = 0;\n\n      \n    if (f.fRxIPChecksum) flagsToCalculate |= pcrIpChecksum;\n    if (!(virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID))\n    {\n        if (virtioFlags & VIRTIO_NET_HDR_F_NEEDS_CSUM)\n        {\n            flagsToCalculate |= pcrFixXxpChecksum | pcrTcpChecksum | pcrUdpChecksum;\n        }\n        else\n        {\n            if (f.fRxTCPChecksum) flagsToCalculate |= pcrTcpV4Checksum;\n            if (f.fRxUDPChecksum) flagsToCalculate |= pcrUdpV4Checksum;\n            if (f.fRxTCPv6Checksum) flagsToCalculate |= pcrTcpV6Checksum;\n            if (f.fRxUDPv6Checksum) flagsToCalculate |= pcrUdpV6Checksum;\n        }\n    }\n\n    ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__);\n\n    if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)\n    {\n        pContext->extraStatistics.framesRxCSHwOK++;\n        ppr.xxpCheckSum = ppresCSOK;\n    }\n\n    if (ppr.ipStatus == ppresIPV4 && !ppr.IsFragment)\n    {\n        if (f.fRxIPChecksum)\n        {\n            res.flags.IpOK =  ppr.ipCheckSum == ppresCSOK;\n            res.flags.IpFailed = ppr.ipCheckSum == ppresCSBad;\n        }\n        if(ppr.xxpStatus == ppresXxpKnown)\n        {\n            if(ppr.TcpUdp == ppresIsTCP) \n            {\n                if (f.fRxTCPChecksum)\n                {\n                    res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.TcpFailed = !res.flags.TcpOK;\n                }\n            }\n            else \n            {\n                if (f.fRxUDPChecksum)\n                {\n                    res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.UdpFailed = !res.flags.UdpOK;\n                }\n            }\n        }\n    }\n    else if (ppr.ipStatus == ppresIPV6)\n    {\n        if(ppr.xxpStatus == ppresXxpKnown)\n        {\n            if(ppr.TcpUdp == ppresIsTCP) \n            {\n                if (f.fRxTCPv6Checksum)\n                {\n                    res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.TcpFailed = !res.flags.TcpOK;\n                }\n            }\n            else \n            {\n                if (f.fRxUDPv6Checksum)\n                {\n                    res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.UdpFailed = !res.flags.UdpOK;\n                }\n            }\n        }\n    }\n\n    return res;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int pop_fetch_message (CONTEXT* ctx, MESSAGE* msg, int msgno)\n{\n  int ret;\n  void *uidl;\n  char buf[LONG_STRING];\n  char path[_POSIX_PATH_MAX];\n  progress_t progressbar;\n  POP_DATA *pop_data = (POP_DATA *)ctx->data;\n  POP_CACHE *cache;\n  HEADER *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  \n  if ((msg->fp = mutt_bcache_get (pop_data->bcache, h->data)))\n    return 0;\n\n  \n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    if (cache->index == h->index)\n    {\n      \n      msg->fp = fopen (cache->path, \"r\");\n      if (msg->fp)\n\treturn 0;\n      \n      mutt_perror (cache->path);\n      mutt_sleep (2);\n      return -1;\n    }\n    else\n    {\n      \n      unlink (cache->path);\n      FREE (&cache->path);\n    }\n  }\n\n  FOREVER\n  {\n    if (pop_reconnect (ctx) < 0)\n      return -1;\n\n    \n    if (h->refno < 0)\n    {\n      mutt_error _(\"The message index is incorrect. Try reopening the mailbox.\");\n      mutt_sleep (2);\n      return -1;\n    }\n\n    mutt_progress_init (&progressbar, _(\"Fetching message...\"),\n\t\t\tMUTT_PROGRESS_SIZE, NetInc, h->content->length + h->content->offset - 1);\n\n    \n    if (!(msg->fp = mutt_bcache_put (pop_data->bcache, h->data, 1)))\n    {\n      \n      bcache = 0;\n      mutt_mktemp (path, sizeof (path));\n      if (!(msg->fp = safe_fopen (path, \"w+\")))\n      {\n\tmutt_perror (path);\n\tmutt_sleep (2);\n\treturn -1;\n      }\n    }\n\n    snprintf (buf, sizeof (buf), \"RETR %d\\r\\n\", h->refno);\n\n    ret = pop_fetch_data (pop_data, buf, &progressbar, fetch_message, msg->fp);\n    if (ret == 0)\n      break;\n\n    safe_fclose (&msg->fp);\n\n    \n    if (!bcache)\n      unlink (path);\n\n    if (ret == -2)\n    {\n      mutt_error (\"%s\", pop_data->err_msg);\n      mutt_sleep (2);\n      return -1;\n    }\n\n    if (ret == -3)\n    {\n      mutt_error _(\"Can't write message to temporary file!\");\n      mutt_sleep (2);\n      return -1;\n    }\n  }\n\n  \n  if (bcache)\n    mutt_bcache_commit (pop_data->bcache, h->data);\n  else\n  {\n    cache->index = h->index;\n    cache->path = safe_strdup (path);\n  }\n  rewind (msg->fp);\n  uidl = h->data;\n\n  \n  if (ctx->subj_hash && h->env->real_subj)\n    hash_delete (ctx->subj_hash, h->env->real_subj, h, NULL);\n  mutt_label_hash_remove (ctx, h);\n  mutt_free_envelope (&h->env);\n  h->env = mutt_read_rfc822_header (msg->fp, h, 0, 0);\n  if (ctx->subj_hash && h->env->real_subj)\n    hash_insert (ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_add (ctx, h);\n\n  h->data = uidl;\n  h->lines = 0;\n  fgets (buf, sizeof (buf), msg->fp);\n  while (!feof (msg->fp))\n  {\n    ctx->hdrs[msgno]->lines++;\n    fgets (buf, sizeof (buf), msg->fp);\n  }\n\n  h->content->length = ftello (msg->fp) - h->content->offset;\n\n  \n  if (!WithCrypto)\n    h->security = crypt_query (h->content);\n\n  mutt_clear_error();\n  rewind (msg->fp);\n\n  return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)\n{\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\n\t\t\n\t\twhile (bytes || !iov->iov_len) {\n\t\t\tint copy = min(bytes, iov->iov_len - base);\n\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tbool basic_ioctls;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t\n\tfound = false;\n\tbasic_ioctls = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t\n\t\tret = -EINVAL;\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\t\n\t\tret = -EPERM;\n\t\tif (unlikely(!(cur->vm_flags & VM_MAYWRITE)))\n\t\t\tgoto out_unlock;\n\n\t\t\n\t\tif (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&\n\t\t    end > cur->vm_start) {\n\t\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(cur);\n\n\t\t\tret = -EINVAL;\n\n\t\t\tif (end & (vma_hpagesize - 1))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\t\n\t\tif (is_vm_hugetlb_page(cur))\n\t\t\tbasic_ioctls = true;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n\t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t\n\t\tif (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :\n\t\t\t     UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\t\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmessageAddArgument(message *m, const char *arg)\n{\n\tint offset;\n\tchar *p;\n\n\tassert(m != NULL);\n\n\tif(arg == NULL)\n\t\treturn;\t\n\n\twhile(isspace(*arg))\n\t\targ++;\n\n\tif(*arg == '\\0')\n\t\t\n\t\treturn;\n\n\tcli_dbgmsg(\"messageAddArgument, arg='%s'\\n\", arg);\n\n\tif(!usefulArg(arg))\n\t\treturn;\n\n\tfor(offset = 0; offset < m->numberOfArguments; offset++)\n\t\tif(m->mimeArguments[offset] == NULL)\n\t\t\tbreak;\n\t\telse if(strcasecmp(arg, m->mimeArguments[offset]) == 0)\n\t\t\treturn;\t\n\n\tif(offset == m->numberOfArguments) {\n\t\tchar **q;\n\n\t\tm->numberOfArguments++;\n\t\tq = (char **)cli_realloc(m->mimeArguments, m->numberOfArguments * sizeof(char *));\n\t\tif(q == NULL) {\n\t\t\tm->numberOfArguments--;\n\t\t\treturn;\n\t\t}\n\t\tm->mimeArguments = q;\n\t}\n\n\tp = m->mimeArguments[offset] = rfc2231(arg);\n\tif(!p) {\n\t\t\n\t\tcli_dbgmsg(\"messageAddArgument, error from rfc2231()\\n\");\n\t\treturn;\n\t}\n\n\tif(strchr(p, '=') == NULL) {\n\t\tif(strncmp(p, \"filename\", 8) == 0) {\n\t\t\t\n\t\t\tcli_dbgmsg(\"Possible data corruption fixed\\n\");\n\t\t\tp[8] = '=';\n\t\t} else {\n\t\t\tif(*p)\n\t\t\t\tcli_dbgmsg(\"messageAddArgument, '%s' contains no '='\\n\", p);\n\t\t\tfree(m->mimeArguments[offset]);\n\t\t\tm->mimeArguments[offset] = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t\n\tif((strncasecmp(p, \"filename=\", 9) == 0) || (strncasecmp(p, \"name=\", 5) == 0))\n\t\tif(messageGetMimeType(m) == NOMIME) {\n\t\t\tcli_dbgmsg(\"Force mime encoding to application\\n\");\n\t\t\tmessageSetMimeType(m, \"application\");\n\t\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\t\n\n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n\n\t\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} \n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline int xrstor_state(struct xsave_struct *fx, u64 mask)\n{\n\tint err = 0;\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\n\t\n\talternative_input(\n\t\t\"1: \" XRSTOR,\n\t\tXRSTORS,\n\t\tX86_FEATURE_XSAVES,\n\t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t: \"memory\");\n\n\tasm volatile(\"2:\\n\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\n\treturn err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nfstring_find_expr(const char **str, const char *end, int raw, int recurse_lvl,\n                  expr_ty *expression, struct compiling *c, const node *n)\n{\n    \n\n    const char *expr_start;\n    const char *expr_end;\n    expr_ty simple_expression;\n    expr_ty format_spec = NULL; \n    int conversion = -1; \n\n    \n    char quote_char = 0;\n\n    \n    int string_type = 0;\n\n    \n    Py_ssize_t nested_depth = 0;\n    char parenstack[MAXLEVEL];\n\n    \n    if (recurse_lvl >= 2) {\n        ast_error(c, n, \"f-string: expressions nested too deeply\");\n        return -1;\n    }\n\n    \n    assert(**str == '{');\n    *str += 1;\n\n    expr_start = *str;\n    for (; *str < end; (*str)++) {\n        char ch;\n\n        \n        assert(nested_depth >= 0);\n        assert(*str >= expr_start && *str < end);\n        if (quote_char)\n            assert(string_type == 1 || string_type == 3);\n        else\n            assert(string_type == 0);\n\n        ch = **str;\n        \n        if (ch == '\\\\') {\n            \n            ast_error(c, n, \"f-string expression part \"\n                            \"cannot include a backslash\");\n            return -1;\n        }\n        if (quote_char) {\n            \n            \n            if (ch == quote_char) {\n                \n                if (string_type == 3) {\n                    if (*str+2 < end && *(*str+1) == ch && *(*str+2) == ch) {\n                        \n                        *str += 2;\n                        string_type = 0;\n                        quote_char = 0;\n                        continue;\n                    }\n                } else {\n                    \n                    quote_char = 0;\n                    string_type = 0;\n                    continue;\n                }\n            }\n        } else if (ch == '\\'' || ch == '\"') {\n            \n            if (*str+2 < end && *(*str+1) == ch && *(*str+2) == ch) {\n                string_type = 3;\n                *str += 2;\n            } else {\n                \n                string_type = 1;\n            }\n            \n            quote_char = ch;\n        } else if (ch == '[' || ch == '{' || ch == '(') {\n            if (nested_depth >= MAXLEVEL) {\n                ast_error(c, n, \"f-string: too many nested parenthesis\");\n                return -1;\n            }\n            parenstack[nested_depth] = ch;\n            nested_depth++;\n        } else if (ch == '#') {\n            \n            ast_error(c, n, \"f-string expression part cannot include '#'\");\n            return -1;\n        } else if (nested_depth == 0 &&\n                   (ch == '!' || ch == ':' || ch == '}')) {\n            \n            if (ch == '!' && *str+1 < end && *(*str+1) == '=') {\n                \n                continue;\n            }\n            \n            break;\n        } else if (ch == ']' || ch == '}' || ch == ')') {\n            if (!nested_depth) {\n                ast_error(c, n, \"f-string: unmatched '%c'\", ch);\n                return -1;\n            }\n            nested_depth--;\n            int opening = parenstack[nested_depth];\n            if (!((opening == '(' && ch == ')') ||\n                  (opening == '[' && ch == ']') ||\n                  (opening == '{' && ch == '}')))\n            {\n                ast_error(c, n,\n                          \"f-string: closing parenthesis '%c' \"\n                          \"does not match opening parenthesis '%c'\",\n                          ch, opening);\n                return -1;\n            }\n        } else {\n            \n        }\n    }\n    expr_end = *str;\n    \n    if (quote_char) {\n        ast_error(c, n, \"f-string: unterminated string\");\n        return -1;\n    }\n    if (nested_depth) {\n        int opening = parenstack[nested_depth - 1];\n        ast_error(c, n, \"f-string: unmatched '%c'\", opening);\n        return -1;\n    }\n\n    if (*str >= end)\n        goto unexpected_end_of_string;\n\n    \n    simple_expression = fstring_compile_expr(expr_start, expr_end, c, n);\n    if (!simple_expression)\n        return -1;\n\n    \n    if (**str == '!') {\n        *str += 1;\n        if (*str >= end)\n            goto unexpected_end_of_string;\n\n        conversion = **str;\n        *str += 1;\n\n        \n        if (!(conversion == 's' || conversion == 'r'\n              || conversion == 'a')) {\n            ast_error(c, n, \"f-string: invalid conversion character: \"\n                            \"expected 's', 'r', or 'a'\");\n            return -1;\n        }\n    }\n\n    \n    if (*str >= end)\n        goto unexpected_end_of_string;\n    if (**str == ':') {\n        *str += 1;\n        if (*str >= end)\n            goto unexpected_end_of_string;\n\n        \n        format_spec = fstring_parse(str, end, raw, recurse_lvl+1, c, n);\n        if (!format_spec)\n            return -1;\n    }\n\n    if (*str >= end || **str != '}')\n        goto unexpected_end_of_string;\n\n    \n    assert(*str < end);\n    assert(**str == '}');\n    *str += 1;\n\n    \n    *expression = FormattedValue(simple_expression, conversion,\n                                 format_spec, LINENO(n), n->n_col_offset,\n                                 n->n_end_lineno, n->n_end_col_offset,\n                                 c->c_arena);\n    if (!*expression)\n        return -1;\n\n    return 0;\n\nunexpected_end_of_string:\n    ast_error(c, n, \"f-string: expecting '}'\");\n    return -1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nber_parse_header(STREAM s, int tagval, uint32 *length)\n{\n\tint tag, len;\n\n\tif (tagval > 0xff)\n\t{\n\t\tin_uint16_be(s, tag);\n\t}\n\telse\n\t{\n\t\tin_uint8(s, tag);\n\t}\n\n\tif (tag != tagval)\n\t{\n\t\tlogger(Core, Error, \"ber_parse_header(), expected tag %d, got %d\", tagval, tag);\n\t\treturn False;\n\t}\n\n\tin_uint8(s, len);\n\n\tif (len & 0x80)\n\t{\n\t\tlen &= ~0x80;\n\t\t*length = 0;\n\t\twhile (len--)\n\t\t\tnext_be(s, *length);\n\t}\n\telse\n\t\t*length = len;\n\n\treturn s_check(s);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n\tstruct iw_exif_state *e, iw_uint32 ifd)\n{\n\tunsigned int tag_count;\n\tunsigned int i;\n\tunsigned int tag_pos;\n\tunsigned int tag_id;\n\tunsigned int v;\n\tdouble v_dbl;\n\n\tif(ifd<8 || ifd>e->d_len-18) return;\n\n\ttag_count = iw_get_ui16_e(&e->d[ifd],e->endian);\n\tif(tag_count>1000) return;\n\tfor(i=0;i<tag_count;i++) {\n\t\ttag_pos = ifd+2+i*12;\n\t\tif(tag_pos+12 > e->d_len) return;\t\ttag_id = iw_get_ui16_e(&e->d[tag_pos],e->endian);\n\n\t\tswitch(tag_id) {\n\t\tcase 274:\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_orientation = v;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 296:\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_density_unit = v;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 282:\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_x = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 283:\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_y = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += get_primary_drawing_order_field_bytes(orderInfo->orderType, NULL);\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n\tchar const* parse_int(char const* start, char const* end, char delimiter, boost::int64_t& val)\n\t{\n\t\twhile (start < end && *start != delimiter)\n\t\t{\n\t\t\tif (!is_digit(*start)) { return 0; }\n\t\t\tval *= 10;\n\t\t\tval += *start - '0';\n\t\t\t++start;\n\t\t}\n\t\treturn start;\n\t}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid QuantizeMultiplier(double double_multiplier, int32_t* quantized_multiplier,\n                        int* left_shift) {\n  if (double_multiplier < 1.0) {\n    QuantizeMultiplierSmallerThanOneExp(double_multiplier, quantized_multiplier,\n                                        left_shift);\n  } else {\n    QuantizeMultiplierGreaterThanOne(double_multiplier, quantized_multiplier,\n                                     left_shift);\n  }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\n\t\t\t\t\t netdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *packet_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\t__wsum csum;\n\tint tnl_hlen;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t\n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\t\n\t\tif (!skb_shinfo(skb)->ip6_frag_id)\n\t\t\tipv6_proxy_select_ident(dev_net(skb->dev), skb);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\tif (skb->encapsulation && skb_shinfo(skb)->gso_type &\n\t    (SKB_GSO_UDP_TUNNEL|SKB_GSO_UDP_TUNNEL_CSUM))\n\t\tsegs = skb_udp_tunnel_segment(skb, features, true);\n\telse {\n\t\tconst struct ipv6hdr *ipv6h;\n\t\tstruct udphdr *uh;\n\n\t\tif (!pskb_may_pull(skb, sizeof(struct udphdr)))\n\t\t\tgoto out;\n\n\t\t\n\n\t\tuh = udp_hdr(skb);\n\t\tipv6h = ipv6_hdr(skb);\n\n\t\tuh->check = 0;\n\t\tcsum = skb_checksum(skb, 0, skb->len, 0);\n\t\tuh->check = udp_v6_check(skb->len, &ipv6h->saddr,\n\t\t\t\t\t  &ipv6h->daddr, csum);\n\t\tif (uh->check == 0)\n\t\t\tuh->check = CSUM_MANGLED_0;\n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\t\n\t\tif (!skb->encap_hdr_csum)\n\t\t\tfeatures |= NETIF_F_HW_CSUM;\n\n\t\t\n\t\ttnl_hlen = skb_tnl_header_len(skb);\n\t\tif (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {\n\t\t\tif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t\n\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\tif (unfrag_ip6hlen < 0)\n\t\t\treturn ERR_PTR(unfrag_ip6hlen);\n\t\tnexthdr = *prevhdr;\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\tunfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +\n\t\t\t     unfrag_ip6hlen + tnl_hlen;\n\t\tpacket_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;\n\t\tmemmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);\n\n\t\tSKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;\n\t\tskb->mac_header -= frag_hdr_sz;\n\t\tskb->network_header -= frag_hdr_sz;\n\n\t\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\t\tfptr->nexthdr = nexthdr;\n\t\tfptr->reserved = 0;\n\t\tif (!skb_shinfo(skb)->ip6_frag_id)\n\t\t\tipv6_proxy_select_ident(dev_net(skb->dev), skb);\n\t\tfptr->identification = skb_shinfo(skb)->ip6_frag_id;\n\n\t\t\n\t\tsegs = skb_segment(skb, features);\n\t}\n\nout:\n\treturn segs;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nonig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n\n err2:\n  if (cpat != pattern) xfree(cpat);\n\n  return r;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool logToUSDT(const Array& bt) {\n  std::lock_guard<std::mutex> lock(usdt_mutex);\n\n  memset(&bt_slab, 0, sizeof(bt_slab));\n\n  int i = 0;\n  IterateVNoInc(\n    bt.get(),\n    [&](TypedValue tv) -> bool {\n\n      if (i >= strobelight::kMaxStackframes) {\n        return true;\n      }\n\n      assertx(isArrayLikeType(type(tv)));\n      ArrayData* bt_frame = val(tv).parr;\n      strobelight::backtrace_frame_t* frame = &bt_slab.frames[i];\n\n      auto const line = bt_frame->get(s_line.get());\n      if (line.is_init()) {\n        assertx(isIntType(type(line)));\n        frame->line = val(line).num;\n      }\n\n      auto const file_name = bt_frame->get(s_file.get());\n      if (file_name.is_init()) {\n        assertx(isStringType(type(file_name)));\n        strncpy(frame->file_name,\n                val(file_name).pstr->data(),\n                std::min(val(file_name).pstr->size(), strobelight::kFileNameMax));\n        frame->file_name[strobelight::kFileNameMax - 1] = '\\0';\n      }\n\n      auto const class_name = bt_frame->get(s_class.get());\n      if (class_name.is_init()) {\n        assertx(isStringType(type(class_name)));\n        strncpy(frame->class_name,\n                val(class_name).pstr->data(),\n                std::min(val(class_name).pstr->size(), strobelight::kClassNameMax));\n        frame->class_name[strobelight::kClassNameMax - 1] = '\\0';\n      }\n\n      auto const function_name = bt_frame->get(s_function.get());\n      if (function_name.is_init()) {\n        assertx(isStringType(type(function_name)));\n        strncpy(frame->function,\n                val(function_name).pstr->data(),\n                std::min(val(function_name).pstr->size(),\n                         strobelight::kFunctionMax));\n        frame->function[strobelight::kFunctionMax - 1] = '\\0';\n      }\n\n      i++;\n      return false;\n    }\n  );\n  bt_slab.len = i;\n\n   FOLLY_SDT_WITH_SEMAPHORE(hhvm, hhvm_stack, &bt_slab);\n\n  return true;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nevutil_parse_sockaddr_port(const char *ip_as_string, struct sockaddr *out, int *outlen)\n{\n\tint port;\n\tchar buf[128];\n\tconst char *cp, *addr_part, *port_part;\n\tint is_ipv6;\n\t\n\n\tcp = strchr(ip_as_string, ':');\n\tif (*ip_as_string == '[') {\n\t\tint len;\n\t\tif (!(cp = strchr(ip_as_string, ']'))) {\n\t\t\treturn -1;\n\t\t}\n\t\tlen = (int) ( cp-(ip_as_string + 1) );\n\t\tif (len > (int)sizeof(buf)-1) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(buf, ip_as_string+1, len);\n\t\tbuf[len] = '\\0';\n\t\taddr_part = buf;\n\t\tif (cp[1] == ':')\n\t\t\tport_part = cp+2;\n\t\telse\n\t\t\tport_part = NULL;\n\t\tis_ipv6 = 1;\n\t} else if (cp && strchr(cp+1, ':')) {\n\t\tis_ipv6 = 1;\n\t\taddr_part = ip_as_string;\n\t\tport_part = NULL;\n\t} else if (cp) {\n\t\tis_ipv6 = 0;\n\t\tif (cp - ip_as_string > (int)sizeof(buf)-1) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(buf, ip_as_string, cp-ip_as_string);\n\t\tbuf[cp-ip_as_string] = '\\0';\n\t\taddr_part = buf;\n\t\tport_part = cp+1;\n\t} else {\n\t\taddr_part = ip_as_string;\n\t\tport_part = NULL;\n\t\tis_ipv6 = 0;\n\t}\n\n\tif (port_part == NULL) {\n\t\tport = 0;\n\t} else {\n\t\tport = atoi(port_part);\n\t\tif (port <= 0 || port > 65535) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!addr_part)\n\t\treturn -1; \n#ifdef AF_INET6\n\tif (is_ipv6)\n\t{\n\t\tstruct sockaddr_in6 sin6;\n\t\tmemset(&sin6, 0, sizeof(sin6));\n#ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN\n\t\tsin6.sin6_len = sizeof(sin6);\n#endif\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_port = htons(port);\n\t\tif (1 != evutil_inet_pton(AF_INET6, addr_part, &sin6.sin6_addr))\n\t\t\treturn -1;\n\t\tif ((int)sizeof(sin6) > *outlen)\n\t\t\treturn -1;\n\t\tmemset(out, 0, *outlen);\n\t\tmemcpy(out, &sin6, sizeof(sin6));\n\t\t*outlen = sizeof(sin6);\n\t\treturn 0;\n\t}\n\telse\n#endif\n\t{\n\t\tstruct sockaddr_in sin;\n\t\tmemset(&sin, 0, sizeof(sin));\n#ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n\t\tsin.sin_len = sizeof(sin);\n#endif\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = htons(port);\n\t\tif (1 != evutil_inet_pton(AF_INET, addr_part, &sin.sin_addr))\n\t\t\treturn -1;\n\t\tif ((int)sizeof(sin) > *outlen)\n\t\t\treturn -1;\n\t\tmemset(out, 0, *outlen);\n\t\tmemcpy(out, &sin, sizeof(sin));\n\t\t*outlen = sizeof(sin);\n\t\treturn 0;\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len,\n\t\t\t   int flags)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct scm_cookie scm;\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tint noblock = flags&MSG_DONTWAIT;\n\tsize_t copied;\n\tstruct sk_buff *skb, *data_skb;\n\tint err, ret;\n\n\tif (flags&MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tcopied = 0;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tdata_skb = skb;\n\n#ifdef CONFIG_COMPAT_NETLINK_MESSAGES\n\tif (unlikely(skb_shinfo(skb)->frag_list)) {\n\t\t\n\t\tif (flags & MSG_CMSG_COMPAT)\n\t\t\tdata_skb = skb_shinfo(skb)->frag_list;\n\t}\n#endif\n\n\tmsg->msg_namelen = 0;\n\n\tcopied = data_skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(data_skb);\n\terr = skb_copy_datagram_iovec(data_skb, 0, msg->msg_iov, copied);\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_nl *addr = (struct sockaddr_nl *)msg->msg_name;\n\t\taddr->nl_family = AF_NETLINK;\n\t\taddr->nl_pad    = 0;\n\t\taddr->nl_pid\t= NETLINK_CB(skb).portid;\n\t\taddr->nl_groups\t= netlink_group_mask(NETLINK_CB(skb).dst_group);\n\t\tmsg->msg_namelen = sizeof(*addr);\n\t}\n\n\tif (nlk->flags & NETLINK_RECV_PKTINFO)\n\t\tnetlink_cmsg_recv_pktinfo(msg, skb);\n\n\tif (NULL == siocb->scm) {\n\t\tmemset(&scm, 0, sizeof(scm));\n\t\tsiocb->scm = &scm;\n\t}\n\tsiocb->scm->creds = *NETLINK_CREDS(skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = data_skb->len;\n\n\tskb_free_datagram(sk, skb);\n\n\tif (nlk->cb_running &&\n\t    atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf / 2) {\n\t\tret = netlink_dump(sk);\n\t\tif (ret) {\n\t\t\tsk->sk_err = ret;\n\t\t\tsk->sk_error_report(sk);\n\t\t}\n\t}\n\n\tscm_recv(sock, msg, siocb->scm, flags);\nout:\n\tnetlink_rcv_wake(sk);\n\treturn err ? : copied;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nObfuscatedPasswd::ObfuscatedPasswd(const PlainPasswd& plainPwd) : CharArray(8), length(8) {\n  size_t l = strlen(plainPwd.buf), i;\n  for (i=0; i<8; i++)\n    buf[i] = i<l ? plainPwd.buf[i] : 0;\n  deskey(d3desObfuscationKey, EN0);\n  des((rdr::U8*)buf, (rdr::U8*)buf);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic unsigned int seedsize(struct crypto_alg *alg)\n{\n\tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n\n\treturn alg->cra_rng.rng_make_random ?\n\t       alg->cra_rng.seedsize : ralg->seedsize;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void nalm_dump(FILE * trace, char *data, u32 data_size)\n{\n\tGF_BitStream *bs;\n\n\tBool rle, large_size;\n\tu32 entry_count;\n\n\tif (!data) {\n\t\tfprintf(trace, \"<NALUMap rle=\\\"\\\" large_size=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<NALUMapEntry NALU_startNumber=\\\"\\\" groupID=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</NALUMap>\\n\");\n\t\treturn;\n\t}\n\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tgf_bs_read_int(bs, 6);\n\tlarge_size = gf_bs_read_int(bs, 1);\n\trle = gf_bs_read_int(bs, 1);\n\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\tfprintf(trace, \"<NALUMap rle=\\\"%d\\\" large_size=\\\"%d\\\">\\n\", rle, large_size);\n\n\twhile (entry_count) {\n\t\tu32 ID;\n\t\tfprintf(trace, \"<NALUMapEntry \");\n\t\tif (rle) {\n\t\t\tu32 start_num = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tfprintf(trace, \"NALU_startNumber=\\\"%d\\\" \", start_num);\n\t\t}\n\t\tID = gf_bs_read_u16(bs);\n\t\tfprintf(trace, \"groupID=\\\"%d\\\"/>\\n\", ID);\n\t\tentry_count--;\n\t}\n\tgf_bs_del(bs);\n\tfprintf(trace, \"</NALUMap>\\n\");\n\treturn;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nl2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* axis = GetInput(context, node, kAxisTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(axis), 1);\n  TF_LITE_ENSURE(context, NumDimensions(input) >= NumElements(axis));\n\n  if (input->type != kTfLiteInt32 && input->type != kTfLiteFloat32 &&\n      input->type != kTfLiteUInt8 && input->type != kTfLiteInt16 &&\n      input->type != kTfLiteInt64 && input->type != kTfLiteBool) {\n    context->ReportError(context, \"Type '%s' is not supported by reverse.\",\n                         TfLiteTypeGetName(input->type));\n    return kTfLiteError;\n  }\n\n  if (axis->type != kTfLiteInt32) {\n    context->ReportError(context, \"Axis Type '%s' is not supported by reverse.\",\n                         TfLiteTypeGetName(axis->type));\n    return kTfLiteError;\n  }\n\n   if (NumElements(axis) > 1) {\n    context->ReportError(context, \"Current does not support more than 1 axis.\");\n  }\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCopy(input->dims);\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, input->type);\n\n  return context->ResizeTensor(context, output, output_shape);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPJ_DEF(pj_status_t) pjsip_ua_register_dlg( pjsip_user_agent *ua,\n\t\t\t\t\t   pjsip_dialog *dlg )\n{\n    \n    PJ_ASSERT_RETURN(ua && dlg, PJ_EINVAL);\n\n    \n    PJ_ASSERT_RETURN(dlg->local.info && dlg->local.info->tag.slen &&\n\t\t     dlg->local.tag_hval != 0, PJ_EBUG);\n\n    \n         \n    \n    pj_mutex_lock(mod_ua.mutex);\n\n    \n    if (dlg->role == PJSIP_ROLE_UAC) {\n\tstruct dlg_set *dlg_set;\n\n\tdlg_set = (struct dlg_set*)\n\t\t  pj_hash_get_lower( mod_ua.dlg_table,\n                                     dlg->local.info->tag.ptr, \n\t\t\t             (unsigned)dlg->local.info->tag.slen,\n\t\t\t             &dlg->local.tag_hval);\n\n\tif (dlg_set) {\n\t    \n\t    pj_assert(dlg_set->dlg_list.next != (void*)&dlg_set->dlg_list);\n\t    pj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\t    dlg->dlg_set = dlg_set;\n\n\t} else {\n\t    \n\t    dlg_set = alloc_dlgset_node();\n\t    pj_list_init(&dlg_set->dlg_list);\n\t    pj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\t    dlg->dlg_set = dlg_set;\n\n\t    \n\t    pj_hash_set_np_lower(mod_ua.dlg_table, \n\t\t\t         dlg->local.info->tag.ptr,\n                                 (unsigned)dlg->local.info->tag.slen,\n\t\t\t         dlg->local.tag_hval, dlg_set->ht_entry,\n                                 dlg_set);\n\t}\n\n    } else {\n\t\n\tstruct dlg_set *dlg_set;\n\n\tdlg_set = alloc_dlgset_node();\n\tpj_list_init(&dlg_set->dlg_list);\n\tpj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\tdlg->dlg_set = dlg_set;\n\n\tpj_hash_set_np_lower(mod_ua.dlg_table, \n\t\t             dlg->local.info->tag.ptr,\n                             (unsigned)dlg->local.info->tag.slen,\n\t\t             dlg->local.tag_hval, dlg_set->ht_entry, dlg_set);\n    }\n\n    \n    pj_mutex_unlock(mod_ua.mutex);\n\n    \n    return PJ_SUCCESS;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tjas_matind_t i;\n\tjas_matind_t j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < mat0->numrows_; i++) {\n\t\tfor (j = 0; j < mat0->numcols_; j++) {\n\t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nseamless_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tchar *buf;\n\tstruct stream packet = *s;\n\n\tif (!s_check(s))\n\t{\n\t\trdp_protocol_error(\"seamless_process(), stream is in unstable state\", &packet);\n\t}\n\n\tpkglen = s->end - s->p;\n\t\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);\n\n\txfree(buf);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nreceive_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='stabber@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+test carbon from recipient\"));\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nNTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tUINT16 id;\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\n\twhile (pAvPair && ntlm_av_pair_get_id(pAvPair, cbAvPair, &id))\n\t{\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n\n\tif (!pAvPair)\n\t\tcbAvPair = 0;\n\tif (pcbAvPairListRemaining)\n\t\t*pcbAvPairListRemaining = cbAvPair;\n\n\treturn pAvPair;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid show_object_with_name(FILE *out, struct object *obj, const char *name)\n{\n\tconst char *p;\n\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n         TF_LITE_ENSURE_EQ(context, NumOutputs(node), 0);\n\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputVariableId);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumElements(input_resource_id_tensor), 1);\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprivsep_preauth(Authctxt *authctxt)\n{\n\tint status, r;\n\tpid_t pid;\n\tstruct ssh_sandbox *box = NULL;\n\n\t\n\tpmonitor = monitor_init();\n\t\n\tpmonitor->m_pkex = &active_state->kex;\n\n\tif (use_privsep == PRIVSEP_ON)\n\t\tbox = ssh_sandbox_init();\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfatal(\"fork of unprivileged child failed\");\n\t} else if (pid != 0) {\n\t\tdebug2(\"Network child is on pid %ld\", (long)pid);\n\n\t\tpmonitor->m_pid = pid;\n\t\tif (have_agent) {\n\t\t\tr = ssh_get_authentication_socket(&auth_sock);\n\t\t\tif (r != 0) {\n\t\t\t\terror(\"Could not get agent socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t\t\thave_agent = 0;\n\t\t\t}\n\t\t}\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_preauth(box, pid);\n\t\tmonitor_child_preauth(authctxt, pmonitor);\n\n\t\t\n\t\tmonitor_sync(pmonitor);\n\n\t\t\n\t\twhile (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tpmonitor->m_pid = -1;\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t\t}\n\t\tprivsep_is_preauth = 0;\n\t\tpmonitor->m_pid = -1;\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status) != 0)\n\t\t\t\tfatal(\"%s: preauth child exited with status %d\",\n\t\t\t\t    __func__, WEXITSTATUS(status));\n\t\t} else if (WIFSIGNALED(status))\n\t\t\tfatal(\"%s: preauth child terminated by signal %d\",\n\t\t\t    __func__, WTERMSIG(status));\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_finish(box);\n\t\treturn 1;\n\t} else {\n\t\t\n\t\tclose(pmonitor->m_sendfd);\n\t\tclose(pmonitor->m_log_recvfd);\n\n\t\t\n\t\tset_log_handler(mm_log_handler, pmonitor);\n\n\t\tprivsep_preauth_child();\n\t\tsetproctitle(\"%s\", \"[net]\");\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_child(box);\n\n\t\treturn 0;\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_bitmap_updates(STREAM s)\n{\n\tuint16 num_updates;\n\tuint16 left, top, right, bottom, width, height;\n\tuint16 cx, cy, bpp, Bpp, compress, bufsize, size;\n\tuint8 *data, *bmpdata;\n\tint i;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint16_le(s, num_updates);\n\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tin_uint16_le(s, left);\n\t\tin_uint16_le(s, top);\n\t\tin_uint16_le(s, right);\n\t\tin_uint16_le(s, bottom);\n\t\tin_uint16_le(s, width);\n\t\tin_uint16_le(s, height);\n\t\tin_uint16_le(s, bpp);\n\t\tBpp = (bpp + 7) / 8;\n\t\tin_uint16_le(s, compress);\n\t\tin_uint16_le(s, bufsize);\n\n\t\tcx = right - left + 1;\n\t\tcy = bottom - top + 1;\n\n\t\tlogger(Graphics, Debug,\n\t\t       \"process_bitmap_updates(), [%d,%d,%d,%d], [%d,%d], bpp=%d, compression=%d\",\n\t\t       left, top, right, bottom, width, height, Bpp, compress);\n\n\t\tif (!compress)\n\t\t{\n\t\t\tint y;\n\t\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\t\tfor (y = 0; y < height; y++)\n\t\t\t{\n\t\t\t\tin_uint8a(s, &bmpdata[(height - y - 1) * (width * Bpp)],\n\t\t\t\t\t  width * Bpp);\n\t\t\t}\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\t\txfree(bmpdata);\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (compress & 0x400)\n\t\t{\n\t\t\tsize = bufsize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin_uint8s(s, 2);\t\n\t\t\tin_uint16_le(s, size);\n\t\t\tin_uint8s(s, 4);\t\n\t\t}\n\t\tin_uint8p(s, data, size);\n\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n\t\t{\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_bitmap_updates(), failed to decompress bitmap\");\n\t\t}\n\n\t\txfree(bmpdata);\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); \n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); \n\n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tunsigned long *table = crst_table_alloc(mm);\n\n\tif (!table)\n\t\treturn NULL;\n\tif (mm->context.asce_limit == (1UL << 31)) {\n\t\t\n\t\tif (!pgtable_pmd_page_ctor(virt_to_page(table))) {\n\t\t\tcrst_table_free(mm, table);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn (pgd_t *) table;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len,\n\t\t\t   int flags)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct scm_cookie scm;\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tint noblock = flags&MSG_DONTWAIT;\n\tsize_t copied;\n\tstruct sk_buff *skb, *data_skb;\n\tint err, ret;\n\n\tif (flags&MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tcopied = 0;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tdata_skb = skb;\n\n#ifdef CONFIG_COMPAT_NETLINK_MESSAGES\n\tif (unlikely(skb_shinfo(skb)->frag_list)) {\n\t\t\n\t\tif (flags & MSG_CMSG_COMPAT)\n\t\t\tdata_skb = skb_shinfo(skb)->frag_list;\n\t}\n#endif\n\n\tmsg->msg_namelen = 0;\n\n\tcopied = data_skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(data_skb);\n\terr = skb_copy_datagram_iovec(data_skb, 0, msg->msg_iov, copied);\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_nl *addr = (struct sockaddr_nl *)msg->msg_name;\n\t\taddr->nl_family = AF_NETLINK;\n\t\taddr->nl_pad    = 0;\n\t\taddr->nl_pid\t= NETLINK_CB(skb).portid;\n\t\taddr->nl_groups\t= netlink_group_mask(NETLINK_CB(skb).dst_group);\n\t\tmsg->msg_namelen = sizeof(*addr);\n\t}\n\n\tif (nlk->flags & NETLINK_RECV_PKTINFO)\n\t\tnetlink_cmsg_recv_pktinfo(msg, skb);\n\n\tif (NULL == siocb->scm) {\n\t\tmemset(&scm, 0, sizeof(scm));\n\t\tsiocb->scm = &scm;\n\t}\n\tsiocb->scm->creds = *NETLINK_CREDS(skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = data_skb->len;\n\n\tskb_free_datagram(sk, skb);\n\n\tif (nlk->cb_running &&\n\t    atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf / 2) {\n\t\tret = netlink_dump(sk);\n\t\tif (ret) {\n\t\t\tsk->sk_err = ret;\n\t\t\tsk->sk_error_report(sk);\n\t\t}\n\t}\n\n\tscm_recv(sock, msg, siocb->scm, flags);\nout:\n\tnetlink_rcv_wake(sk);\n\treturn err ? : copied;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint64_t MemFile::readImpl(char *buffer, int64_t length) {\n  assertx(m_len != -1);\n  assertx(length > 0);\n  assertx(m_cursor >= 0);\n  int64_t remaining = m_len - m_cursor;\n  if (remaining < length) length = remaining;\n  if (length > 0) {\n    memcpy(buffer, (const void *)(m_data + m_cursor), length);\n    m_cursor += length;\n    return length;\n  }\n  return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ngrowable_int_array_deallocate(growable_int_array *arr) {\n    free(arr->items);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nSPL_METHOD(SplFileObject, getMaxLineLen)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG((long)intern->u.file.max_line_len);\n} \n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nR_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tut8 *attr_buf = NULL;\n\tint pending = len - offset;\n\tconst ut8 *a_buf = offset + buf;\n\tattr_buf = (ut8 *) calloc (pending + 1, 1);\n\tif (!attr_buf) {\n\t\teprintf (\"Unable to allocate enough bytes (0x%04\"PFMT64x\n\t\t\t\") to read in the attribute.\\n\", sz);\n\t\treturn attr_buf;\n\t}\n\tmemcpy (attr_buf, a_buf, pending);\treturn attr_buf;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS(s);\n\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; \n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS(s);\n      ptmp = tmp;\n      while (isdigit((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = '\\0';\n      if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      \n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      \n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n\n  return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nrdpsnd_process_training(STREAM in)\n{\n\tuint16 tick;\n\tuint16 packsize;\n\tSTREAM out;\n\tstruct stream packet = *in;\n\n\tif (!s_check_rem(in, 4))\n\t{\n\t\trdp_protocol_error(\"rdpsnd_process_training(), consume of training data from stream would overrun\", &packet);\n\t}\n\n\tin_uint16_le(in, tick);\n\tin_uint16_le(in, packsize);\n\n\tlogger(Sound, Debug, \"rdpsnd_process_training(), tick=0x%04x\", (unsigned) tick);\n\n\tout = rdpsnd_init_packet(SNDC_TRAINING, 4);\n\tout_uint16_le(out, tick);\n\tout_uint16_le(out, packsize);\n\ts_mark_end(out);\n\trdpsnd_send(out);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\n\t*data = &iterator->current;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline bool can_follow_write_pte(pte_t pte, unsigned int flags)\n{\n\treturn pte_write(pte) ||\n\t\t((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nnewkeys_from_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n{\n\tstruct sshbuf *b = NULL;\n\tstruct sshcomp *comp;\n\tstruct sshenc *enc;\n\tstruct sshmac *mac;\n\tstruct newkeys *newkey = NULL;\n\tsize_t keylen, ivlen, maclen;\n\tint r;\n\n\tif ((newkey = calloc(1, sizeof(*newkey))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\tenc = &newkey->enc;\n\tmac = &newkey->mac;\n\tcomp = &newkey->comp;\n\n\tif ((r = sshbuf_get_cstring(b, &enc->name, NULL)) != 0 ||\n\t    (r = sshbuf_get(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||\n\t    (r = sshbuf_get_u32(b, (u_int *)&enc->enabled)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &enc->block_size)) != 0 ||\n\t    (r = sshbuf_get_string(b, &enc->key, &keylen)) != 0 ||\n\t    (r = sshbuf_get_string(b, &enc->iv, &ivlen)) != 0)\n\t\tgoto out;\n\tif (cipher_authlen(enc->cipher) == 0) {\n\t\tif ((r = sshbuf_get_cstring(b, &mac->name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = mac_setup(mac, mac->name)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = sshbuf_get_u32(b, (u_int *)&mac->enabled)) != 0 ||\n\t\t    (r = sshbuf_get_string(b, &mac->key, &maclen)) != 0)\n\t\t\tgoto out;\n\t\tif (maclen > mac->key_len) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tmac->key_len = maclen;\n\t}\n\tif ((r = sshbuf_get_u32(b, &comp->type)) != 0 ||\n\t    (r = sshbuf_get_u32(b, (u_int *)&comp->enabled)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &comp->name, NULL)) != 0)\n\t\tgoto out;\n\tif (enc->name == NULL ||\n\t    cipher_by_name(enc->name) != enc->cipher) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tenc->key_len = keylen;\n\tenc->iv_len = ivlen;\n\tssh->kex->newkeys[mode] = newkey;\n\tnewkey = NULL;\n\tr = 0;\n out:\n\tfree(newkey);\n\tsshbuf_free(b);\n\treturn r;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header = get_header(fp);\n\n    \n    const char *c;\n    if ((c = strstr(header, \"%PDF-\")) && \n        ((c + 6)[0] == '.') &&        isdigit((c + 5)[0]) &&        isdigit((c + 7)[0]))      {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n\n    free(header);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic bool parseOperands(char* str, ArmOp *op) {\n\tchar *t = strdup (str);\n\tint operand = 0;\n\tchar *token = t;\n\tchar *x;\n\tint imm_count = 0;\n\tint mem_opt = 0;\n\tif (!token) {\n\t\treturn false;\n\t}\n\n\twhile (token) {\n\t\tchar *next = strchr (token, ',');\n\t\tif (next) {\n\t\t\t*next++ = 0;\n\t\t}\n\t\twhile (token[0] == ' ') {\n\t\t\ttoken++;\n\t\t}\n\t\tif (operand >= MAX_OPERANDS) {\n\t\t\teprintf (\"Too many operands\\n\");\n\t\t\treturn false;\n\t\t}\n\t\top->operands[operand].type = ARM_NOTYPE;\n\t\top->operands[operand].reg_type = ARM_UNDEFINED;\n\t\top->operands[operand].shift = ARM_NO_SHIFT;\n\n\t\twhile (token[0] == ' ' || token[0] == '[' || token[0] == ']') {\n\t\t\ttoken ++;\n\t\t}\n\n\t\tif (!strncmp (token, \"lsl\", 3)) {\n\t\t\top->operands[operand].shift = ARM_LSL;\n\t\t} else if (!strncmp (token, \"lsr\", 3)) {\n\t\t\top->operands[operand].shift = ARM_LSR;\n\t\t} else if (!strncmp (token, \"asr\", 3)) {\n\t\t\top->operands[operand].shift = ARM_ASR;\n\t\t}\n\t\tif (strlen (token) > 4 && op->operands[operand].shift != ARM_NO_SHIFT) {\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].shift_amount = r_num_math (NULL, token + 4);\n\t\t\tif (op->operands[operand].shift_amount > 63) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\toperand ++;\n\t\t\ttoken = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (token[0]) {\n\t\tcase 'x':\n\t\t\tx = strchr (token, ',');\n\t\t\tif (x) {\n\t\t\t\tx[0] = '\\0';\n\t\t\t}\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\top->operands[operand].reg_type = ARM_REG64;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tif (op->operands[operand].reg > 31) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\top->operands[operand].reg_type = ARM_REG32;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tif (op->operands[operand].reg > 31) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_FP;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tif (token[1] == 'P' || token [1] == 'p') {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; msr_const[i].name; i++) {\n\t\t\t\t\tif (!r_str_ncasecmp (token, msr_const[i].name, strlen (msr_const[i].name))) {\n\t\t\t\t\t\top->operands[operand].sp_val = msr_const[i].val;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\t\top->operands[operand].reg_type = ARM_SP | ARM_REG64;\n\t\t\t\top->operands[operand].reg = 31;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmem_opt = get_mem_option (token);\n\t\t\tif (mem_opt != -1) {\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_MEM_OPT;\n\t\t\t\top->operands[operand].mem_option = mem_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\tcase 'l':\n\t\tcase 'I':\n\t\tcase 'i':\n\t\tcase 'N':\n\t\tcase 'n':\n\t\tcase 'O':\n\t\tcase 'o':\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\tmem_opt = get_mem_option (token);\n\t\t\tif (mem_opt != -1) {\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_MEM_OPT;\n\t\t\t\top->operands[operand].mem_option = mem_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\top->operands[operand].sign = -1;\n\t\t\t\tdefault:\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_CONSTANT;\n\t\t\top->operands[operand].immediate = r_num_math (NULL, token);\n\t\t\timm_count++;\n\t\t\tbreak;\n\t\t}\n\t\ttoken = next;\n\n\t\toperand ++;\n\t\tif (operand > MAX_OPERANDS) {\n\t\t\tfree (t);\n\t\t\treturn false;\n\t\t}\n\t}\n\tfree (t);\n\treturn true;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_secondary_order(STREAM s)\n{\n\t\n\tuint16 length;\n\tuint16 flags;\n\tuint8 type;\n\tuint8 *next_order;\n\tstruct stream packet = *s;\n\n\tin_uint16_le(s, length);\n\tin_uint16_le(s, flags);\t\n\tin_uint8(s, type);\n\n\tif (!s_check_rem(s, length + 7))\n\t{\n\t\trdp_protocol_error(\"process_secondary_order(), next order pointer would overrun stream\", &packet);\n\t}\n\n\tnext_order = s->p + (sint16) length + 7;\n\n\tswitch (type)\n\t{\n\t\tcase RDP_ORDER_RAW_BMPCACHE:\n\t\t\tprocess_raw_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_COLCACHE:\n\t\t\tprocess_colcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE:\n\t\t\tprocess_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_FONTCACHE:\n\t\t\tprocess_fontcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_RAW_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, False);\t\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, True);\t\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BRUSHCACHE:\n\t\t\tprocess_brushcache(s, flags);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_secondary_order(), unhandled secondary order %d\", type);\n\t}\n\n\ts->p = next_order;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (output->type) {\n    case kTfLiteFloat32: {\n      return ReverseSequenceHelper<float>(context, node);\n    }\n    case kTfLiteUInt8: {\n      return ReverseSequenceHelper<uint8_t>(context, node);\n    }\n    case kTfLiteInt16: {\n      return ReverseSequenceHelper<int16_t>(context, node);\n    }\n    case kTfLiteInt32: {\n      return ReverseSequenceHelper<int32_t>(context, node);\n    }\n    case kTfLiteInt64: {\n      return ReverseSequenceHelper<int64_t>(context, node);\n    }\n    default: {\n      context->ReportError(context,\n                           \"Type '%s' is not supported by reverse_sequence.\",\n                           TfLiteTypeGetName(output->type));\n      return kTfLiteError;\n    }\n  }\n  return kTfLiteOk;\n}  // namespace\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid RemoteFsDevice::mount()\n{\n    if (details.isLocalFile()) {\n        return;\n    }\n    if (isConnected() || proc) {\n        return;\n    }\n\n    if (messageSent) {\n        return;\n    }\n    if (constSambaAvahiProtocol==details.url.scheme()) {\n        Details det=details;\n        AvahiService *srv=Avahi::self()->getService(det.serviceName);\n        if (!srv || srv->getHost().isEmpty() || 0==srv->getPort()) {\n            emit error(tr(\"Failed to resolve connection details for %1\").arg(details.name));\n            return;\n        }\n        if (constPromptPassword==det.url.password()) {\n            bool ok=false;\n            QString passwd=InputDialog::getPassword(QString(), &ok, QApplication::activeWindow());\n            if (!ok) {\n                return;\n            }\n            det.url.setPassword(passwd);\n        }\n        det.url.setScheme(constSambaProtocol);\n        det.url.setHost(srv->getHost());\n        det.url.setPort(srv->getPort());\n        mounter()->mount(det.url.toString(), mountPoint(details, true), getuid(), getgid(), getpid());\n        setStatusMessage(tr(\"Connecting...\"));\n        messageSent=true;\n        return;\n    }\n    if (constSambaProtocol==details.url.scheme()) {\n        Details det=details;\n        if (constPromptPassword==det.url.password()) {\n            bool ok=false;\n            QString passwd=InputDialog::getPassword(QString(), &ok, QApplication::activeWindow());\n            if (!ok) {\n                return;\n            }\n            det.url.setPassword(passwd);\n        }\n        mounter()->mount(det.url.toString(), mountPoint(details, true), getuid(), getgid(), getpid());\n        setStatusMessage(tr(\"Connecting...\"));\n        messageSent=true;\n        return;\n    }\n\n    QString cmd;\n    QStringList args;\n    QString askPass;\n    if (!details.isLocalFile() && !details.isEmpty()) {\n               bool needAskPass=!details.extraOptions.contains(\"IdentityFile=\");\n\n        if (needAskPass) {\n            QStringList askPassList;\n            if (Utils::KDE==Utils::currentDe()) {\n                askPassList << QLatin1String(\"ksshaskpass\") << QLatin1String(\"ssh-askpass\") << QLatin1String(\"ssh-askpass-gnome\");\n            } else {\n                askPassList << QLatin1String(\"ssh-askpass-gnome\") << QLatin1String(\"ssh-askpass\") << QLatin1String(\"ksshaskpass\");\n            }\n\n            for (const QString &ap: askPassList) {\n                askPass=Utils::findExe(ap);\n                if (!askPass.isEmpty()) {\n                    break;\n                }\n            }\n\n            if (askPass.isEmpty()) {\n                emit error(tr(\"No suitable ssh-askpass application installed! This is required for entering passwords.\"));\n                return;\n            }\n        }\n        QString sshfs=Utils::findExe(\"sshfs\");\n        if (sshfs.isEmpty()) {\n            emit error(tr(\"\\\"sshfs\\\" is not installed!\"));\n            return;\n        }\n        cmd=Utils::findExe(\"setsid\");\n        if (!cmd.isEmpty()) {\n            QString mp=mountPoint(details, true);\n            if (mp.isEmpty()) {\n                emit error(\"Failed to determine mount point\");            }\n            if (!QDir(mp).entryList(QDir::NoDot|QDir::NoDotDot|QDir::AllEntries|QDir::Hidden).isEmpty()) {\n                emit error(tr(\"Mount point (\\\"%1\\\") is not empty!\").arg(mp));\n                return;\n            }\n\n            args << sshfs << details.url.userName()+QChar('@')+details.url.host()+QChar(':')+details.url.path()<< QLatin1String(\"-p\")\n                 << QString::number(details.url.port()) << mountPoint(details, true)\n                 << QLatin1String(\"-o\") << QLatin1String(\"ServerAliveInterval=15\");\n                       if (!details.extraOptions.isEmpty()) {\n                args << details.extraOptions.split(' ', QString::SkipEmptyParts);\n            }\n        } else {\n            emit error(tr(\"\\\"sshfs\\\" is not installed!\").replace(\"sshfs\", \"setsid\"));        }\n    }\n\n    if (!cmd.isEmpty()) {\n        setStatusMessage(tr(\"Connecting...\"));\n        proc=new QProcess(this);\n        proc->setProperty(\"mount\", true);\n\n        if (!askPass.isEmpty()) {\n            QProcessEnvironment env = QProcessEnvironment::systemEnvironment();\n            env.insert(\"SSH_ASKPASS\", askPass);\n            proc->setProcessEnvironment(env);\n        }\n        connect(proc, SIGNAL(finished(int)), SLOT(procFinished(int)));\n        proc->start(cmd, args, QIODevice::ReadOnly);\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\t\t size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ddpehdr *ddp;\n\tint copied = 0;\n\tint offset = 0;\n\tint err = 0;\n\tstruct sk_buff *skb;\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tlock_sock(sk);\n\n\tif (!skb)\n\t\tgoto out;\n\n\t\n\tddp = ddp_hdr(skb);\n\tcopied = ntohs(ddp->deh_len_hops) & 1023;\n\n\tif (sk->sk_type != SOCK_RAW) {\n\t\toffset = sizeof(*ddp);\n\t\tcopied -= offset;\n\t}\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n\n\tif (!err && msg->msg_name) {\n\t\tstruct sockaddr_at *sat = msg->msg_name;\n\t\tsat->sat_family      = AF_APPLETALK;\n\t\tsat->sat_port        = ddp->deh_sport;\n\t\tsat->sat_addr.s_node = ddp->deh_snode;\n\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n\t\tmsg->msg_namelen     = sizeof(*sat);\n\t}\n\n\tskb_free_datagram(sk, skb);\t\n\nout:\n\trelease_sock(sk);\n\treturn err ? : copied;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, zend_long elements, int objprops)\n{\n\twhile (elements-- > 0) {\n\t\tzval key, *data, d, *old_data;\n\t\tzend_ulong idx;\n\n\t\tZVAL_UNDEF(&key);\n\n\t\tif (!php_var_unserialize_internal(&key, p, max, NULL, classes)) {\n\t\t\tzval_dtor(&key);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdata = NULL;\n\t\tZVAL_UNDEF(&d);\n\n\t\tif (!objprops) {\n\t\t\tif (Z_TYPE(key) == IS_LONG) {\n\t\t\t\tidx = Z_LVAL(key);\nnumeric_key:\n\t\t\t\tif (UNEXPECTED((old_data = zend_hash_index_find(ht, idx)) != NULL)) {\n\t\t\t\t\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t\tdata = zend_hash_index_update(ht, idx, &d);\n\t\t\t\t} else {\n\t\t\t\t\tdata = zend_hash_index_add_new(ht, idx, &d);\n\t\t\t\t}\n\t\t\t} else if (Z_TYPE(key) == IS_STRING) {\n\t\t\t\tif (UNEXPECTED(ZEND_HANDLE_NUMERIC(Z_STR(key), idx))) {\n\t\t\t\t\tgoto numeric_key;\n\t\t\t\t}\n\t\t\t\tif (UNEXPECTED((old_data = zend_hash_find(ht, Z_STR(key))) != NULL)) {\n\t\t\t\t\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t\tdata = zend_hash_update(ht, Z_STR(key), &d);\n\t\t\t\t} else {\n\t\t\t\t\tdata = zend_hash_add_new(ht, Z_STR(key), &d);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tzval_dtor(&key);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (EXPECTED(Z_TYPE(key) == IS_STRING)) {\nstring_key:\n\t\t\t\tif ((old_data = zend_hash_find(ht, Z_STR(key))) != NULL) {\n\t\t\t\t\tif (Z_TYPE_P(old_data) == IS_INDIRECT) {\n\t\t\t\t\t\told_data = Z_INDIRECT_P(old_data);\n\t\t\t\t\t}\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t\tdata = zend_hash_update_ind(ht, Z_STR(key), &d);\n\t\t\t\t} else {\n\t\t\t\t\tdata = zend_hash_add_new(ht, Z_STR(key), &d);\n\t\t\t\t}\n\t\t\t} else if (Z_TYPE(key) == IS_LONG) {\n\t\t\t\t\n\t\t\t\tconvert_to_string(&key);\n\t\t\t\tgoto string_key;\n\t\t\t} else {\n\t\t\t\tzval_dtor(&key);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (!php_var_unserialize_internal(data, p, max, var_hash, classes)) {\n\t\t\tzval_dtor(&key);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (UNEXPECTED(Z_ISUNDEF_P(data))) {\n\t\t\tif (Z_TYPE(key) == IS_LONG) {\n\t\t\t\tzend_hash_index_del(ht, Z_LVAL(key));\n\t\t\t} else {\n\t\t\t\tzend_hash_del_ind(ht, Z_STR(key));\n\t\t\t}\n\t\t} else {\n\t\t\tvar_push_dtor(var_hash, data);\n\t\t}\n\n\t\tzval_dtor(&key);\n\n\t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {\n\t\t\t(*p)--;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint flb_gzip_compress(void *in_data, size_t in_len,\n                      void **out_data, size_t *out_len)\n{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n    out_size = in_len + 32;\n    out_buf = flb_malloc(out_size);\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    \n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;\n    strm.opaque    = Z_NULL;\n    strm.next_in   = in_data;\n    strm.avail_in  = in_len;\n    strm.total_out = 0;\n\n    \n    deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                 Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);\n\n    \n    gzip_header(out_buf);\n\n    \n    pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;\n\n    flush = Z_NO_FLUSH;\n    while (1) {\n        strm.next_out  = pb + strm.total_out;\n        strm.avail_out = out_size - (pb - (uint8_t *) out_buf);\n\n        if (strm.avail_in == 0) {\n            flush = Z_FINISH;\n        }\n\n        status = deflate(&strm, flush);\n        if (status == Z_STREAM_END) {\n            break;\n        }\n        else if (status != Z_OK) {\n            deflateEnd(&strm);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&strm) != Z_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n    *out_len = strm.total_out;\n\n    \n    footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;\n    pb = (uint8_t *) out_buf + footer_start;\n\n    crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);\n    *pb++ = crc & 0xFF;\n    *pb++ = (crc >> 8) & 0xFF;\n    *pb++ = (crc >> 16) & 0xFF;\n    *pb++ = (crc >> 24) & 0xFF;\n    *pb++ = in_len & 0xFF;\n    *pb++ = (in_len >> 8) & 0xFF;\n    *pb++ = (in_len >> 16) & 0xFF;\n    *pb++ = (in_len >> 24) & 0xFF;\n\n    \n    *out_len += FLB_GZIP_HEADER_OFFSET + 8;\n    *out_data = out_buf;\n\n    return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast2obj_mod(void* _o)\n{\n    mod_ty o = (mod_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    switch (o->kind) {\n    case Module_kind:\n        result = PyType_GenericNew(Module_type, NULL, NULL);\n        if (!result) goto failed;\n        value = ast2obj_list(o->v.Module.body, ast2obj_stmt);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        value = ast2obj_list(o->v.Module.type_ignores, ast2obj_type_ignore);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_type_ignores, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        break;\n    case Interactive_kind:\n        result = PyType_GenericNew(Interactive_type, NULL, NULL);\n        if (!result) goto failed;\n        value = ast2obj_list(o->v.Interactive.body, ast2obj_stmt);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        break;\n    case Expression_kind:\n        result = PyType_GenericNew(Expression_type, NULL, NULL);\n        if (!result) goto failed;\n        value = ast2obj_expr(o->v.Expression.body);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        break;\n    case FunctionType_kind:\n        result = PyType_GenericNew(FunctionType_type, NULL, NULL);\n        if (!result) goto failed;\n        value = ast2obj_list(o->v.FunctionType.argtypes, ast2obj_expr);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_argtypes, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        value = ast2obj_expr(o->v.FunctionType.returns);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_returns, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        break;\n    case Suite_kind:\n        result = PyType_GenericNew(Suite_type, NULL, NULL);\n        if (!result) goto failed;\n        value = ast2obj_list(o->v.Suite.body, ast2obj_stmt);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        break;\n    }\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nqedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void test_map_big_memory(void)\n{\n    uc_engine *uc;\n\n    OK(uc_open(UC_ARCH_X86, UC_MODE_64, &uc));\n\n    uc_assert_err(UC_ERR_NOMEM,\n                  uc_mem_map(uc, 0x0, 0xfffffffffffff000, UC_PROT_ALL));\n\n    OK(uc_close(uc));\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nobj2ast_alias(PyObject* obj, alias_ty* out, PyArena* arena)\n{\n    PyObject* tmp = NULL;\n    identifier name;\n    identifier asname;\n\n    if (lookup_attr_id(obj, &PyId_name, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL) {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"name\\\" missing from alias\");\n        return 1;\n    }\n    else {\n        int res;\n        res = obj2ast_identifier(tmp, &name, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    if (lookup_attr_id(obj, &PyId_asname, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL || tmp == Py_None) {\n        Py_CLEAR(tmp);\n        asname = NULL;\n    }\n    else {\n        int res;\n        res = obj2ast_identifier(tmp, &asname, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    *out = alias(name, asname, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);\n    return 1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = READ_ONCE(key->flags);\n\tshort state = READ_ONCE(key->state);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\n\t\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\n\t\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\t\n\t\tif (state < 0) {\n\t\t\tctx->result = ERR_PTR(state);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\n\nskipped:\n\treturn ctx->skipped_ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid RemoteFsDevice::serviceRemoved(const QString &name)\n{\n    if (name==details.serviceName && constSambaAvahiProtocol==details.url.scheme()) {\n        sub=tr(\"Not Available\");\n        updateStatus();\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void cmd_parse_lsub (IMAP_DATA* idata, char* s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  BUFFER err, token;\n  ciss_url_t url;\n  IMAP_LIST list;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    \n    cmd_parse_list (idata, s);\n    return;\n  }\n\n  if (!option (OPTIMAPCHECKSUBSCRIBED))\n    return;\n\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list (idata, s);\n  idata->cmddata = NULL;\n  \n  if (!list.name || list.noselect)\n    return;\n\n  dprint (3, (debugfile, \"Subscribing to %s\\n\", list.name));\n\n  strfcpy (buf, \"mailboxes \\\"\", sizeof (buf));\n  mutt_account_tourl (&idata->conn->account, &url);\n  \n  imap_quote_string(errstr, sizeof (errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (!mutt_strcmp (url.user, ImapUser))\n    url.user = NULL;\n  url_ciss_tostring (&url, buf + 11, sizeof (buf) - 10, 0);\n  safe_strcat (buf, sizeof (buf), \"\\\"\");\n  mutt_buffer_init (&token);\n  mutt_buffer_init (&err);\n  err.data = errstr;\n  err.dsize = sizeof (errstr);\n  if (mutt_parse_rc_line (buf, &token, &err))\n    dprint (1, (debugfile, \"Error adding subscribed mailbox: %s\\n\", errstr));\n  FREE (&token.data);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "OS Command Injection"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n{\n\tint a;\n\tint x, y;\n\tint alphaBlendingFlag = 0;\n\tint color;\n\tint width = im->sx;\n\tint height = im->sy;\n\tuint32 *buffer;\n\tuint32 rgba;\n\n\t\n\talphaBlendingFlag = im->alphaBlendingFlag;\n\tgdImageAlphaBlending(im, 0);\n\n\tbuffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);\n\tif (!buffer) {\n\t\treturn GD_FAILURE;\n\t}\n\n\tTIFFReadRGBAImage(tif, width, height, buffer, 0);\n\n\tfor(y = 0; y < height; y++) {\n\t\tfor(x = 0; x < width; x++) {\n\t\t\t\n\t\t\trgba = buffer[(y * width + x)];\n\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n\n\t\t\t\n\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n\t\t}\n\t}\n\n\tgdFree(buffer);\n\n\t\n\tgdImageAlphaBlending(im, alphaBlendingFlag);\n\treturn GD_SUCCESS;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_secondary_order(STREAM s)\n{\n\t\n\tuint16 length;\n\tuint16 flags;\n\tuint8 type;\n\tuint8 *next_order;\n\tstruct stream packet = *s;\n\n\tin_uint16_le(s, length);\n\tin_uint16_le(s, flags);\t\n\tin_uint8(s, type);\n\n\tif (!s_check_rem(s, length + 7))\n\t{\n\t\trdp_protocol_error(\"process_secondary_order(), next order pointer would overrun stream\", &packet);\n\t}\n\n\tnext_order = s->p + (sint16) length + 7;\n\n\tswitch (type)\n\t{\n\t\tcase RDP_ORDER_RAW_BMPCACHE:\n\t\t\tprocess_raw_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_COLCACHE:\n\t\t\tprocess_colcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE:\n\t\t\tprocess_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_FONTCACHE:\n\t\t\tprocess_fontcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_RAW_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, False);\t\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, True);\t\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BRUSHCACHE:\n\t\t\tprocess_brushcache(s, flags);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_secondary_order(), unhandled secondary order %d\", type);\n\t}\n\n\ts->p = next_order;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\t\n\tsnd_timer_stop(timeri);\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\t\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\t\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n\t\t    timer->hw.close)\n\t\t\ttimer->hw.close(timer);\n\t\t\n\t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n\t\t\t\t\t open_list) {\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n\t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n\t\t\tslave->master = NULL;\n\t\t\tslave->timer = NULL;\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t}\n\t\tmutex_unlock(&register_mutex);\n\t}\n out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)\n{\n\tstatic const char module[] = \"PredictorEncodeTile\";\n\tTIFFPredictorState *sp = PredictorState(tif);\n        uint8 *working_copy;\n\ttmsize_t cc = cc0, rowsize;\n\tunsigned char* bp;\n        int result_code;\n\n\tassert(sp != NULL);\n\tassert(sp->encodepfunc != NULL);\n\tassert(sp->encodetile != NULL);\n\n        \n        working_copy = (uint8*) _TIFFmalloc(cc0);\n        if( working_copy == NULL )\n        {\n            TIFFErrorExt(tif->tif_clientdata, module, \n                         \"Out of memory allocating \" TIFF_SSIZE_FORMAT \" byte temp buffer.\",\n                         cc0 );\n            return 0;\n        }\n        memcpy( working_copy, bp0, cc0 );\n        bp = working_copy;\n\n\trowsize = sp->rowsize;\n\tassert(rowsize > 0);\n\tassert((cc0%rowsize)==0);\n\twhile (cc > 0) {\n\t\t(*sp->encodepfunc)(tif, bp, rowsize);\n\t\tcc -= rowsize;\n\t\tbp += rowsize;\n\t}\n\tresult_code = (*sp->encodetile)(tif, working_copy, cc0, s);\n\n        _TIFFfree( working_copy );\n\n        return result_code;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteMfccParams*>(node->user_data);\n\n  const TfLiteTensor* input_wav = GetInput(context, node, kInputTensorWav);\n  const TfLiteTensor* input_rate = GetInput(context, node, kInputTensorRate);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  const int32 sample_rate = *GetTensorData<int>(input_rate);\n\n  const int spectrogram_channels = input_wav->dims->data[2];\n  const int spectrogram_samples = input_wav->dims->data[1];\n  const int audio_channels = input_wav->dims->data[0];\n\n  internal::Mfcc mfcc;\n  mfcc.set_upper_frequency_limit(params->upper_frequency_limit);\n  mfcc.set_lower_frequency_limit(params->lower_frequency_limit);\n  mfcc.set_filterbank_channel_count(params->filterbank_channel_count);\n  mfcc.set_dct_coefficient_count(params->dct_coefficient_count);\n\n  mfcc.Initialize(spectrogram_channels, sample_rate);\n\n  const float* spectrogram_flat = GetTensorData<float>(input_wav);\n  float* output_flat = GetTensorData<float>(output);\n\n  for (int audio_channel = 0; audio_channel < audio_channels; ++audio_channel) {\n    for (int spectrogram_sample = 0; spectrogram_sample < spectrogram_samples;\n         ++spectrogram_sample) {\n      const float* sample_data =\n          spectrogram_flat +\n          (audio_channel * spectrogram_samples * spectrogram_channels) +\n          (spectrogram_sample * spectrogram_channels);\n      std::vector<double> mfcc_input(sample_data,\n                                     sample_data + spectrogram_channels);\n      std::vector<double> mfcc_output;\n      mfcc.Compute(mfcc_input, &mfcc_output);\n      TF_LITE_ENSURE_EQ(context, params->dct_coefficient_count,\n                        mfcc_output.size());\n      float* output_data = output_flat +\n                           (audio_channel * spectrogram_samples *\n                            params->dct_coefficient_count) +\n                           (spectrogram_sample * params->dct_coefficient_count);\n      for (int i = 0; i < params->dct_coefficient_count; ++i) {\n        output_data[i] = mfcc_output[i];\n      }\n    }\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nhandle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg = NULL;\n    int i = start;\n    int j = 0; \n\n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    \n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          ch->n_end_lineno, ch->n_end_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; \n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                \n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    goto error;\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* input,\n                                 const TfLiteTensor* size_splits,\n                                 const TfLiteTensor* axis) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n\n  std::vector<int64_t> size_splits_vector;\n  if (size_splits->type == kTfLiteInt32) {\n    GetSizeSplitsVector<int32_t>(size_splits, &size_splits_vector);\n  } else if (size_splits->type == kTfLiteInt64) {\n    GetSizeSplitsVector<int64_t>(size_splits, &size_splits_vector);\n  } else {\n    context->ReportError(context, \"size_splits only support type int32|int64.\");\n    return kTfLiteError;\n  }\n\n  int minus_one_index = -1;\n  int64_t size_splits_sum = 0;\n\n  for (int i = 0; i < size_splits_vector.size(); ++i) {\n    if (size_splits_vector.at(i) == -1) {\n      if (minus_one_index == -1) {\n        minus_one_index = i;\n      } else {\n        context->ReportError(context,\n                             \"The size_splits contains more than one -1.\");\n      }\n    } else {\n      size_splits_sum += size_splits_vector.at(i);\n    }\n  }\n\n  const int input_size = SizeOfDimension(input, axis_value);\n\n  if (minus_one_index != -1) {\n    if (size_splits_sum > input_size) {\n      context->ReportError(\n          context,\n          \"The sum of size_splits must be less than the dimension of value.\");\n    } else {\n      size_splits_vector[minus_one_index] = input_size - size_splits_sum;\n    }\n  } else if (size_splits_sum != input_size) {\n    context->ReportError(\n        context,\n        \"The size_splits must sum to the dimension of value along axis.\");\n  }\n\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = size_splits_vector.at(i);\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  if (input->type != kTfLiteFloat32) {\n    TF_LITE_UNSUPPORTED_TYPE(context, input->type, \"Ceil\");\n  }\n\n  optimized_ops::Ceil(GetTensorShape(input), GetTensorData<float>(input),\n                      GetTensorShape(output), GetTensorData<float>(output));\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteRegistration AddOpRegistration() {\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n\n  reg.custom_name = \"my_add\";\n  reg.builtin_code = tflite::BuiltinOperator_CUSTOM;\n\n  reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n       const TfLiteTensor* input1;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input1));\n    const TfLiteTensor* input2;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &input2));\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n\n    TF_LITE_ENSURE_EQ(context, input1->dims->size, input2->dims->size);\n    for (int i = 0; i < input1->dims->size; ++i) {\n      TF_LITE_ENSURE_EQ(context, input1->dims->data[i], input2->dims->data[i]);\n    }\n\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(\n        context, output, TfLiteIntArrayCopy(input1->dims)));\n    return kTfLiteOk;\n  };\n\n  reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n       const TfLiteTensor* a0;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &a0));\n    TF_LITE_ENSURE(context, a0);\n    TF_LITE_ENSURE(context, a0->data.f);\n    const TfLiteTensor* a1;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &a1));\n    TF_LITE_ENSURE(context, a1);\n    TF_LITE_ENSURE(context, a1->data.f);\n    TfLiteTensor* out;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &out));\n    TF_LITE_ENSURE(context, out);\n    TF_LITE_ENSURE(context, out->data.f);\n    int num = a0->dims->data[0];\n    for (int i = 0; i < num; i++) {\n      out->data.f[i] = a0->data.f[i] + a1->data.f[i];\n    }\n    return kTfLiteOk;\n  };\n  return reg;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nunsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\n\tif (v8086_mode(regs))\n\t\t\n\t\treturn (unsigned long)(sel << 4);\n\n\tif (user_64bit_mode(regs)) {\n\t\t\n\t\tunsigned long base;\n\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\t\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\n\t\n\tif (!sel)\n\t\treturn -1L;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\n\treturn get_desc_base(desc);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void Compute(OpKernelContext* context) override {\n    const int64 axis_input = context->input(0).scalar<int64>()();\n    const Tensor& input_indices = context->input(1);\n    const Tensor& input_values = context->input(2);\n    const Tensor& input_shape = context->input(3);\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices.shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values.shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_indices.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape.shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape.shape().DebugString()));\n\n    const int64 input_rank = input_shape.vec<int64>().size();\n    const int64 axis = (axis_input < 0) ? input_rank + axis_input : axis_input;\n\n    OP_REQUIRES(\n        context, axis >= 0 && axis < input_rank,\n        errors::InvalidArgument(\"Input axis should be in range [\", -input_rank,\n                                \", \", input_rank, \"), got \", axis_input));\n\n    OP_REQUIRES(context,\n                num_split_ >= 1 && num_split_ <= input_shape.vec<int64>()(axis),\n                errors::InvalidArgument(\"Input num_split should be between 1 \"\n                                        \"and the splitting dimension size (\",\n                                        input_shape.vec<int64>()(axis),\n                                        \"), got \", num_split_));\n\n       TensorShape dense_shape;\n    const auto input_shape_flat = input_shape.flat<int64>();\n    for (int i = 0; i < input_shape.NumElements(); i++) {\n      OP_REQUIRES_OK(context,\n                     dense_shape.AddDimWithStatus(input_shape_flat(i)));\n    }\n\n    sparse::SparseTensor sparse_tensor;\n    OP_REQUIRES_OK(context,\n                   sparse::SparseTensor::Create(input_indices, input_values,\n                                                dense_shape, &sparse_tensor));\n\n    std::vector<sparse::SparseTensor> outputs;\n    OP_REQUIRES_OK(context, sparse::SparseTensor::Split<T>(\n                                sparse_tensor, axis, num_split_, &outputs));\n\n    for (int slice_index = 0; slice_index < num_split_; ++slice_index) {\n      context->set_output(slice_index, outputs[slice_index].indices());\n      context->set_output(slice_index + num_split_,\n                          outputs[slice_index].values());\n      Tensor* shape = nullptr;\n      OP_REQUIRES_OK(context, context->allocate_output(\n                                  slice_index + 2 * num_split_,\n                                  {outputs[slice_index].dims()}, &shape));\n      auto output_shape = outputs[slice_index].shape();\n      for (int dim = 0; dim < outputs[slice_index].dims(); ++dim) {\n        shape->vec<int64>()(dim) = output_shape[dim];\n      }\n    }\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nptaReadStream(FILE  *fp)\n{\nchar       typestr[128];  \nl_int32    i, n, ix, iy, type, version;\nl_float32  x, y;\nPTA       *pta;\n\n    PROCNAME(\"ptaReadStream\");\n\n    if (!fp)\n        return (PTA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if (fscanf(fp, \"\\n Pta Version %d\\n\", &version) != 1)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (version != PTA_VERSION_NUMBER)\n        return (PTA *)ERROR_PTR(\"invalid pta version\", procName, NULL);\n    if (fscanf(fp, \" Number of pts = %d; format = %127s\\n\", &n, typestr) != 2)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (!strcmp(typestr, \"float\"))\n        type = 0;\n    else  \n        type = 1;\n\n    if ((pta = ptaCreate(n)) == NULL)\n        return (PTA *)ERROR_PTR(\"pta not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        if (type == 0) {  \n            if (fscanf(fp, \"   (%f, %f)\\n\", &x, &y) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading floats\", procName, NULL);\n            }\n            ptaAddPt(pta, x, y);\n        } else {   \n            if (fscanf(fp, \"   (%d, %d)\\n\", &ix, &iy) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading ints\", procName, NULL);\n            }\n            ptaAddPt(pta, ix, iy);\n        }\n    }\n\n    return pta;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done_with_cleanup);\n\n    Tensor group_assignment = c->input(2);\n\n    OP_REQUIRES_OK_ASYNC(\n        c,\n        FillCollectiveParams(col_params, group_assignment, REDUCTION_COLLECTIVE,\n                             resource.get()),\n        done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();\n    col_params->final_op = final_op_.get();\n    VLOG(1) << \"CollectiveReduceV3 group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n       Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_secondary_order(STREAM s)\n{\n\t\n\tuint16 length;\n\tuint16 flags;\n\tuint8 type;\n\tuint8 *next_order;\n\tstruct stream packet = *s;\n\n\tin_uint16_le(s, length);\n\tin_uint16_le(s, flags);\t\n\tin_uint8(s, type);\n\n\tif (!s_check_rem(s, length + 7))\n\t{\n\t\trdp_protocol_error(\"process_secondary_order(), next order pointer would overrun stream\", &packet);\n\t}\n\n\tnext_order = s->p + (sint16) length + 7;\n\n\tswitch (type)\n\t{\n\t\tcase RDP_ORDER_RAW_BMPCACHE:\n\t\t\tprocess_raw_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_COLCACHE:\n\t\t\tprocess_colcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE:\n\t\t\tprocess_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_FONTCACHE:\n\t\t\tprocess_fontcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_RAW_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, False);\t\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, True);\t\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BRUSHCACHE:\n\t\t\tprocess_brushcache(s, flags);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_secondary_order(), unhandled secondary order %d\", type);\n\t}\n\n\ts->p = next_order;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus GreaterEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  bool requires_broadcast = !HaveSameShapes(input1, input2);\n  switch (input1->type) {\n    case kTfLiteFloat32:\n      Comparison<float, reference_ops::GreaterFn>(input1, input2, output,\n                                                  requires_broadcast);\n      break;\n    case kTfLiteInt32:\n      Comparison<int32_t, reference_ops::GreaterFn>(input1, input2, output,\n                                                    requires_broadcast);\n      break;\n    case kTfLiteInt64:\n      Comparison<int64_t, reference_ops::GreaterFn>(input1, input2, output,\n                                                    requires_broadcast);\n      break;\n    case kTfLiteUInt8:\n      ComparisonQuantized<uint8_t, reference_ops::GreaterFn>(\n          input1, input2, output, requires_broadcast);\n      break;\n    case kTfLiteInt8:\n      ComparisonQuantized<int8_t, reference_ops::GreaterFn>(\n          input1, input2, output, requires_broadcast);\n      break;\n    default:\n      context->ReportError(context,\n                           \"Does not support type %d, requires float|int|uint8\",\n                           input1->type);\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nhandle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg;\n    int i = start;\n    int j = 0; \n\n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    \n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; \n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                \n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstruct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n{\n\tstruct crypto_alg *alg;\n\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\trequest_module(\"crypto-%s\", name);\n\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"crypto-%s-all\", name);\n\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\n\tif (alg)\n\t\treturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\n\n\treturn crypto_larval_add(name, type, mask);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus NonMaxSuppressionMultiClassRegularHelper(TfLiteContext* context,\n                                                      TfLiteNode* node,\n                                                      OpData* op_data,\n                                                      const float* scores) {\n  const TfLiteTensor* input_box_encodings;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorBoxEncodings,\n                                 &input_box_encodings));\n  const TfLiteTensor* input_class_predictions;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorClassPredictions,\n                                 &input_class_predictions));\n  const TfLiteTensor* decoded_boxes =\n      &context->tensors[op_data->decoded_boxes_index];\n\n  TfLiteTensor* detection_boxes;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorDetectionBoxes,\n                                  &detection_boxes));\n  TfLiteTensor* detection_classes;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorDetectionClasses,\n                                  &detection_classes));\n  TfLiteTensor* detection_scores;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorDetectionScores,\n                                  &detection_scores));\n  TfLiteTensor* num_detections;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorNumDetections,\n                                  &num_detections));\n\n  const int num_boxes = input_box_encodings->dims->data[1];\n  const int num_classes = op_data->num_classes;\n  const int num_detections_per_class = op_data->detections_per_class;\n  const int max_detections = op_data->max_detections;\n  const int num_classes_with_background =\n      input_class_predictions->dims->data[2];\n   int label_offset = num_classes_with_background - num_classes;\n  TF_LITE_ENSURE(context, num_detections_per_class > 0);\n\n   std::vector<float> class_scores(num_boxes);\n\n  std::vector<int> box_indices_after_regular_non_max_suppression(\n      num_boxes + max_detections);\n  std::vector<float> scores_after_regular_non_max_suppression(num_boxes +\n                                                              max_detections);\n\n  int size_of_sorted_indices = 0;\n  std::vector<int> sorted_indices;\n  sorted_indices.resize(num_boxes + max_detections);\n  std::vector<float> sorted_values;\n  sorted_values.resize(max_detections);\n\n  for (int col = 0; col < num_classes; col++) {\n    for (int row = 0; row < num_boxes; row++) {\n           class_scores[row] =\n          *(scores + row * num_classes_with_background + col + label_offset);\n    }\n       std::vector<int> selected;\n    TF_LITE_ENSURE_STATUS(NonMaxSuppressionSingleClassHelper(\n        context, node, op_data, class_scores, &selected,\n        num_detections_per_class));\n       int output_index = size_of_sorted_indices;\n    for (const auto& selected_index : selected) {\n      box_indices_after_regular_non_max_suppression[output_index] =\n          (selected_index * num_classes_with_background + col + label_offset);\n      scores_after_regular_non_max_suppression[output_index] =\n          class_scores[selected_index];\n      output_index++;\n    }\n          int num_indices_to_sort = std::min(output_index, max_detections);\n    DecreasingPartialArgSort(scores_after_regular_non_max_suppression.data(),\n                             output_index, num_indices_to_sort,\n                             sorted_indices.data());\n\n       for (int row = 0; row < num_indices_to_sort; row++) {\n      int temp = sorted_indices[row];\n      sorted_indices[row] = box_indices_after_regular_non_max_suppression[temp];\n      sorted_values[row] = scores_after_regular_non_max_suppression[temp];\n    }\n       for (int row = 0; row < num_indices_to_sort; row++) {\n      box_indices_after_regular_non_max_suppression[row] = sorted_indices[row];\n      scores_after_regular_non_max_suppression[row] = sorted_values[row];\n    }\n    size_of_sorted_indices = num_indices_to_sort;\n  }\n\n   for (int output_box_index = 0; output_box_index < max_detections;\n       output_box_index++) {\n    if (output_box_index < size_of_sorted_indices) {\n      const int anchor_index = floor(\n          box_indices_after_regular_non_max_suppression[output_box_index] /\n          num_classes_with_background);\n      const int class_index =\n          box_indices_after_regular_non_max_suppression[output_box_index] -\n          anchor_index * num_classes_with_background - label_offset;\n      const float selected_score =\n          scores_after_regular_non_max_suppression[output_box_index];\n           ReInterpretTensor<BoxCornerEncoding*>(detection_boxes)[output_box_index] =\n          ReInterpretTensor<const BoxCornerEncoding*>(\n              decoded_boxes)[anchor_index];\n           GetTensorData<float>(detection_classes)[output_box_index] = class_index;\n           GetTensorData<float>(detection_scores)[output_box_index] = selected_score;\n    } else {\n      ReInterpretTensor<BoxCornerEncoding*>(\n          detection_boxes)[output_box_index] = {0.0f, 0.0f, 0.0f, 0.0f};\n           GetTensorData<float>(detection_classes)[output_box_index] = 0.0f;\n           GetTensorData<float>(detection_scores)[output_box_index] = 0.0f;\n    }\n  }\n  GetTensorData<float>(num_detections)[0] = size_of_sorted_indices;\n  box_indices_after_regular_non_max_suppression.clear();\n  scores_after_regular_non_max_suppression.clear();\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsafe_fprintf(FILE *f, const char *fmt, ...)\n{\n\tchar fmtbuff_stack[256]; \n\tchar outbuff[256]; \n\tchar *fmtbuff_heap; \n\tchar *fmtbuff;  \n\tint fmtbuff_length;\n\tint length, n;\n\tva_list ap;\n\tconst char *p;\n\tunsigned i;\n\twchar_t wc;\n\tchar try_wc;\n\n\t\n\tfmtbuff_heap = NULL;\n\tfmtbuff_length = sizeof(fmtbuff_stack);\n\tfmtbuff = fmtbuff_stack;\n\n\t\n\tva_start(ap, fmt);\n\tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);\n\tva_end(ap);\n\n\t\n\twhile (length < 0 || length >= fmtbuff_length) {\n\t\tif (length >= fmtbuff_length)\n\t\t\tfmtbuff_length = length+1;\n\t\telse if (fmtbuff_length < 8192)\n\t\t\tfmtbuff_length *= 2;\n\t\telse if (fmtbuff_length < 1000000)\n\t\t\tfmtbuff_length += fmtbuff_length / 4;\n\t\telse {\n\t\t\tlength = fmtbuff_length;\n\t\t\tfmtbuff_heap[length-1] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\tfree(fmtbuff_heap);\n\t\tfmtbuff_heap = malloc(fmtbuff_length);\n\n\t\t\n\t\tif (fmtbuff_heap != NULL) {\n\t\t\tfmtbuff = fmtbuff_heap;\n\t\t\tva_start(ap, fmt);\n\t\t\tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);\n\t\t\tva_end(ap);\n\t\t} else {\n\t\t\t\n\t\t\tlength = sizeof(fmtbuff_stack) - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\tif (mbtowc(NULL, NULL, 1) == -1) { \n\t\t\n\t\tfree(fmtbuff_heap);\n\t\treturn;\n\t}\n\n\t\n\tp = fmtbuff;\n\ti = 0;\n\ttry_wc = 1;\n\twhile (*p != '\\0') {\n\n\t\t\n\t\tif (try_wc && (n = mbtowc(&wc, p, length)) != -1) {\n\t\t\tlength -= n;\n\t\t\tif (iswprint(wc) && wc != L'\\\\') {\n\t\t\t\t\n\t\t\t\twhile (n-- > 0)\n\t\t\t\t\toutbuff[i++] = *p++;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\twhile (n-- > 0)\n\t\t\t\t\ti += (unsigned)bsdtar_expand_char(\n\t\t\t\t\t    outbuff, i, *p++);\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\ti += (unsigned)bsdtar_expand_char(outbuff, i, *p++);\n\t\t\ttry_wc = 0;\n\t\t}\n\n\t\t\n\t\tif (i > (sizeof(outbuff) - 20)) {\n\t\t\toutbuff[i] = '\\0';\n\t\t\tfprintf(f, \"%s\", outbuff);\n\t\t\ti = 0;\n\t\t}\n\t}\n\toutbuff[i] = '\\0';\n\tfprintf(f, \"%s\", outbuff);\n\n\t\n\tfree(fmtbuff_heap);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nMONGO_EXPORT int bson_append_element( bson *b, const char *name_or_null, const bson_iterator *elem ) {\n    bson_iterator next = *elem;\n    int size;\n\n    bson_iterator_next( &next );\n    size = next.cur - elem->cur;\n\n    if ( name_or_null == NULL ) {\n        if( bson_ensure_space( b, size ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append( b, elem->cur, size );\n    }\n    else {\n        int data_size = size - 2 - strlen( bson_iterator_key( elem ) );\n        bson_append_estart( b, elem->cur[0], name_or_null, data_size );\n        bson_append( b, bson_iterator_value( elem ), data_size );\n    }\n\n    return BSON_OK;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  int length() const {\n    return m_str ? m_str->size() : 0;\n  }\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmcs_recv_connect_response(STREAM mcs_data)\n{\n\tUNUSED(mcs_data);\n\tuint8 result;\n\tuint32 length;\n\tSTREAM s;\n\tstruct stream packet;\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\t\n\tpacket = *s;\n\n\tber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\n\n\tber_parse_header(s, BER_TAG_RESULT, &length);\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);\n\t\treturn False;\n\t}\n\n\tber_parse_header(s, BER_TAG_INTEGER, &length);\n\tin_uint8s(s, length);\t\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\trdp_protocol_error(\"mcs_recv_connect_response(), consume connect id from stream would overrun\", &packet);\n\t}\n\n\tmcs_parse_domain_params(s);\n\n\tber_parse_header(s, BER_TAG_OCTET_STRING, &length);\n\n\tsec_process_mcs_data(s);\n\t\n\treturn s_check_end(s);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid ksz9131DumpPhyReg(NetInterface *interface)\n{\n   uint8_t i;\n\n     for(i = 0; i < 32; i++)\n   {\n           TRACE_DEBUG(\"%02\" PRIu8 \": 0x%04\" PRIX16 \"\\r\\n\", i,\n         ksz9131ReadPhyReg(interface, i));\n   }\n\n     TRACE_DEBUG(\"\\r\\n\");\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint encoded_pixels;\n\tint rle_size;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size <= 0) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\t\t\t\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\n\t\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t\n\t\tpipe_buf_get(ipipe, ibuf);\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\n\t\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int __init sit_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\n\treturn err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n    double width_d;\n    double scale_f_d = 1.0;\n    const double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\n    if (scale_d < 1.0) {\n        width_d = filter_width_d / scale_d;\n        scale_f_d = scale_d;\n    }  else {\n        width_d= filter_width_d;\n    }\n\n    windows_size = 2 * (int)ceil(width_d) + 1;\n    res = _gdContributionsAlloc(line_size, windows_size);\n\n    for (u = 0; u < line_size; u++) {\n        const double dCenter = (double)u / scale_d;\n        \n        register int iLeft = MAX(0, (int)floor (dCenter - width_d));\n        int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n        double dTotalWeight = 0.0;\n\t\tint iSrc;\n\n        res->ContribRow[u].Left = iLeft;\n        res->ContribRow[u].Right = iRight;\n\n        \n        if (iRight - iLeft + 1 > windows_size)  {\n            if (iLeft < ((int)src_size - 1 / 2))  {\n                iLeft++;\n            } else {\n                iRight--;\n            }\n        }\n\n        for (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n            dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n        }\n\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\n        if (dTotalWeight > 0.0) {\n            for (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n                res->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n            }\n        }\n   }\n   return res;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstd::string encodeBase64(const std::string& input) {\n  return Base64::encode(folly::ByteRange(\n                            reinterpret_cast<const uint8_t*>(input.c_str()),\n                            input.length()));\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic ssize_t virtio_net_receive_rcu(NetClientState *nc, const uint8_t *buf,\n                                      size_t size, bool no_rss)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    VirtIONetQueue *q = virtio_net_get_subqueue(nc);\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    VirtQueueElement *elems[VIRTQUEUE_MAX_SIZE];\n    size_t lens[VIRTQUEUE_MAX_SIZE];\n    struct iovec mhdr_sg[VIRTQUEUE_MAX_SIZE];\n    struct virtio_net_hdr_mrg_rxbuf mhdr;\n    unsigned mhdr_cnt = 0;\n    size_t offset, i, guest_offset, j;\n    ssize_t err;\n\n    if (!virtio_net_can_receive(nc)) {\n        return -1;\n    }\n\n    if (!no_rss && n->rss_data.enabled && n->rss_data.enabled_software_rss) {\n        int index = virtio_net_process_rss(nc, buf, size);\n        if (index >= 0) {\n            NetClientState *nc2 = qemu_get_subqueue(n->nic, index);\n            return virtio_net_receive_rcu(nc2, buf, size, true);\n        }\n    }\n\n    \n    if (!virtio_net_has_buffers(q, size + n->guest_hdr_len - n->host_hdr_len)) {\n        return 0;\n    }\n\n    if (!receive_filter(n, buf, size))\n        return size;\n\n    offset = i = 0;\n\n    while (offset < size) {\n        VirtQueueElement *elem;\n        int len, total;\n        const struct iovec *sg;\n\n        total = 0;\n\n        if (i == VIRTQUEUE_MAX_SIZE) {\n            virtio_error(vdev, \"virtio-net unexpected long buffer chain\");\n            err = size;\n            goto err;\n        }\n\n        elem = virtqueue_pop(q->rx_vq, sizeof(VirtQueueElement));\n        if (!elem) {\n            if (i) {\n                virtio_error(vdev, \"virtio-net unexpected empty queue: \"\n                             \"i %zd mergeable %d offset %zd, size %zd, \"\n                             \"guest hdr len %zd, host hdr len %zd \"\n                             \"guest features 0x%\" PRIx64,\n                             i, n->mergeable_rx_bufs, offset, size,\n                             n->guest_hdr_len, n->host_hdr_len,\n                             vdev->guest_features);\n            }\n            err = -1;\n            goto err;\n        }\n\n        if (elem->in_num < 1) {\n            virtio_error(vdev,\n                         \"virtio-net receive queue contains no in buffers\");\n            virtqueue_detach_element(q->rx_vq, elem, 0);\n            g_free(elem);\n            err = -1;\n            goto err;\n        }\n\n        sg = elem->in_sg;\n        if (i == 0) {\n            assert(offset == 0);\n            if (n->mergeable_rx_bufs) {\n                mhdr_cnt = iov_copy(mhdr_sg, ARRAY_SIZE(mhdr_sg),\n                                    sg, elem->in_num,\n                                    offsetof(typeof(mhdr), num_buffers),\n                                    sizeof(mhdr.num_buffers));\n            }\n\n            receive_header(n, sg, elem->in_num, buf, size);\n            if (n->rss_data.populate_hash) {\n                offset = sizeof(mhdr);\n                iov_from_buf(sg, elem->in_num, offset,\n                             buf + offset, n->host_hdr_len - sizeof(mhdr));\n            }\n            offset = n->host_hdr_len;\n            total += n->guest_hdr_len;\n            guest_offset = n->guest_hdr_len;\n        } else {\n            guest_offset = 0;\n        }\n\n        \n        len = iov_from_buf(sg, elem->in_num, guest_offset,\n                           buf + offset, size - offset);\n        total += len;\n        offset += len;\n        \n        if (!n->mergeable_rx_bufs && offset < size) {\n            virtqueue_unpop(q->rx_vq, elem, total);\n            g_free(elem);\n            err = size;\n            goto err;\n        }\n\n        elems[i] = elem;\n        lens[i] = total;\n        i++;\n    }\n\n    if (mhdr_cnt) {\n        virtio_stw_p(vdev, &mhdr.num_buffers, i);\n        iov_from_buf(mhdr_sg, mhdr_cnt,\n                     0,\n                     &mhdr.num_buffers, sizeof mhdr.num_buffers);\n    }\n\n    for (j = 0; j < i; j++) {\n        \n        virtqueue_fill(q->rx_vq, elems[j], lens[j], j);\n        g_free(elems[j]);\n    }\n\n    virtqueue_flush(q->rx_vq, i);\n    virtio_notify(vdev, q->rx_vq);\n\n    return size;\n\nerr:\n    for (j = 0; j < i; j++) {\n        g_free(elems[j]);\n    }\n\n    return err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus SoftmaxEval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteSoftmaxParams*>(node->builtin_data);\n  SoftmaxOpData* data = reinterpret_cast<SoftmaxOpData*>(node->user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      return SoftmaxFloat(context, input, output, params);\n    }\n    case kTfLiteUInt8: {\n      switch (output->type) {\n        case kTfLiteUInt8:\n          return SoftmaxQuantized<uint8_t, uint8_t>(context, input, output,\n                                                    data);\n        case kTfLiteInt16:\n          return SoftmaxQuantized<uint8_t, int16_t>(context, input, output,\n                                                    data);\n        default:\n          TF_LITE_KERNEL_LOG(context,\n                             \"Only uint8_t and int16_t outputs are supported \"\n                             \"with uint8_t inputs currently, got %s.\",\n                             TfLiteTypeGetName(output->type));\n          return kTfLiteError;\n      }\n    }\n    case kTfLiteInt8: {\n      switch (output->type) {\n        case kTfLiteInt8:\n          return SoftmaxQuantized<int8_t, int8_t>(context, input, output, data);\n        case kTfLiteInt16:\n          return SoftmaxQuantized<int8_t, int16_t>(context, input, output,\n                                                   data);\n        default:\n          TF_LITE_KERNEL_LOG(context,\n                             \"Only int8_t and int16_t outputs are supported \"\n                             \"with int8_t inputs currently, got %s.\",\n                             TfLiteTypeGetName(output->type));\n          return kTfLiteError;\n      }\n    }\n    case kTfLiteInt16: {\n      return SoftmaxQuantized<int16_t, int16_t>(context, input, output, data);\n    }\n\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Only float32, uint8_t, Int8_t, Int16_t are supported \"\n                         \"currently, got %s.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void snd_timer_check_master(struct snd_timer_instance *master)\n{\n\tstruct snd_timer_instance *slave, *tmp;\n\n\t\n\tlist_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {\n\t\tif (slave->slave_class == master->slave_class &&\n\t\t    slave->slave_id == master->slave_id) {\n\t\t\tlist_move_tail(&slave->open_list, &master->slave_list_head);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\tspin_lock(&master->timer->lock);\n\t\t\tslave->master = master;\n\t\t\tslave->timer = master->timer;\n\t\t\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\tlist_add_tail(&slave->active_list,\n\t\t\t\t\t      &master->slave_active_head);\n\t\t\tspin_unlock(&master->timer->lock);\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t}\n\t}\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_for_arguments(struct compiling *c, const node *n)\n{\n    \n    int i, j, k, nposargs = 0, nkwonlyargs = 0;\n    int nposdefaults = 0, found_default = 0;\n    asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;\n    arg_ty vararg = NULL, kwarg = NULL;\n    arg_ty arg = NULL;\n    node *ch;\n\n    if (TYPE(n) == parameters) {\n        if (NCH(n) == 2) \n            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);\n        n = CHILD(n, 1);\n    }\n    assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);\n\n    \n    for (i = 0; i < NCH(n); i++) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == STAR) {\n            \n            i++;\n            if (i < NCH(n) && \n                (TYPE(CHILD(n, i)) == tfpdef ||\n                 TYPE(CHILD(n, i)) == vfpdef)) {\n                i++;\n            }\n            break;\n        }\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;\n        if (TYPE(ch) == EQUAL) nposdefaults++;\n    }\n    \n    for ( ; i < NCH(n); ++i) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;\n    }\n    posargs = (nposargs ? _Ta3_asdl_seq_new(nposargs, c->c_arena) : NULL);\n    if (!posargs && nposargs)\n        return NULL;\n    kwonlyargs = (nkwonlyargs ?\n                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwonlyargs && nkwonlyargs)\n        return NULL;\n    posdefaults = (nposdefaults ?\n                    _Ta3_asdl_seq_new(nposdefaults, c->c_arena) : NULL);\n    if (!posdefaults && nposdefaults)\n        return NULL;\n    \n    kwdefaults = (nkwonlyargs ?\n                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwdefaults && nkwonlyargs)\n        return NULL;\n\n    \n    i = 0;\n    j = 0;  \n    k = 0;  \n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case tfpdef:\n            case vfpdef:\n                \n                \n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        return NULL;\n                    assert(posdefaults != NULL);\n                    asdl_seq_SET(posdefaults, j++, expression);\n                    i += 2;\n                    found_default = 1;\n                }\n                else if (found_default) {\n                    ast_error(c, n,\n                             \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                arg = ast_for_arg(c, ch);\n                if (!arg)\n                    return NULL;\n                asdl_seq_SET(posargs, k++, arg);\n                i += 1; \n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case STAR:\n                if (i+1 >= NCH(n) ||\n                    (i+2 == NCH(n) && (TYPE(CHILD(n, i+1)) == COMMA\n                                       || TYPE(CHILD(n, i+1)) == TYPE_COMMENT))) {\n                    ast_error(c, CHILD(n, i),\n                        \"named arguments must follow bare *\");\n                    return NULL;\n                }\n                ch = CHILD(n, i+1);  \n                if (TYPE(ch) == COMMA) {\n                    int res = 0;\n                    i += 2; \n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        ast_error(c, CHILD(n, i),\n                                \"bare * has associated type comment\");\n                        return NULL;\n                    }\n\n                    res = handle_keywordonly_args(c, n, i,\n                                                  kwonlyargs, kwdefaults);\n                    if (res == -1) return NULL;\n                    i = res; \n                }\n                else {\n                    vararg = ast_for_arg(c, ch);\n                    if (!vararg)\n                        return NULL;\n\n                    i += 2; \n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                        i += 1; \n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        vararg->type_comment = NEW_TYPE_COMMENT(CHILD(n, i));\n                        if (!vararg->type_comment)\n                            return NULL;\n                        i += 1;\n                    }\n\n                    if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef\n                                    || TYPE(CHILD(n, i)) == vfpdef)) {\n                        int res = 0;\n                        res = handle_keywordonly_args(c, n, i,\n                                                      kwonlyargs, kwdefaults);\n                        if (res == -1) return NULL;\n                        i = res; \n                    }\n                }\n                break;\n            case DOUBLESTAR:\n                ch = CHILD(n, i+1);  \n                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);\n                kwarg = ast_for_arg(c, ch);\n                if (!kwarg)\n                    return NULL;\n                i += 2; \n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                assert(i);\n\n                if (kwarg)\n                    arg = kwarg;\n\n                \n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    return NULL;\n                i += 1;\n                break;\n            default:\n                PyErr_Format(PyExc_SystemError,\n                             \"unexpected node in varargslist: %d @ %d\",\n                             TYPE(ch), i);\n                return NULL;\n        }\n    }\n    return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid RemoteDevicePropertiesWidget::update(const RemoteFsDevice::Details &d, bool create, bool isConnected)\n{\n    int t=d.isLocalFile() ? Type_File : Type_SshFs;\n    setEnabled(d.isLocalFile() || !isConnected);\n    infoLabel->setVisible(create);\n    orig=d;\n    name->setText(d.name);\n    sshPort->setValue(22);\n\n    connectionNote->setVisible(!d.isLocalFile() && isConnected);\n    sshFolder->setText(QString());\n    sshHost->setText(QString());\n    sshUser->setText(QString());\n    fileFolder->setText(QString());\n\n    switch (t) {\n    case Type_SshFs: {\n        sshFolder->setText(d.url.path());\n        if (0!=d.url.port()) {\n            sshPort->setValue(d.url.port());\n        }\n        sshHost->setText(d.url.host());\n        sshUser->setText(d.url.userName());\n        sshExtra->setText(d.extraOptions);\n        break;\n    }\n    case Type_File:\n        fileFolder->setText(d.url.path());\n        break;\n    }\n\n    name->setEnabled(d.isLocalFile() || !isConnected);\n\n    connect(type, SIGNAL(currentIndexChanged(int)), this, SLOT(setType()));\n    for (int i=1; i<type->count(); ++i) {\n        if (type->itemData(i).toInt()==t) {\n            type->setCurrentIndex(i);\n            stackedWidget->setCurrentIndex(i);\n            break;\n        }\n    }\n    connect(name, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(sshHost, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(sshUser, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(sshFolder, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(sshPort, SIGNAL(valueChanged(int)), this, SLOT(checkSaveable()));\n    connect(sshExtra, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(fileFolder, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    modified=false;\n    setType();\n    checkSaveable();\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus TanhPrepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  if (kernel_type == kFixedPointOptimized) {\n    if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n      static constexpr int kInputIntegerBits = 4;\n\n      const double input_real_multiplier =\n          input->params.scale *\n          static_cast<double>(1 << (15 - kInputIntegerBits));\n\n      const double q =\n          std::frexp(input_real_multiplier, &data->input_left_shift);\n      auto q_fixed = static_cast<int32_t>(TfLiteRound(q * (1ll << 15)));\n      data->input_multiplier = static_cast<int16_t>(q_fixed);\n\n      int16_t input_range_radius =\n          CalculateInputRadius(kInputIntegerBits, data->input_left_shift, 15);\n      data->input_range_radius = input_range_radius;\n    }\n  }\n\n  if (kernel_type == kGenericOptimized || kernel_type == kReference) {\n    if (input->type == kTfLiteUInt8) {\n      PopulateLookupTable<uint8_t>(\n          data, input, output, [](float value) { return std::tanh(value); });\n    } else if (input->type == kTfLiteInt8) {\n      PopulateLookupTable<int8_t>(data, input, output,\n                                  [](float value) { return std::tanh(value); });\n    }\n  }\n\n  if (input->type == kTfLiteInt16) {\n    static constexpr int kInputIntegerBits = 3;\n    static constexpr int kOutputFractionalBits = 15;\n\n                        \n    TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0);\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);\n\n    int input_scale_log2_rounded;\n    bool param_scale_pot =\n        CheckedLog2(input->params.scale, &input_scale_log2_rounded);\n\n    data->input_left_shift =\n        (15 - kInputIntegerBits) + input_scale_log2_rounded;\n    param_scale_pot &=\n        (data->input_left_shift == 0 || data->input_left_shift == 1);\n\n    if (!param_scale_pot) {\n                                    data->input_multiplier = static_cast<int32_t>(input->params.scale * 4096);\n    }\n\n    int output_scale_log2_rounded;\n    TF_LITE_ENSURE(\n        context, CheckedLog2(output->params.scale, &output_scale_log2_rounded));\n    TF_LITE_ENSURE_EQ(context, output_scale_log2_rounded,\n                      -kOutputFractionalBits);\n  }\n\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmark_desktop_file_executable (CommonJob    *common,\n                              GCancellable *cancellable,\n                              GFile        *file,\n                              gboolean      interactive)\n{\n    GError *error;\n    guint32 current_perms, new_perms;\n    int response;\n    GFileInfo *info;\n\nretry:\n\n    error = NULL;\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_UNIX_MODE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              common->cancellable,\n                              &error);\n\n    if (info == NULL)\n    {\n        if (interactive)\n        {\n            response = run_error (common,\n                                  g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                  error->message,\n                                  NULL,\n                                  FALSE,\n                                  CANCEL, RETRY,\n                                  NULL);\n        }\n        else\n        {\n            response = 0;\n        }\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (common);\n        }\n        else if (response == 1)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\n\n    if (g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE))\n    {\n        current_perms = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n        new_perms = current_perms | S_IXGRP | S_IXUSR | S_IXOTH;\n\n        if ((current_perms != new_perms) &&\n            !g_file_set_attribute_uint32 (file, G_FILE_ATTRIBUTE_UNIX_MODE,\n                                          new_perms, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                          common->cancellable, &error))\n        {\n            g_object_unref (info);\n\n            if (interactive)\n            {\n                response = run_error (common,\n                                      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                      error->message,\n                                      NULL,\n                                      FALSE,\n                                      CANCEL, RETRY,\n                                      NULL);\n            }\n            else\n            {\n                response = 0;\n            }\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (common);\n            }\n            else if (response == 1)\n            {\n                goto retry;\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n\n            goto out;\n        }\n    }\n    g_object_unref (info);\nout:\n    ;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ninline bool loadModule(const char* filename, IR::Module& outModule)\n{\n\tstd::vector<U8> fileBytes;\n\tif(!loadFile(filename, fileBytes)) { return false; }\n\n\tif(*(U32*)fileBytes.data() == 0x6d736100)\n\t{ return loadBinaryModule(fileBytes.data(), fileBytes.size(), outModule); }\n\telse\n\t{\n\t\t\tfileBytes.push_back(0);\n\n\t\t\tstd::vector<WAST::Error> parseErrors;\n\t\tif(!WAST::parseModule(\n\t\t\t   (const char*)fileBytes.data(), fileBytes.size(), outModule, parseErrors))\n\t\t{\n\t\t\tLog::printf(Log::error, \"Error parsing WebAssembly text file:\\n\");\n\t\t\treportParseErrors(filename, parseErrors);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const TfLiteType type = input1->type;\n  if (type != kTfLiteInt32 && type != kTfLiteFloat32) {\n    TF_LITE_KERNEL_LOG(context, \"Unsupported data type %s.\",\n                       TfLiteTypeGetName(type));\n    return kTfLiteError;\n  }\n  output->type = type;\n\n  data->requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (data->requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void bt_for_each(struct blk_mq_hw_ctx *hctx,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t\trq = hctx->tags->rqs[off + bit];\n\t\t\tif (rq->q == hctx->queue)\n\t\t\t\tfn(hctx, rq, data, reserved);\n\t\t}\n\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus LessEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  bool requires_broadcast = !HaveSameShapes(input1, input2);\n  switch (input1->type) {\n    case kTfLiteFloat32:\n      Comparison<float, reference_ops::LessFn>(input1, input2, output,\n                                               requires_broadcast);\n      break;\n    case kTfLiteInt32:\n      Comparison<int32_t, reference_ops::LessFn>(input1, input2, output,\n                                                 requires_broadcast);\n      break;\n    case kTfLiteInt64:\n      Comparison<int64_t, reference_ops::LessFn>(input1, input2, output,\n                                                 requires_broadcast);\n      break;\n    case kTfLiteUInt8:\n      ComparisonQuantized<uint8_t, reference_ops::LessFn>(\n          input1, input2, output, requires_broadcast);\n      break;\n    case kTfLiteInt8:\n      ComparisonQuantized<int8_t, reference_ops::LessFn>(input1, input2, output,\n                                                         requires_broadcast);\n      break;\n    default:\n      context->ReportError(context,\n                           \"Does not support type %d, requires float|int|uint8\",\n                           input1->type);\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic Jsi_RC jsi_ArrayFindSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    Jsi_Obj *obj;\n    int curlen;\n    uint i;\n    Jsi_RC rc = JSI_OK;\n    Jsi_Value *func, *vpargs, *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *nthis = NULL;\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    int fval = 0;\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    Jsi_Value *vobjs[3];\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            break;\n        fval = Jsi_ValueIsTrue(interp, nrPtr);\n        Jsi_ValueMakeUndef(interp, &nrPtr);\n        if (op == 3) {\n            if (!fval) break;\n        } else if (fval)\n            break;\n    }\n    if (rc == JSI_OK) {\n        if (op == 1 && fval)            Jsi_ValueCopy(interp, *ret, obj->arr[i]); \n        else if (op == 2 || op == 3)            Jsi_ValueMakeBool(interp, ret, fval);\n        else if (op == 4)\n            Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)(fval?(int)i:-1));\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    Jsi_DecrRefCount(interp, nrPtr);\n    return rc;\n\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int ExecuteSQL( SQLHDBC hDbc, char *szSQL, char cDelimiter, int bColumnNames, int bHTMLTable )\n{\n    SQLHSTMT        hStmt;\n    SQLTCHAR        szSepLine[32001];   \n    SQLTCHAR        szUcSQL[32001]; \n    SQLSMALLINT     cols;\n    SQLINTEGER      ret;\n    SQLLEN          nRows                   = 0;\n\n    szSepLine[ 0 ] = 0;\n\n    ansi_to_unicode( szSQL, szUcSQL );\n\n    \n    if ( SQLAllocStmt( hDbc, &hStmt ) != SQL_SUCCESS )\n    {\n        if ( bVerbose ) DumpODBCLog( hEnv, hDbc, 0 );\n        fprintf( stderr, \"[ISQL]ERROR: Could not SQLAllocStmt\\n\" );\n        return 0;\n    }\n\n    if ( buseED ) {\n        ret = SQLExecDirect( hStmt, szUcSQL, SQL_NTS );\n\n        if ( ret == SQL_NO_DATA )\n        {\n            fprintf( stderr, \"[ISQL]INFO: SQLExecDirect returned SQL_NO_DATA\\n\" );\n        }\n        else if ( ret == SQL_SUCCESS_WITH_INFO )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]INFO: SQLExecDirect returned SQL_SUCCESS_WITH_INFO\\n\" );\n        }\n        else if ( ret != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLExecDirect\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            free(szSepLine);\n            return 0;\n        }\n    }\n    else {\n        if ( SQLPrepare( hStmt, szUcSQL, SQL_NTS ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLPrepare\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    \n        ret =  SQLExecute( hStmt );\n    \n        if ( ret == SQL_NO_DATA )\n        {\n            fprintf( stderr, \"[ISQL]INFO: SQLExecute returned SQL_NO_DATA\\n\" );\n        }\n        else if ( ret == SQL_SUCCESS_WITH_INFO )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]INFO: SQLExecute returned SQL_SUCCESS_WITH_INFO\\n\" );\n        }\n        else if ( ret != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLExecute\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    }\n\n    do \n    {\n        \n\n        if ( SQLNumResultCols( hStmt, &cols ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLNumResultCols\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n\n        if ( cols > 0 )\n        {\n            \n            if ( bHTMLTable )\n                WriteHeaderHTMLTable( hStmt );\n            else if ( cDelimiter == 0 )\n                UWriteHeaderNormal( hStmt, szSepLine );\n            else if ( cDelimiter && bColumnNames )\n                WriteHeaderDelimited( hStmt, cDelimiter );\n\n            \n            if ( bHTMLTable )\n                WriteBodyHTMLTable( hStmt );\n            else if ( cDelimiter == 0 )\n                nRows = WriteBodyNormal( hStmt );\n            else\n                WriteBodyDelimited( hStmt, cDelimiter );\n        }\n\n        \n        if ( bHTMLTable )\n            WriteFooterHTMLTable( hStmt );\n        else if ( cDelimiter == 0 )\n            UWriteFooterNormal( hStmt, szSepLine, nRows );\n    }\n    while ( SQL_SUCCEEDED( SQLMoreResults( hStmt )));\n\n    \n    SQLFreeStmt( hStmt, SQL_DROP );\n\n    return 1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nex_function(exarg_T *eap)\n{\n    (void)define_function(eap, NULL);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nforward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n\t\t     UChar* range, UChar** low, UChar** high, UChar** low_prev)\n{\n  UChar *p, *pprev = (UChar* )NULL;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\n\",\n\t  (int )str, (int )end, (int )s, (int )range);\n#endif\n\n  p = s;\n  if (reg->dmin > 0) {\n    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {\n      p += reg->dmin;\n    }\n    else {\n      UChar *q = p + reg->dmin;\n\n      if (q >= end) return 0; \n      while (p < q) p += enclen(reg->enc, p);\n    }\n  }\n\n retry:\n  switch (reg->optimize) {\n  case ONIG_OPTIMIZE_EXACT:\n    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);\n    break;\n  case ONIG_OPTIMIZE_EXACT_IC:\n    p = slow_search_ic(reg->enc, reg->case_fold_flag,\n                       reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM:\n    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:\n    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_MAP:\n    p = map_search(reg->enc, reg->map, p, range);\n    break;\n  }\n\n  if (p && p < range) {\n    if (p - reg->dmin < s) {\n    retry_gate:\n      pprev = p;\n      p += enclen(reg->enc, p);\n      goto retry;\n    }\n\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCHOR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc,\n                                            (pprev ? pprev : str), p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n        }\n        break;\n\n      case ANCHOR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), p);\n          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 )\n          goto retry_gate;\n        break;\n      }\n    }\n\n    if (reg->dmax == 0) {\n      *low = p;\n      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        *low = p - reg->dmax;\n        if (*low > s) {\n          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                          *low, (const UChar** )low_prev);\n          if (low_prev && IS_NULL(*low_prev))\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : s), *low);\n        }\n        else {\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : str), *low);\n        }\n      }\n    }\n    \n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);\n#endif\n    return 1; \n  }\n\n  return 0; \n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n\n\tmscfs_check_cache(priv->fs);\n\n\tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid= fs->cache.array[x].objectId.id;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n\t\t\tbuf[1] = oid[3];\n\t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; \n\t\t\tbuf += 2;\n\t\t\tcount+=2;\n\t\t}\n\t}\n\treturn count;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\treturn -ENOSYS;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug(\"Sending CC\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint32_t enc_len) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_poly);\n\n    memset(getThreadLocalDecryptedDkgPoly(), 0, DKG_BUFER_LENGTH);\n\n    int status = AES_decrypt(encrypted_poly, enc_len, (char *) getThreadLocalDecryptedDkgPoly(),\n                             DKG_BUFER_LENGTH);\n\n    CHECK_STATUS2(\"sgx_unseal_data - encrypted_poly failed with status %d\")\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nconst char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrncat(line, buf, sizeof line);\n\t\tstrncat(line, \" \", sizeof line);\n\t\te = e->next;\n\t}\n\tline[(sizeof line)-1] = '\\0'; \n\tline[strlen(line)-1] = 0; \n\treturn line;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tcomplete(&task->slow_task->completion);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint my_csr_reader( const char*           i_csr_file_in,\n                    unsigned int**        o_row_idx,\n                    unsigned int**        o_column_idx,\n                    REALTYPE**            o_values,\n                    unsigned int*         o_row_count,\n                    unsigned int*         o_column_count,\n                    unsigned int*         o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return -1;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return -1;\n    }\n    \n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      \n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          \n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n          *o_values = (REALTYPE*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          \n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return -1;\n          }\n\n          \n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\n\n          \n          for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          \n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return -1;\n        }\n      \n      } else {\n        unsigned int l_row, l_column;\n        REALTYPE l_value;\n        \n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return -1;\n        }\n        \n        l_row--;\n        l_column--;\n        \n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        \n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  \n  fclose( l_csr_file_handle );\n\n  \n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return -1;\n  }\n\n  \n  for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n    if ( l_row_idx_id[l_i] == 0 ) {\n      (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n    }\n  }\n\n  \n  if ( l_row_idx_id != NULL ) {\n    free( l_row_idx_id );\n  }\n  return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (sec_attr == NULL || sec_attr_len) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint gdTransformAffineCopy(gdImagePtr dst,\n\t\t  int dst_x, int dst_y,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_region,\n\t\t  const double affine[6])\n{\n\tint c1x,c1y,c2x,c2y;\n\tint backclip = 0;\n\tint backup_clipx1, backup_clipy1, backup_clipx2, backup_clipy2;\n\tregister int x, y, src_offset_x, src_offset_y;\n\tdouble inv[6];\n\tint *dst_p;\n\tgdPointF pt, src_pt;\n\tgdRect bbox;\n\tint end_x, end_y;\n\tgdInterpolationMethod interpolation_id_bak = GD_DEFAULT;\n\tinterpolation_method interpolation_bak;\n\n\t\n\tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\tinterpolation_id_bak = src->interpolation_id;\n\t\tinterpolation_bak = src->interpolation;\n\t\t\n\t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\n\t}\n\n\n\tgdImageClipRectangle(src, src_region);\n\n\tif (src_region->x > 0 || src_region->y > 0\n\t\t|| src_region->width < gdImageSX(src)\n\t\t|| src_region->height < gdImageSY(src)) {\n\t\tbackclip = 1;\n\n\t\tgdImageGetClip(src, &backup_clipx1, &backup_clipy1,\n\t\t&backup_clipx2, &backup_clipy2);\n\n\t\tgdImageSetClip(src, src_region->x, src_region->y,\n\t\t\tsrc_region->x + src_region->width - 1,\n\t\t\tsrc_region->y + src_region->height - 1);\n\t}\n\n\tif (!gdTransformAffineBoundingBox(src_region, affine, &bbox)) {\n\t\tif (backclip) {\n\t\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\t\tbackup_clipx2, backup_clipy2);\n\t\t}\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\t\treturn GD_FALSE;\n\t}\n\n\tgdImageGetClip(dst, &c1x, &c1y, &c2x, &c2y);\n\n\tend_x = bbox.width  + (int) fabs(bbox.x);\n\tend_y = bbox.height + (int) fabs(bbox.y);\n\n\t\n\tgdAffineInvert(inv, affine);\n\n\tsrc_offset_x =  src_region->x;\n\tsrc_offset_y =  src_region->y;\n\n\tif (dst->alphaBlendingFlag) {\n\t\tfor (y = bbox.y; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5;\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\t\t\t\tgdImageSetPixel(dst, dst_x + x, dst_y + y, getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, 0));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (y = 0; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5 + bbox.y;\n\t\t\tif ((dst_y + y) < 0 || ((dst_y + y) > gdImageSY(dst) -1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdst_p = dst->tpixels[dst_y + y] + dst_x;\n\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5 + bbox.x;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\n\t\t\t\tif ((dst_x + x) < 0 || (dst_x + x) > (gdImageSX(dst) - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*(dst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tif (backclip) {\n\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\tbackup_clipx2, backup_clipy2);\n\t}\n\n\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\treturn GD_TRUE;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nGF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8)-1) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\n\t\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;\n\t\tswitch (mode) {\n\t\tcase PSR_AA32_MODE_USR:\n\t\tcase PSR_AA32_MODE_FIQ:\n\t\tcase PSR_AA32_MODE_IRQ:\n\t\tcase PSR_AA32_MODE_SVC:\n\t\tcase PSR_AA32_MODE_ABT:\n\t\tcase PSR_AA32_MODE_UND:\n\t\tcase PSR_MODE_EL0t:\n\t\tcase PSR_MODE_EL1t:\n\t\tcase PSR_MODE_EL1h:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int ext4_dax_pfn_mkwrite(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tint ret = VM_FAULT_NOPAGE;\n\tloff_t size;\n\n\tsb_start_pagefault(sb);\n\tfile_update_time(vma->vm_file);\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size)\n\t\tret = VM_FAULT_SIGBUS;\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\tsb_end_pagefault(sb);\n\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid handle_debug_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        msg_read_tiny(msg, len);\n    } else {\n        usb_rx_helper(msg, len, DEBUG_MSG);\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_MSB,op_LSB;\n\tint ret;\n\tif (!data)\n\t\treturn 0;\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top->addr = addr;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\n\top->size = 2;\n\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteUnpackParams* data =\n      reinterpret_cast<TfLiteUnpackParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      UnpackImpl<float>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteInt32: {\n      UnpackImpl<int32_t>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteUInt8: {\n      UnpackImpl<uint8_t>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteInt8: {\n      UnpackImpl<int8_t>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteBool: {\n      UnpackImpl<bool>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteInt16: {\n      UnpackImpl<int16_t>(context, node, input, data->num, data->axis);\n      break;\n    }\n    default: {\n      context->ReportError(context, \"Type '%s' is not supported by unpack.\",\n                           TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n    }\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,\n                       const unsigned char *hash,     unsigned long hashlen,\n                             int            padding,\n                             int            hash_idx, unsigned long saltlen,\n                             int           *stat,     rsa_key      *key)\n{\n  unsigned long modulus_bitlen, modulus_bytelen, x;\n  int           err;\n  unsigned char *tmpbuf;\n\n  LTC_ARGCHK(hash  != NULL);\n  LTC_ARGCHK(sig   != NULL);\n  LTC_ARGCHK(stat  != NULL);\n  LTC_ARGCHK(key   != NULL);\n\n  \n  *stat = 0;\n\n  \n\n  if ((padding != LTC_PKCS_1_V1_5) &&\n      (padding != LTC_PKCS_1_PSS)) {\n    return CRYPT_PK_INVALID_PADDING;\n  }\n\n  if (padding == LTC_PKCS_1_PSS) {\n    \n    if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {\n       return err;\n    }\n  }\n\n  \n  modulus_bitlen = mp_count_bits( (key->N));\n\n  \n  modulus_bytelen = mp_unsigned_bin_size( (key->N));\n  if (modulus_bytelen != siglen) {\n     return CRYPT_INVALID_PACKET;\n  }\n\n  \n  tmpbuf = XMALLOC(siglen);\n  if (tmpbuf == NULL) {\n     return CRYPT_MEM;\n  }\n\n  \n  x = siglen;\n  if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {\n     XFREE(tmpbuf);\n     return err;\n  }\n\n  \n  if (x != siglen) {\n     XFREE(tmpbuf);\n     return CRYPT_INVALID_PACKET;\n  }\n\n  if (padding == LTC_PKCS_1_PSS) {\n    \n\n    if(modulus_bitlen%8 == 1){\n      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf+1, x-1, saltlen, hash_idx, modulus_bitlen, stat);\n    }\n    else{\n      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);\n    }\n\n  } else {\n    \n    unsigned char *out;\n    unsigned long outlen, loid[16];\n    int           decoded;\n    ltc_asn1_list digestinfo[2], siginfo[2];\n\n    \n    if (hash_descriptor[hash_idx].OIDlen == 0) {\n       err = CRYPT_INVALID_ARG;\n       goto bail_2;\n    }\n\n    \n    outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;\n    out    = XMALLOC(outlen);\n    if (out == NULL) {\n      err = CRYPT_MEM;\n      goto bail_2;\n    }\n\n    if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) {\n      XFREE(out);\n      goto bail_2;\n    }\n\n    \n    \n    LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));\n    LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);\n    LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);\n    LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);\n\n    if ((err = der_decode_sequence(out, outlen, siginfo, 2)) != CRYPT_OK) {\n       XFREE(out);\n       goto bail_2;\n    }\n\n    \n    if ((digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&\n        (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&\n        (siginfo[1].size == hashlen) &&\n        (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {\n       *stat = 1;\n    }\n\n#ifdef LTC_CLEAN_STACK\n    zeromem(out, outlen);\n#endif\n    XFREE(out);\n  }\n\nbail_2:\n#ifdef LTC_CLEAN_STACK\n  zeromem(tmpbuf, siglen);\n#endif\n  XFREE(tmpbuf);\n  return err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t len;\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        len = r->sector_count * 512;\n        if (len > SCSI_DMA_BUF_SIZE) {\n            len = SCSI_DMA_BUF_SIZE;\n        }\n        r->iov.iov_len = len;\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, len);\n        scsi_req_data(&r->req, len);\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t     struct file *out, loff_t *ppos,\n\t\t\t\t     size_t len, unsigned int flags)\n{\n\tunsigned nbuf;\n\tunsigned idx;\n\tstruct pipe_buffer *bufs;\n\tstruct fuse_copy_state cs;\n\tstruct fuse_dev *fud;\n\tsize_t rem;\n\tssize_t ret;\n\n\tfud = fuse_get_dev(out);\n\tif (!fud)\n\t\treturn -EPERM;\n\n\tpipe_lock(pipe);\n\n\tbufs = kvmalloc_array(pipe->nrbufs, sizeof(struct pipe_buffer),\n\t\t\t      GFP_KERNEL);\n\tif (!bufs) {\n\t\tpipe_unlock(pipe);\n\t\treturn -ENOMEM;\n\t}\n\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\n\tret = -EINVAL;\n\tif (rem < len) {\n\t\tpipe_unlock(pipe);\n\t\tgoto out;\n\t}\n\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tpipe_buf_get(pipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\n\tfuse_copy_init(&cs, 0, NULL);\n\tcs.pipebufs = bufs;\n\tcs.nr_segs = nbuf;\n\tcs.pipe = pipe;\n\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\n\tret = fuse_dev_do_write(fud, &cs, len);\n\n\tpipe_lock(pipe);\n\tfor (idx = 0; idx < nbuf; idx++)\n\t\tpipe_buf_release(pipe, &bufs[idx]);\n\tpipe_unlock(pipe);\n\nout:\n\tkvfree(bufs);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid dhcpClientProcessMessage(NetInterface *interface,\n   const IpPseudoHeader *pseudoHeader, const UdpHeader *udpHeader,\n   const NetBuffer *buffer, size_t offset, const NetRxAncillary *ancillary,\n   void *param)\n{\n   size_t length;\n   DhcpClientContext *context;\n   DhcpMessage *message;\n   DhcpOption *option;\n\n     context = (DhcpClientContext *) param;\n\n     length = netBufferGetLength(buffer) - offset;\n\n     if(length < sizeof(DhcpMessage))\n      return;\n   if(length > DHCP_MAX_MSG_SIZE)\n      return;\n\n     message = netBufferAt(buffer, offset);\n     if(message == NULL)\n      return;\n\n     TRACE_DEBUG(\"\\r\\n%s: DHCP message received (%\" PRIuSIZE \" bytes)...\\r\\n\",\n      formatSystemTime(osGetSystemTime(), NULL), length);\n\n     dhcpDumpMessage(message, length);\n\n     if(message->op != DHCP_OPCODE_BOOTREPLY)\n      return;\n     if(message->htype != DHCP_HARDWARE_TYPE_ETH)\n      return;\n     if(message->hlen != sizeof(MacAddr))\n      return;\n     if(message->magicCookie != HTONL(DHCP_MAGIC_COOKIE))\n      return;\n\n     option = dhcpGetOption(message, length, DHCP_OPT_DHCP_MESSAGE_TYPE);\n\n     if(option == NULL || option->length != 1)\n      return;\n\n     switch(option->value[0])\n   {\n   case DHCP_MESSAGE_TYPE_OFFER:\n           dhcpClientParseOffer(context, message, length);\n      break;\n   case DHCP_MESSAGE_TYPE_ACK:\n           dhcpClientParseAck(context, message, length);\n      break;\n   case DHCP_MESSAGE_TYPE_NAK:\n           dhcpClientParseNak(context, message, length);\n      break;\n   default:\n           break;\n   }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t\n\tint leftLimit = -1, rightLimit;\n\tint i, restoreAlphaBlending = 0;\n\n\tif (border < 0) {\n\t\t\n\t\treturn;\n\t}\n\n\tif (!im->trueColor) {\n\t\tif ((color > (im->colorsTotal - 1)) || (border > (im->colorsTotal - 1)) || (color < 0)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\trestoreAlphaBlending = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\n\tfor (i = x; i >= 0; i--) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == -1) {\n\t\tim->alphaBlendingFlag = restoreAlphaBlending;\n\t\treturn;\n\t}\n\t\n\trightLimit = x;\n\tfor (i = (x + 1); i < im->sx; i++) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t\n\t\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y + 1);\n\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBlending;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nisakmp_rfc3948_print(netdissect_options *ndo,\n\t\t     const u_char *bp, u_int length,\n\t\t     const u_char *bp2)\n{\n\tND_TCHECK(bp[0]);\n\tif(length == 1 && bp[0]==0xff) {\n\t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n\t\treturn;\n\t}\n\n\tif(length < 4) {\n\t\tgoto trunc;\n\t}\n\tND_TCHECK(bp[3]);\n\n\t\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\n\t\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\n\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n\t\tsk->sk_state = BT_CONFIG;\n\t\tmsg->msg_namelen = 0;\n\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic BOOL ntlm_av_pair_check(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\treturn ntlm_av_pair_check_data(pAvPair, cbAvPair, 0);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  auto* params = reinterpret_cast<TfLiteShapeParams*>(node->builtin_data);\n  switch (params->out_type) {\n    case kTfLiteInt32:\n      output->type = kTfLiteInt32;\n      break;\n    case kTfLiteInt64:\n      output->type = kTfLiteInt64;\n      break;\n    default:\n      context->ReportError(context, \"Unknown shape output data type: %d\",\n                           params->out_type);\n      return kTfLiteError;\n  }\n\n     SetTensorToPersistentRo(output);\n\n    TfLiteIntArray* output_size = TfLiteIntArrayCreate(1);\n  output_size->data[0] = NumDimensions(input);\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_size));\n\n  TFLITE_DCHECK_EQ(NumDimensions(output), 1);\n  TFLITE_DCHECK_EQ(SizeOfDimension(output, 0), NumDimensions(input));\n\n    switch (output->type) {\n    case kTfLiteInt32:\n      ExtractShape(input, GetTensorData<int32_t>(output));\n      break;\n    case kTfLiteInt64:\n      ExtractShape(input, GetTensorData<int64_t>(output));\n      break;\n    default:\n      return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* axis;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kAxis, &axis));\n   TF_LITE_ENSURE_EQ(context, NumElements(axis), 1);\n   TF_LITE_ENSURE(context,\n                 axis->type == kTfLiteInt32 || axis->type == kTfLiteInt64);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  auto* params = reinterpret_cast<TfLiteArgMaxParams*>(node->builtin_data);\n  switch (params->output_type) {\n    case kTfLiteInt32:\n      output->type = kTfLiteInt32;\n      break;\n    case kTfLiteInt64:\n      output->type = kTfLiteInt64;\n      break;\n    default:\n      context->ReportError(context, \"Unknown index output data type: %d\",\n                           params->output_type);\n      return kTfLiteError;\n  }\n\n   switch (input->type) {\n    case kTfLiteFloat32:\n    case kTfLiteUInt8:\n    case kTfLiteInt8:\n    case kTfLiteInt32:\n      break;\n\n    default:\n      context->ReportError(\n          context,\n          \"Unknown input type: %d, only float32 and int types are supported\",\n          input->type);\n      return kTfLiteError;\n  }\n\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n\n  if (IsConstantTensor(axis)) {\n    TF_LITE_ENSURE_STATUS(ResizeOutput(context, input, axis, output));\n  } else {\n    SetTensorToDynamic(output);\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint main(int argc, char *argv[])\n{\n    int option;\n    int passlen=0;\n    FILE *outfp = NULL;\n    char outfile[1024];\n    unsigned char pass[MAX_PASSWD_BUF];\n    int file_count = 0;\n    unsigned char bom[2];\n    int password_acquired = 0;\n\n    while ((option = getopt(argc, argv, \"vhg:p:o:\")) != -1)\n    {\n        switch (option)\n        {\n            case 'h':\n                usage(argv[0]);\n                return 0;\n            case 'v':\n                version(argv[0]);\n                return 0;\n            case 'g':\n                if (password_acquired)\n                {\n                    fprintf(stderr, \"Error: password supplied twice\\n\");\n                    return -1;\n                }\n                if (optarg != 0)\n                {\n                    passlen = generate_password(atoi((char*) optarg),\n                                                pass);\n                    if (passlen < 0)\n                    {\n                        return -1;\n                    }\n                }\n                password_acquired = 1;\n                break;\n            case 'p':\n                if (password_acquired)\n                {\n                    fprintf(stderr, \"Error: password supplied twice\\n\");\n                    return -1;\n                }\n                if (optarg != 0)\n                {\n                    passlen = passwd_to_utf16((unsigned char *) optarg,\n                                              strlen((char *) optarg),\n                                              MAX_PASSWD_LEN,\n                                              pass);\n                    if (passlen < 0)\n                    {\n                        return -1;\n                    }\n                }\n                password_acquired = 1;\n                break;\n            default:\n                fprintf(stderr, \"Error: Unknown option '%c'\\n\", option);\n                return -1;\n        }\n    }\n\n    file_count = argc - optind;\n    if (file_count != 1)\n    {\n        fprintf(stderr, \"Error: A single output file must be specified.\\n\");\n        usage(argv[0]);\n        \n        memset_secure(pass, 0, MAX_PASSWD_BUF);\n        return -1;\n    }\n    else\n    {\n        \n        strncpy(outfile, argv[optind++], 1024);\n        outfile[1023] = '\\0';\n    }\n\n    \n    if (passlen == 0)\n    {\n        passlen = read_password(pass, ENC);\n\n        switch (passlen)\n        {\n            case 0: \n                fprintf(stderr, \"Error: No password supplied.\\n\");\n                return -1;\n            case AESCRYPT_READPWD_FOPEN:\n            case AESCRYPT_READPWD_FILENO:\n            case AESCRYPT_READPWD_TCGETATTR:\n            case AESCRYPT_READPWD_TCSETATTR:\n            case AESCRYPT_READPWD_FGETC:\n            case AESCRYPT_READPWD_TOOLONG:\n            case AESCRYPT_READPWD_ICONV:\n                fprintf(stderr, \"Error in read_password: %s.\\n\",\n                        read_password_error(passlen));\n                return -1;\n            case AESCRYPT_READPWD_NOMATCH:\n                fprintf(stderr, \"Error: Passwords don't match.\\n\");\n                return -1;\n        }\n    }\n\n    if(!strcmp(\"-\", outfile))\n    {\n        outfp = stdout;\n    }\n    else if ((outfp = fopen(outfile, \"w\")) == NULL)\n    {\n        fprintf(stderr, \"Error opening output file %s : \", outfile);\n        perror(\"\");\n        \n        memset_secure(pass, 0, MAX_PASSWD_BUF);\n        return  -1;\n    }\n\n    \n    bom[0] = 0xFF;\n    bom[1] = 0xFE;\n    if (fwrite(bom, 1, 2, outfp) != 2)\n    {\n        fprintf(stderr, \"Error: Could not write BOM to password file.\\n\");\n        if (strcmp(\"-\",outfile))\n        {\n            fclose(outfp);\n        }\n        cleanup(outfile);\n        return  -1;\n    }\n\n    if (fwrite(pass, 1, passlen, outfp) != (size_t) passlen)\n    {\n        fprintf(stderr, \"Error: Could not write password file.\\n\");\n        if (strcmp(\"-\",outfile))\n        {\n            fclose(outfp);\n        }\n        cleanup(outfile);\n        return  -1;\n    }\n\n    \n    if (strcmp(\"-\",outfile))\n    {\n        fclose(outfp);\n    }\n\n    \n    memset_secure(pass, 0, MAX_PASSWD_BUF);\n\n    return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nreceive_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+test carbon from recipient\"));\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* begin = GetInput(context, node, kBeginTensor);\n  const TfLiteTensor* size = GetInput(context, node, kSizeTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputShape(context, input, begin, size, output));\n  }\n\n  std::vector<int> begins;\n  begins.reserve(kMaxDim);\n  std::vector<int> sizes;\n  sizes.reserve(kMaxDim);\n\n  for (int i = NumDimensions(input); i < kMaxDim; ++i) {\n    begins.push_back(0);\n    sizes.push_back(1);\n  }\n\n  if (begin->type == kTfLiteInt32) {\n    GetBeginAndSizeVectors<int32_t>(NumDimensions(input), begin, size, &begins,\n                                    &sizes);\n  } else if (begin->type == kTfLiteInt64) {\n    GetBeginAndSizeVectors<int64_t>(NumDimensions(input), begin, size, &begins,\n                                    &sizes);\n  } else {\n    context->ReportError(\n        context, \"Type %d is currently not supported by Slice.\", begin->type);\n    return kTfLiteError;\n  }\n\n      #define TF_LITE_SLICE(data_type, kernel_type)                                  \\\n  {                                                                            \\\n    TF_LITE_ENSURE_EQ(context, begins.size(), 4);                              \\\n    TF_LITE_ENSURE_EQ(context, sizes.size(), 4);                               \\\n    tflite::SliceParams op_params;                                             \\\n    op_params.begin_count = 4;                                                 \\\n    op_params.size_count = 4;                                                  \\\n    for (int i = 0; i < 4; ++i) {                                              \\\n      op_params.begin[i] = begins[i];                                          \\\n      op_params.size[i] = sizes[i];                                            \\\n    }                                                                          \\\n                                                                               \\\n    if (kernel_type == kGenericOptimized) {                                    \\\n      optimized_ops::Slice<data_type>(op_params, GetTensorShape(input), input, \\\n                                      GetTensorShape(output), output);         \\\n    } else {                                                                   \\\n      reference_ops::Slice<data_type>(op_params, GetTensorShape(input), input, \\\n                                      GetTensorShape(output), output);         \\\n    }                                                                          \\\n  }\n\n  switch (input->type) {\n    case kTfLiteFloat32:\n      TF_LITE_SLICE(float, kernel_type);\n      break;\n    case kTfLiteInt32:\n      TF_LITE_SLICE(int32_t, kernel_type);\n      break;\n    case kTfLiteInt64:\n      TF_LITE_SLICE(int64_t, kernel_type);\n      break;\n    case kTfLiteInt8:\n      TF_LITE_SLICE(int8_t, kernel_type);\n      break;\n    case kTfLiteInt16:\n      TF_LITE_SLICE(int16_t, kernel_type);\n      break;\n    case kTfLiteUInt8:\n      TF_LITE_SLICE(uint8_t, kernel_type);\n      break;\n    case kTfLiteBool:\n      TF_LITE_SLICE(bool, kernel_type);\n      break;\n    case kTfLiteString:\n      TF_LITE_SLICE(string, kernel_type);\n      break;\n    default:\n      context->ReportError(\n          context, \"Type %d is currently not supported by Slice.\", input->type);\n      return kTfLiteError;\n  }\n#undef TF_LITE_SLICE\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint addrconf_sysctl_mtu(struct ctl_table *ctl, int write,\n\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct inet6_dev *idev = ctl->extra1;\n\tint min_mtu = IPV6_MIN_MTU;\n\tstruct ctl_table lctl;\n\n\tlctl = *ctl;\n\tlctl.extra1 = &min_mtu;\n\tlctl.extra2 = idev ? &idev->dev->mtu : NULL;\n\n\treturn proc_dointvec_minmax(&lctl, write, buffer, lenp, ppos);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nStatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n\n    *t = op_def.output_arg(i).experimental_full_type();\n\n                                  for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n\n        arg->clear_s();\n      }\n    }\n  }\n\n  return ft;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    if(lzx->inbuf)\n        sys->free(lzx->inbuf);\n    if(lzx->window)\n        sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\t\tlength = cap->bLength;\n\n\t\tif (total_len < length)\n\t\t\tbreak;\n\t\ttotal_len -= length;\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\t\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ngrowable_int_array_deallocate(growable_int_array *arr) {\n    free(arr->items);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n\t\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\t\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\t\tm = numrows - hstartcol;\n\n\t\t\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\n\t\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nforbidden_name(struct compiling *c, identifier name, const node *n,\n               int full_checks)\n{\n    assert(PyUnicode_Check(name));\n    if (PyUnicode_CompareWithASCIIString(name, \"__debug__\") == 0) {\n        ast_error(c, n, \"assignment to keyword\");\n        return 1;\n    }\n    if (full_checks) {\n        const char * const *p;\n        for (p = FORBIDDEN; *p; p++) {\n            if (PyUnicode_CompareWithASCIIString(name, *p) == 0) {\n                ast_error(c, n, \"assignment to keyword\");\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nconst char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrncat(line, buf, sizeof line);\n\t\tstrncat(line, \" \", sizeof line);\n\t\te = e->next;\n\t}\n\tline[(sizeof line)-1] = '\\0'; \n\tline[strlen(line)-1] = 0; \n\treturn line;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ns32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)\n{\n\tu32 pps_id;\n\n\tsi->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, \"irap_or_gdr_pic\");\n\tsi->non_ref_pic = gf_bs_read_int_log(bs, 1, \"non_ref_pic\");\n\tif (si->irap_or_gdr_pic)\n\t\tsi->gdr_pic = gf_bs_read_int_log(bs, 1, \"gdr_pic\");\n\tif ((si->inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"inter_slice_allowed_flag\")))\n\t\tsi->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"intra_slice_allowed_flag\");\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id >= 64))\n\t\treturn -1;\n\tsi->pps = &vvc->pps[pps_id];\n\tsi->sps = &vvc->sps[si->pps->sps_id];\n\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\n\tsi->recovery_point_valid = 0;\n\tsi->gdr_recovery_count = 0;\n\tif (si->gdr_pic) {\n\t\tsi->recovery_point_valid = 1;\n\t\tsi->gdr_recovery_count = gf_bs_read_ue_log(bs, \"gdr_recovery_count\");\n\t}\n\tgf_bs_read_int_log(bs, si->sps->ph_num_extra_bits, \"ph_extra_bits\");\n\n\tif (si->sps->poc_msb_cycle_flag) {\n\t\tif ( (si->poc_msb_cycle_present_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_present_flag\"))) {\n\t\t\tsi->poc_msb_cycle = gf_bs_read_int_log(bs, si->sps->poc_msb_cycle_len, \"poc_msb_cycle\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* hash = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);\n   TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);\n\n  const TfLiteTensor* input = GetInput(context, node, 1);\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n\n  if (NumInputs(node) == 3) {\n    const TfLiteTensor* weight = GetInput(context, node, 2);\n    TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),\n                      SizeOfDimension(input, 0));\n  }\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  switch (params->type) {\n    case kTfLiteLshProjectionSparse:\n      outputSize->data[0] = SizeOfDimension(hash, 0);\n      break;\n    case kTfLiteLshProjectionDense:\n      outputSize->data[0] = SizeOfDimension(hash, 0) * SizeOfDimension(hash, 1);\n      break;\n    default:\n      return kTfLiteError;\n  }\n  return context->ResizeTensor(context, output, outputSize);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPerl_my_setenv(pTHX_ const char *nam, const char *val)\n{\n  dVAR;\n#ifdef __amigaos4__\n  amigaos4_obtain_environ(__FUNCTION__);\n#endif\n#ifdef USE_ITHREADS\n  \n  if (PL_curinterp == aTHX)\n#endif\n  {\n#ifndef PERL_USE_SAFE_PUTENV\n    if (!PL_use_safe_putenv) {\n        \n        UV i;\n        Size_t vlen, nlen = strlen(nam);\n\n        \n        for (i = 0; environ[i]; i++) {\n            if (strnEQ(environ[i], nam, nlen) && environ[i][nlen] == '=')\n                break;\n        }\n\n        if (environ == PL_origenviron) {   \n            UV j, max;\n            char **tmpenv;\n\n            max = i;\n            while (environ[max])\n                max++;\n            \n            tmpenv = (char**)S_env_alloc(NULL, max, 2, 0, sizeof(char*));\n            for (j=0; j<max; j++) {         \n                const Size_t len = strlen(environ[j]);\n                tmpenv[j] = S_env_alloc(NULL, len, 1, 0, 1);\n                Copy(environ[j], tmpenv[j], len+1, char);\n            }\n            tmpenv[max] = NULL;\n            environ = tmpenv;               \n        }\n        if (!val) {\n            safesysfree(environ[i]);\n            while (environ[i]) {\n                environ[i] = environ[i+1];\n                i++;\n            }\n#ifdef __amigaos4__\n            goto my_setenv_out;\n#else\n            return;\n#endif\n        }\n        if (!environ[i]) {                 \n            environ = (char**)S_env_alloc(environ, i, 2, 0, sizeof(char*));\n            environ[i+1] = NULL;    \n        }\n        else\n            safesysfree(environ[i]);\n\n        vlen = strlen(val);\n\n        environ[i] = S_env_alloc(NULL, nlen, vlen, 2, 1);\n        \n        my_setenv_format(environ[i], nam, nlen, val, vlen);\n    } else {\n# endif\n    \n#   if defined(__CYGWIN__)|| defined(__SYMBIAN32__) || defined(__riscos__) || (defined(__sun) && defined(HAS_UNSETENV)) || defined(PERL_DARWIN)\n#       if defined(HAS_UNSETENV)\n        if (val == NULL) {\n            (void)unsetenv(nam);\n        } else {\n            (void)setenv(nam, val, 1);\n        }\n#       else \n        (void)setenv(nam, val, 1);\n#       endif \n#   elif defined(HAS_UNSETENV)\n        if (val == NULL) {\n            if (environ) \n                (void)unsetenv(nam);\n        } else {\n\t    const Size_t nlen = strlen(nam);\n\t    const Size_t vlen = strlen(val);\n\t    char * const new_env = S_env_alloc(NULL, nlen, vlen, 2, 1);\n            my_setenv_format(new_env, nam, nlen, val, vlen);\n            (void)putenv(new_env);\n        }\n#   else \n        char *new_env;\n\tconst Size_t nlen = strlen(nam);\n\tSize_t vlen;\n        if (!val) {\n\t   val = \"\";\n        }\n        vlen = strlen(val);\n        new_env = S_env_alloc(NULL, nlen, vlen, 2, 1);\n        \n        my_setenv_format(new_env, nam, nlen, val, vlen);\n        (void)putenv(new_env);\n#   endif \n#ifndef PERL_USE_SAFE_PUTENV\n    }\n#endif\n  }\n#ifdef __amigaos4__\nmy_setenv_out:\n  amigaos4_release_environ(__FUNCTION__);\n#endif\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int on_header_value(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n        SWITCH(data->header_field)\n        CASE(OGS_SBI_CONTENT_TYPE)\n            ogs_assert(data->part[data->num_of_part].content_type == NULL);\n            data->part[data->num_of_part].content_type =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_type);\n            break;\n        CASE(OGS_SBI_CONTENT_ID)\n            ogs_assert(data->part[data->num_of_part].content_id == NULL);\n            data->part[data->num_of_part].content_id =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_id);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown header field [%s]\", data->header_field);\n        END\n    }\n\n    return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool Archive::GetComment(Array<wchar> *CmtData)\n{\n  if (!MainComment)\n    return false;\n  SaveFilePos SavePos(*this);\n\n#ifndef SFX_MODULE\n  uint CmtLength;\n  if (Format==RARFMT14)\n  {\n    Seek(SFXSize+SIZEOF_MAINHEAD14,SEEK_SET);\n    CmtLength=GetByte();\n    CmtLength+=(GetByte()<<8);\n  }\n  else\n#endif\n  {\n    if (MainHead.CommentInHeader)\n    {\n                Seek(SFXSize+SIZEOF_MARKHEAD3+SIZEOF_MAINHEAD3,SEEK_SET);\n      if (!ReadHeader())\n        return false;\n    }\n    else\n    {\n           Seek(GetStartPos(),SEEK_SET);\n      return SearchSubBlock(SUBHEAD_TYPE_CMT)!=0 && ReadCommentData(CmtData);\n    }\n#ifndef SFX_MODULE\n          if (BrokenHeader)\n    {\n      uiMsg(UIERROR_CMTBROKEN,FileName);\n      return false;\n    }\n    CmtLength=CommHead.HeadSize-SIZEOF_COMMHEAD;\n#endif\n  }\n#ifndef SFX_MODULE\n  if (Format==RARFMT14 && MainHead.PackComment || Format!=RARFMT14 && CommHead.Method!=0x30)\n  {\n    if (Format!=RARFMT14 && (CommHead.UnpVer < 15 || CommHead.UnpVer > VER_UNPACK || CommHead.Method > 0x35))\n      return false;\n    ComprDataIO DataIO;\n    DataIO.SetTestMode(true);\n    uint UnpCmtLength;\n    if (Format==RARFMT14)\n    {\n#ifdef RAR_NOCRYPT\n      return false;\n#else\n      UnpCmtLength=GetByte();\n      UnpCmtLength+=(GetByte()<<8);\n      CmtLength-=2;\n      DataIO.SetCmt13Encryption();\n      CommHead.UnpVer=15;\n#endif\n    }\n    else\n      UnpCmtLength=CommHead.UnpSize;\n    DataIO.SetFiles(this,NULL);\n    DataIO.EnableShowProgress(false);\n    DataIO.SetPackedSizeToRead(CmtLength);\n    DataIO.UnpHash.Init(HASH_CRC32,1);\n    DataIO.SetNoFileHeader(true);\n    Unpack CmtUnpack(&DataIO);\n    CmtUnpack.Init(0x10000,false);\n    CmtUnpack.SetDestSize(UnpCmtLength);\n    CmtUnpack.DoUnpack(CommHead.UnpVer,false);\n\n    if (Format!=RARFMT14 && (DataIO.UnpHash.GetCRC32()&0xffff)!=CommHead.CommCRC)\n    {\n      uiMsg(UIERROR_CMTBROKEN,FileName);\n      return false;\n    }\n    else\n    {\n      byte *UnpData;\n      size_t UnpDataSize;\n      DataIO.GetUnpackedData(&UnpData,&UnpDataSize);\n#ifdef _WIN_ALL\n                OemToCharBuffA((char *)UnpData,(char *)UnpData,(DWORD)UnpDataSize);\n#endif\n      CmtData->Alloc(UnpDataSize+1);\n      memset(CmtData->Addr(0),0,CmtData->Size()*sizeof(wchar));\n      CharToWide((char *)UnpData,CmtData->Addr(0),CmtData->Size());\n      CmtData->Alloc(wcslen(CmtData->Addr(0)));\n    }\n  }\n  else\n  {\n    if (CmtLength==0)\n      return false;\n    Array<byte> CmtRaw(CmtLength);\n    int ReadSize=Read(&CmtRaw[0],CmtLength);\n    if (ReadSize>=0 && (uint)ReadSize<CmtLength)    {\n      CmtLength=ReadSize;\n      CmtRaw.Alloc(CmtLength);\n    }\n\n    if (Format!=RARFMT14 && CommHead.CommCRC!=(~CRC32(0xffffffff,&CmtRaw[0],CmtLength)&0xffff))\n    {\n      uiMsg(UIERROR_CMTBROKEN,FileName);\n      return false;\n    }\n    CmtData->Alloc(CmtLength+1);\n    CmtRaw.Push(0);\n#ifdef _WIN_ALL\n          OemToCharA((char *)&CmtRaw[0],(char *)&CmtRaw[0]);\n#endif\n    CharToWide((char *)&CmtRaw[0],CmtData->Addr(0),CmtLength);\n    CmtData->Alloc(wcslen(CmtData->Addr(0)));\n  }\n#endif\n  return CmtData->Size() > 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nMemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram(uc, ram, size, perms);\n    if (ram->addr == -1) {\n               return NULL;\n    }\n\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n\n    return ram;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic s32 gf_media_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tVVC_PPS *pps;\n\n\tpps_id = gf_bs_read_int_log(bs, 6, \"pps_id\");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &vvc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (pps->sps_id >= 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; \n\tpps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \"mixed_nal_types\");\n\tpps->width = gf_bs_read_ue_log(bs, \"width\");\n\tpps->height = gf_bs_read_ue_log(bs, \"height\");\n\tpps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\");\n\tif (pps->conf_window) {\n\t\tpps->cw_left = gf_bs_read_ue_log(bs, \"conf_win_left_offset\");\n\t\tpps->cw_right = gf_bs_read_ue_log(bs, \"conf_win_right_offset\");\n\t\tpps->cw_top = gf_bs_read_ue_log(bs, \"conf_win_top_offset\");\n\t\tpps->cw_bottom = gf_bs_read_ue_log(bs, \"conf_win_bottom_offset\");\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"scaling_window_explicit_signalling_flag\")) {\n\t\tgf_bs_read_se_log(bs, \"scaling_win_left_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_right_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_top_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_bottom_offset\");\n\t}\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");\n\tpps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, \"no_pic_partition_flag\");\n\tpps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\tif (pps->subpic_id_mapping_present_flag) {\n\t\tu32 pps_subpic_id_len, pps_num_subpics=0;\n\t\tif (!pps->no_pic_partition_flag) {\n\t\t\tpps_num_subpics = 1+gf_bs_read_ue_log(bs, \"pps_num_subpics_minus1\");\n\t\t}\n\t\tpps_subpic_id_len = 1 + gf_bs_read_ue(bs);\n\t\tfor (i=0; i<pps_num_subpics; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, pps_subpic_id_len, \"subpic_id\", i);\n\t\t}\n\t}\n\tif (!pps->no_pic_partition_flag) {\n\t\tgf_bs_read_int_log(bs, 2, \"pps_log2_ctu_size_minus5\");\n\t\tu32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_columns_minus1\");\n\t\tu32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_rows_minus1\");\n\t\tfor (i=0; i<num_exp_tile_columns; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"tile_column_width_minus1\", i);\n\t\tfor (i=0; i<num_exp_tile_rows; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"tile_row_height_minus1\", i);\n\n\t\t\treturn pps_id;\n\t}\n\n\n\n\treturn pps_id;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic unsigned int get_exif_ui32(struct iw_exif_state *e, unsigned int pos)\n{\n\tif(e->d_len<4 || pos>e->d_len-4) return 0;\n\treturn iw_get_ui32_e(&e->d[pos], e->endian);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\n\t\n\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\n\tlock_sock(sk);\n\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\t\n\t\tif (op->ifindex) {\n\t\t\t\n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list)\n\t\tbcm_remove_op(op);\n\n#if IS_ENABLED(CONFIG_PROC_FS)\n\t\n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif \n\n\t\n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_char *b, *s, *t, c;\n\tint i, proto;\n\tconst void *se;\n\n        if (length <= 0)\n                return;\n\n\tb = (uint8_t *)malloc(length);\n\tif (b == NULL)\n\t\treturn;\n\n\t\n\tfor (s = (u_char *)p, t = b, i = length; i > 0; i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i > 1) {\n\t\t\t\ti--;\n\t\t\t\tc = *s++ ^ 0x20;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n\n        \n        if (length < 1)\n                goto trunc;\n        proto = *b; \n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: \n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); \n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): \n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); \n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: \n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nrdp_in_unistr(STREAM s, int in_len, char **string, uint32 * str_size)\n{\n\tstatic iconv_t icv_utf16_to_local;\n\tsize_t ibl, obl;\n\tchar *pin, *pout;\n\n\tstruct stream packet = *s;\n\n\tif ((in_len < 0) || ((uint32)in_len >= (RD_UINT32_MAX / 2)))\n\t{\n\t\tlogger(Protocol, Error, \"rdp_in_unistr(), length of unicode data is out of bounds.\");\n\t\tabort();\n\t}\n\n\tif (!s_check_rem(s, in_len))\n\t{\n\t\trdp_protocol_error(\"rdp_in_unistr(), consume of unicode data from stream would overrun\", &packet);\n\t}\n\n\tif (!icv_utf16_to_local)\n\t{\n\t\ticv_utf16_to_local = iconv_open(g_codepage, WINDOWS_CODEPAGE);\n\t\tif (icv_utf16_to_local == (iconv_t) - 1)\n\t\t{\n\t\t\tlogger(Protocol, Error, \"rdp_in_unistr(), iconv_open[%s -> %s] fail %p\",\n\t\t\t       WINDOWS_CODEPAGE, g_codepage, icv_utf16_to_local);\n\t\t\tabort();\n\t\t}\n\t}\n\n\t\n\tif (*string == NULL)\n\t{\n\n\t\t*string = xmalloc(in_len * 2);\n\t\t*str_size = in_len * 2;\n\t}\n\n\tibl = in_len;\n\tobl = *str_size - 1;\n\tpin = (char *) s->p;\n\tpout = *string;\n\n\tif (iconv(icv_utf16_to_local, (char **) &pin, &ibl, &pout, &obl) == (size_t) - 1)\n\t{\n\t\tif (errno == E2BIG)\n\t\t{\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"rdp_in_unistr(), server sent an unexpectedly long string, truncating\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger(Protocol, Warning, \"rdp_in_unistr(), iconv fail, errno %d\", errno);\n\n\t\t\tfree(*string);\n\t\t\t*string = NULL;\n\t\t\t*str_size = 0;\n\t\t}\n\t\tabort();\n\t}\n\n\t\n\ts->p += in_len;\n\n\t*pout = 0;\n\n\tif (*string)\n\t\t*str_size = pout - *string;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool SetOpAttrScalar(TFE_Context* ctx, TFE_Op* op, const char* key,\n                     PyObject* py_value, TF_AttrType type,\n                     tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,\n                     TF_Status* status) {\n  if (type == TF_ATTR_STRING) {\n    tensorflow::StringPiece value;\n    if (!ParseStringValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrString(op, key, value.data(), value.size());\n  } else if (type == TF_ATTR_INT) {\n    int64_t value;\n    if (!ParseInt64Value(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrInt(op, key, value);\n             if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = value;\n  } else if (type == TF_ATTR_FLOAT) {\n    float value;\n    if (!ParseFloatValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrFloat(op, key, value);\n  } else if (type == TF_ATTR_BOOL) {\n    unsigned char value;\n    if (!ParseBoolValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrBool(op, key, value);\n  } else if (type == TF_ATTR_TYPE) {\n    int value;\n    if (!ParseTypeValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrType(op, key, static_cast<TF_DataType>(value));\n  } else if (type == TF_ATTR_SHAPE) {\n    if (py_value == Py_None) {\n      TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n    } else {\n      if (!PySequence_Check(py_value)) {\n        TF_SetStatus(status, TF_INVALID_ARGUMENT,\n                     tensorflow::strings::StrCat(\n                         \"Expecting None or sequence value for attr\", key,\n                         \", got \", py_value->ob_type->tp_name)\n                         .c_str());\n        return false;\n      }\n      const auto num_dims = TensorShapeNumDims(py_value);\n      if (num_dims == -1) {\n        TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n        return true;\n      }\n      std::unique_ptr<int64_t[]> dims(new int64_t[num_dims]);\n      for (int i = 0; i < num_dims; ++i) {\n        tensorflow::Safe_PyObjectPtr inner_py_value(\n            PySequence_ITEM(py_value, i));\n        if (inner_py_value.get() == Py_None) {\n          dims[i] = -1;\n        } else if (!ParseDimensionValue(key, inner_py_value.get(), status,\n                                        &dims[i])) {\n          return false;\n        }\n      }\n      TFE_OpSetAttrShape(op, key, dims.get(), num_dims, status);\n    }\n    if (!status->status.ok()) return false;\n  } else if (type == TF_ATTR_FUNC) {\n                            tensorflow::StringPiece func_name;\n    if (!ParseStringValue(key, py_value, status, &func_name)) {\n      PyObject* name_attr = PyObject_GetAttrString(py_value, \"name\");\n      if (name_attr == nullptr ||\n          !ParseStringValue(key, name_attr, status, &func_name)) {\n        TF_SetStatus(\n            status, TF_INVALID_ARGUMENT,\n            tensorflow::strings::StrCat(\n                \"unable to set function value attribute from a \",\n                py_value->ob_type->tp_name,\n                \" object. If you think this is an error, please file an issue \"\n                \"at https://github.com/tensorflow/tensorflow/issues/new\")\n                .c_str());\n        return false;\n      }\n    }\n    TF_SetStatus(status, TF_OK, \"\");\n    TFE_OpSetAttrFunctionName(op, key, func_name.data(), func_name.size());\n  } else {\n    TF_SetStatus(\n        status, TF_UNIMPLEMENTED,\n        tensorflow::strings::StrCat(\"Attr \", key, \" has unhandled type \", type)\n            .c_str());\n    return false;\n  }\n  return true;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nALWAYS_INLINE String serialize_impl(const Variant& value,\n                                    const SerializeOptions& opts) {\n  switch (value.getType()) {\n    case KindOfClass:\n    case KindOfLazyClass:\n    case KindOfPersistentString:\n    case KindOfString: {\n      auto const str =\n        isStringType(value.getType()) ? value.getStringData() :\n        isClassType(value.getType()) ? classToStringHelper(value.toClassVal()) :\n        lazyClassToStringHelper(value.toLazyClassVal());\n      auto const size = str->size();\n      if (size >= RuntimeOption::MaxSerializedStringSize) {\n        throw Exception(\"Size of serialized string (%d) exceeds max\", size);\n      }\n      StringBuffer sb;\n      sb.append(\"s:\");\n      sb.append(size);\n      sb.append(\":\\\"\");\n      sb.append(str->data(), size);\n      sb.append(\"\\\";\");\n      return sb.detach();\n    }\n    case KindOfResource:\n      return s_Res;\n\n    case KindOfUninit:\n    case KindOfNull:\n    case KindOfBoolean:\n    case KindOfInt64:\n    case KindOfFunc:\n    case KindOfPersistentVec:\n    case KindOfVec:\n    case KindOfPersistentDict:\n    case KindOfDict:\n    case KindOfPersistentKeyset:\n    case KindOfKeyset:\n    case KindOfPersistentDArray:\n    case KindOfDArray:\n    case KindOfPersistentVArray:\n    case KindOfVArray:\n    case KindOfDouble:\n    case KindOfObject:\n    case KindOfClsMeth:\n    case KindOfRClsMeth:\n    case KindOfRFunc:\n    case KindOfRecord:\n      break;\n  }\n  VariableSerializer vs(VariableSerializer::Type::Serialize);\n  if (opts.keepDVArrays)        vs.keepDVArrays();\n  if (opts.forcePHPArrays)      vs.setForcePHPArrays();\n  if (opts.warnOnHackArrays)    vs.setHackWarn();\n  if (opts.warnOnPHPArrays)     vs.setPHPWarn();\n  if (opts.ignoreLateInit)      vs.setIgnoreLateInit();\n  if (opts.serializeProvenanceAndLegacy) vs.setSerializeProvenanceAndLegacy();\n   return vs.serialize(value, true, true);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus SimpleOpEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = tflite::GetInput(context, node, 0);\n  const TfLiteTensor* input2 = tflite::GetInput(context, node, 1);\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n\n  int32_t* output_data = output->data.i32;\n  *output_data = *(input1->data.i32) + *(input2->data.i32);\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic XMLSharedNodeList* find_impl(xmlXPathContext* ctxt, const string& xpath)\n{\n\txmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);\n\n\tif (!result) {\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt->doc);\n\n\t\tthrow XMLException(\"Invalid XPath: \" + xpath);\n\t}\n\n\tif (result->type != XPATH_NODESET) {\n\t\txmlXPathFreeObject(result);\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt->doc);\n\n\t\tthrow XMLException(\"Only nodeset result types are supported.\");\n\t}\n\n\txmlNodeSet* nodeset = result->nodesetval;\n\tXMLSharedNodeList* nodes = new XMLSharedNodeList();\n\tif (nodeset) {\n\t\tfor (int i = 0; i < nodeset->nodeNr; ++i) {\n\t\t\tXMLNode* node = readnode(nodeset->nodeTab[i]);\n\t\t\tnodes->push_back(boost::shared_ptr<XMLNode>(node));\n\t\t}\n\t} else {\n\t\t}\n\n\txmlXPathFreeObject(result);\n\n\treturn nodes;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus PopulatePrecomputedZPTimesWeightsWithBias(TfLiteContext* context,\n                                                       OpData* op_data,\n                                                       TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* output_state =\n      GetVariableInput(context, node, kOutputStateTensor);\n  TF_LITE_ENSURE(context, output_state != nullptr);\n\n  const int32_t input_zero_point = -input->params.zero_point;\n  const int32_t output_state_zero_point = -output_state->params.zero_point;\n\n  const TfLiteTensor* input_to_input_weights =\n      GetOptionalInputTensor(context, node, kInputToInputWeightsTensor);\n  const TfLiteTensor* input_to_forget_weights =\n      GetInput(context, node, kInputToForgetWeightsTensor);\n  const TfLiteTensor* input_to_cell_weights =\n      GetInput(context, node, kInputToCellWeightsTensor);\n  const TfLiteTensor* input_to_output_weights =\n      GetInput(context, node, kInputToOutputWeightsTensor);\n\n  const TfLiteTensor* recurrent_to_input_weights =\n      GetOptionalInputTensor(context, node, kRecurrentToInputWeightsTensor);\n  const TfLiteTensor* recurrent_to_forget_weights =\n      GetInput(context, node, kRecurrentToForgetWeightsTensor);\n  const TfLiteTensor* recurrent_to_cell_weights =\n      GetInput(context, node, kRecurrentToCellWeightsTensor);\n  const TfLiteTensor* recurrent_to_output_weights =\n      GetInput(context, node, kRecurrentToOutputWeightsTensor);\n\n  const TfLiteTensor* projection_weights =\n      GetOptionalInputTensor(context, node, kProjectionWeightsTensor);\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, kProjectionBiasTensor);\n\n  lstm_eval::IntegerLstmParameter* integer_lstm_params =\n      &op_data->integer_lstm_param;\n\n  const TfLiteTensor* intermediate =\n      &context->tensors[node->intermediates->data[4]];\n  const auto* params =\n      static_cast<TfLiteAffineQuantization*>(intermediate->quantization.params);\n  const int32_t hidden_zp = params->zero_point->data[0];\n\n      const bool is_layer_norm = op_data->use_layer_norm;\n\n   const TfLiteTensor* forget_gate_bias =\n      is_layer_norm ? nullptr : GetInput(context, node, kForgetGateBiasTensor);\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, input_zero_point, input_to_forget_weights, forget_gate_bias,\n          &(integer_lstm_params->input_to_forget_effective_bias)));\n\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, output_state_zero_point, recurrent_to_forget_weights,\n          nullptr, &(integer_lstm_params->recurrent_to_forget_effective_bias)));\n\n   const TfLiteTensor* cell_gate_bias =\n      is_layer_norm ? nullptr : GetInput(context, node, kCellGateBiasTensor);\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, input_zero_point, input_to_cell_weights, cell_gate_bias,\n          &(integer_lstm_params->input_to_cell_effective_bias)));\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, output_state_zero_point, recurrent_to_cell_weights, nullptr,\n          &(integer_lstm_params->recurrent_to_cell_effective_bias)));\n\n   const TfLiteTensor* output_gate_bias =\n      is_layer_norm ? nullptr : GetInput(context, node, kOutputGateBiasTensor);\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, input_zero_point, input_to_output_weights, output_gate_bias,\n          &(integer_lstm_params->input_to_output_effective_bias)));\n\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, output_state_zero_point, recurrent_to_output_weights,\n          nullptr, &(integer_lstm_params->recurrent_to_output_effective_bias)));\n\n   const TfLiteTensor* input_gate_bias =\n      is_layer_norm ? nullptr : GetInput(context, node, kInputGateBiasTensor);\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, input_zero_point, input_to_input_weights, input_gate_bias,\n          &(integer_lstm_params->input_to_input_effective_bias)));\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, output_state_zero_point, recurrent_to_input_weights, nullptr,\n          &(integer_lstm_params->recurrent_to_input_effective_bias)));\n\n   TF_LITE_ENSURE_OK(context,\n                    PrecomputeZeroPointTimesWeightWithBias(\n                        context, hidden_zp, projection_weights, projection_bias,\n                        &(integer_lstm_params->projection_effective_bias)));\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nhybiReturnData(char *dst, int len, ws_ctx_t *wsctx, int *nWritten)\n{\n  int nextState = WS_HYBI_STATE_ERR;\n\n  \n  if (wsctx->readlen > 0) {\n    \n    if (wsctx->readlen > len) {\n      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", len, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, len);\n      *nWritten = len;\n      wsctx->readlen -= len;\n      wsctx->readPos += len;\n      nextState = WS_HYBI_STATE_DATA_AVAILABLE;\n    } else {\n      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", wsctx->readlen, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, wsctx->readlen);\n      *nWritten = wsctx->readlen;\n      wsctx->readlen = 0;\n      wsctx->readPos = NULL;\n      if (hybiRemaining(wsctx) == 0) {\n        nextState = WS_HYBI_STATE_FRAME_COMPLETE;\n      } else {\n        nextState = WS_HYBI_STATE_DATA_NEEDED;\n      }\n    }\n    rfbLog(\"after copy: readPos=%p, readLen=%d\\n\", wsctx->readPos, wsctx->readlen);\n  } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_CLOSE_REASON_PENDING) {\n    nextState = WS_HYBI_STATE_CLOSE_REASON_PENDING;\n  }\n  return nextState;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid FormatConverter<T>::InitSparseToDenseConverter(\n    std::vector<int> shape, std::vector<int> traversal_order,\n    std::vector<TfLiteDimensionType> format, std::vector<int> dense_size,\n    std::vector<std::vector<int>> segments,\n    std::vector<std::vector<int>> indices, std::vector<int> block_map) {\n  dense_shape_ = std::move(shape);\n  traversal_order_ = std::move(traversal_order);\n  block_map_ = std::move(block_map);\n  format_ = std::move(format);\n\n  dense_size_ = 1;\n  for (int i = 0; i < dense_shape_.size(); i++) {\n    dense_size_ *= dense_shape_[i];\n  }\n\n  dim_metadata_.resize(2 * format_.size());\n  for (int i = 0; i < format_.size(); i++) {\n    if (format_[i] == kTfLiteDimDense) {\n      dim_metadata_[2 * i] = {dense_size[i]};\n    } else {\n      dim_metadata_[2 * i] = std::move(segments[i]);\n      dim_metadata_[2 * i + 1] = std::move(indices[i]);\n    }\n  }\n\n  int original_rank = dense_shape_.size();\n  int block_dim = 0;\n\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      int orig_dim = traversal_order_[original_rank + block_dim];\n      block_size_[block_dim] = dense_size[orig_dim];\n      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];\n      block_dim++;\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast2obj_slice(void* _o)\n{\n    slice_ty o = (slice_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    switch (o->kind) {\n    case Slice_kind:\n        result = PyType_GenericNew(Slice_type, NULL, NULL);\n        if (!result) goto failed;\n        value = ast2obj_expr(o->v.Slice.lower);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_lower, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        value = ast2obj_expr(o->v.Slice.upper);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_upper, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        value = ast2obj_expr(o->v.Slice.step);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_step, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        break;\n    case ExtSlice_kind:\n        result = PyType_GenericNew(ExtSlice_type, NULL, NULL);\n        if (!result) goto failed;\n        value = ast2obj_list(o->v.ExtSlice.dims, ast2obj_slice);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_dims, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        break;\n    case Index_kind:\n        result = PyType_GenericNew(Index_type, NULL, NULL);\n        if (!result) goto failed;\n        value = ast2obj_expr(o->v.Index.value);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        break;\n    }\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\n\tchar *colon;\n\tchar *host = NULL;\n\n#ifdef HAVE_IPV6\n\tchar *p;\n\n\tif (*(str) == '[' && str_len > 1) {\n\t\t\n\t\tp = memchr(str + 1, ']', str_len - 2);\n\t\tif (!p || *(p + 1) != ':') {\n\t\t\tif (get_err) {\n\t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\t*portno = atoi(p + 2);\n\t\treturn estrndup(str + 1, p - str - 1);\n\t}\n#endif\n\tif (str_len) {\n\t\tcolon = memchr(str, ':', str_len - 1);\n\t} else {\n\t\tcolon = NULL;\n\t}\n\tif (colon) {\n\t\t*portno = atoi(colon + 1);\n\t\thost = estrndup(str, colon - str);\n\t} else {\n\t\tif (get_err) {\n\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\treturn host;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void Compute(OpKernelContext* context) override {\n    const Tensor& x = context->input(0);\n    const Tensor& y = context->input(1);\n    const float min_x = context->input(2).flat<float>()(0);\n    const float max_x = context->input(3).flat<float>()(0);\n    const float min_y = context->input(4).flat<float>()(0);\n    const float max_y = context->input(5).flat<float>()(0);\n\n    BCast bcast(BCast::FromShape(x.shape()), BCast::FromShape(y.shape()));\n    if (!bcast.IsValid()) {\n      context->SetStatus(errors::InvalidArgument(\n          \"Incompatible shapes: \", x.shape().DebugString(), \" vs. \",\n          y.shape().DebugString()));\n      return;\n    }\n    Tensor* z;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0, BCast::ToShape(bcast.output_shape()), &z));\n\n             OP_REQUIRES(context, (max_x > min_x),\n                errors::InvalidArgument(\"max_x must be larger than min_a.\"));\n    OP_REQUIRES(context, (max_y > min_y),\n                errors::InvalidArgument(\"max_x must be larger than min_b.\"));\n    const int32 offset_x = FloatToQuantizedUnclamped<T>(0.0f, min_x, max_x);\n    const int32 offset_y = FloatToQuantizedUnclamped<T>(0.0f, min_y, max_y);\n    const T* x_data = x.flat<T>().data();\n    const T* y_data = y.flat<T>().data();\n    Toutput* z_data = z->flat<Toutput>().data();\n\n    const int ndims = bcast.x_reshape().size();\n    if (ndims <= 1) {\n      if (x.NumElements() == 1) {\n        ScalarMultiply<T, Toutput>(context, y_data, offset_y, y.NumElements(),\n                                   x_data[0], offset_x, z_data);\n      } else if (y.NumElements() == 1) {\n        ScalarMultiply<T, Toutput>(context, x_data, offset_x, x.NumElements(),\n                                   y_data[0], offset_y, z_data);\n      } else {\n        VectorMultiply<T, Toutput>(context, x_data, offset_x, y_data, offset_y,\n                                   x.NumElements(), z_data);\n      }\n    } else if (ndims == 2) {\n      const T* vector_data;\n      int64 vector_num_elements;\n      int32 vector_offset;\n      const T* tensor_data;\n      int64 tensor_num_elements;\n      int32 tensor_offset;\n      if (x.NumElements() < y.NumElements()) {\n        vector_data = x_data;\n        vector_num_elements = x.NumElements();\n        vector_offset = offset_x;\n        tensor_data = y_data;\n        tensor_num_elements = y.NumElements();\n        tensor_offset = offset_y;\n      } else {\n        vector_data = y_data;\n        vector_num_elements = y.NumElements();\n        vector_offset = offset_y;\n        tensor_data = x_data;\n        tensor_num_elements = x.NumElements();\n        tensor_offset = offset_x;\n      }\n      if (vector_num_elements == 0) {\n        context->SetStatus(\n            errors::InvalidArgument(\"vector must have at least 1 element\"));\n        return;\n      }\n      VectorTensorMultiply<T, Toutput>(\n          vector_data, vector_offset, vector_num_elements, tensor_data,\n          tensor_offset, tensor_num_elements, z_data);\n    } else {\n      LOG(INFO) << \"ndims=\" << ndims;\n      LOG(INFO) << \"bcast.x_reshape()=\"\n                << TensorShape(bcast.x_reshape()).DebugString();\n      LOG(INFO) << \"bcast.y_reshape()=\"\n                << TensorShape(bcast.y_reshape()).DebugString();\n      LOG(INFO) << \"bcast.x_bcast()=\"\n                << TensorShape(bcast.x_bcast()).DebugString();\n      LOG(INFO) << \"bcast.y_bcast()=\"\n                << TensorShape(bcast.y_bcast()).DebugString();\n\n      context->SetStatus(errors::Unimplemented(\n          \"Broadcast between \", context->input(0).shape().DebugString(),\n          \" and \", context->input(1).shape().DebugString(),\n          \" is not supported yet.\"));\n      return;\n    }\n\n    float min_z_value;\n    float max_z_value;\n    QuantizationRangeForMultiplication<T, T, Toutput>(\n        min_x, max_x, min_y, max_y, &min_z_value, &max_z_value);\n    Tensor* z_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &z_min));\n    z_min->flat<float>()(0) = min_z_value;\n\n    Tensor* z_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &z_max));\n    z_max->flat<float>()(0) = max_z_value;\n  }\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tstruct dev_pagemap *pgmap = NULL;\n\tint nr_start = *nr, ret = 0;\n\tpte_t *ptep, *ptem;\n\n\tptem = ptep = pte_offset_map(&pmd, addr);\n\tdo {\n\t\tpte_t pte = gup_get_pte(ptep);\n\t\tstruct page *head, *page;\n\n\t\t\n\t\tif (pte_protnone(pte))\n\t\t\tgoto pte_unmap;\n\n\t\tif (!pte_access_permitted(pte, write))\n\t\t\tgoto pte_unmap;\n\n\t\tif (pte_devmap(pte)) {\n\t\t\tpgmap = get_dev_pagemap(pte_pfn(pte), pgmap);\n\t\t\tif (unlikely(!pgmap)) {\n\t\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\t\tgoto pte_unmap;\n\t\t\t}\n\t\t} else if (pte_special(pte))\n\t\t\tgoto pte_unmap;\n\n\t\tVM_BUG_ON(!pfn_valid(pte_pfn(pte)));\n\t\tpage = pte_page(pte);\n\t\thead = compound_head(page);\n\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto pte_unmap;\n\n\t\tif (unlikely(pte_val(pte) != pte_val(*ptep))) {\n\t\t\tput_page(head);\n\t\t\tgoto pte_unmap;\n\t\t}\n\n\t\tVM_BUG_ON_PAGE(compound_head(page) != head, page);\n\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\n\t} while (ptep++, addr += PAGE_SIZE, addr != end);\n\n\tret = 1;\n\npte_unmap:\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\tpte_unmap(ptem);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  output->type = input->type;\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);\n  return context->ResizeTensor(context, output, output_size);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  \n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageType(image,BilevelType,exception);\n  (void) SetImageDepth(image,1,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  \n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  \n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ntTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, caller);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE(context, node->inputs->size > 0);\n\n   const TfLiteTensor* cond = GetInput(context, node, 0);\n     TF_LITE_ENSURE_EQ(context, cond->type, kTfLiteBool);\n  TF_LITE_ENSURE_EQ(context, NumElements(cond), 1);\n\n     int num_inputs = node->inputs->size - 1;\n  int num_outputs = node->outputs->size;\n\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n  TF_LITE_ENSURE(context, op_data->then_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context, op_data->else_subgraph_index < subgraphs->size());\n\n  Subgraph* then_subgraph = (*subgraphs)[op_data->then_subgraph_index].get();\n  Subgraph* else_subgraph = (*subgraphs)[op_data->else_subgraph_index].get();\n\n  for (auto* subgraph : {then_subgraph, else_subgraph}) {\n    TF_LITE_ENSURE_EQ(context, num_inputs, subgraph->inputs().size());\n    TF_LITE_ENSURE_EQ(context, num_outputs, subgraph->outputs().size());\n  }\n\n  bool has_dynamic_output_tensors = false;\n  for (auto* subgraph : {then_subgraph, else_subgraph}) {\n    for (int i = 0; i < num_inputs; ++i) {\n                const TfLiteTensor* input = GetInput(context, node, i + 1);\n      std::vector<int> dims(input->dims->data,\n                            input->dims->data + input->dims->size);\n      subgraph->ResizeInputTensor(i, dims);\n      TfLiteTensor* subgraph_input = subgraph->tensor(subgraph->inputs()[i]);\n      TF_LITE_ENSURE_TYPES_EQ(context, input->type, subgraph_input->type);\n    }\n             TF_LITE_ENSURE_OK(context, subgraph->AllocateTensors());\n    has_dynamic_output_tensors |= subgraph->HasDynamicTensors();\n  }\n\n  if (!has_dynamic_output_tensors) {\n    for (int i = 0; i < num_outputs; ++i) {\n      TfLiteTensor* then_output =\n          then_subgraph->tensor(then_subgraph->outputs()[i]);\n      TfLiteTensor* else_output =\n          else_subgraph->tensor(else_subgraph->outputs()[i]);\n                if (!TfLiteIntArrayEqual(then_output->dims, else_output->dims)) {\n        has_dynamic_output_tensors = true;\n        break;\n      }\n    }\n  }\n\n  for (int i = 0; i < num_outputs; ++i) {\n    TfLiteTensor* output = GetOutput(context, node, i);\n    if (has_dynamic_output_tensors) {\n      SetTensorToDynamic(output);\n    } else {\n                TfLiteTensor* then_output =\n          then_subgraph->tensor(then_subgraph->outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(then_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic std::string WC2MB(const std::wstring& input, unsigned int code_page) {\n  if (input.empty()) {\n    return \"\";\n  }\n\n     DWORD flags = 0;\n  if (code_page != 65001 && code_page != 54936) {\n    flags = WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR;\n  }\n\n  int length = ::WideCharToMultiByte(code_page, flags, &input[0],\n                                     static_cast<int>(input.size()), NULL, 0,\n                                     NULL, NULL);\n\n  std::string output(length, '\\0');\n\n  ::WideCharToMultiByte(code_page, flags, &input[0],\n                        static_cast<int>(input.size()), &output[0],\n                        static_cast<int>(output.size()), NULL, NULL);\n\n  return output;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmcs_recv_connect_response(STREAM mcs_data)\n{\n\tUNUSED(mcs_data);\n\tuint8 result;\n\tint length;\n\tSTREAM s;\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\tber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\n\n\tber_parse_header(s, BER_TAG_RESULT, &length);\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);\n\t\treturn False;\n\t}\n\n\tber_parse_header(s, BER_TAG_INTEGER, &length);\n\tin_uint8s(s, length);\t\n\tmcs_parse_domain_params(s);\n\n\tber_parse_header(s, BER_TAG_OCTET_STRING, &length);\n\n\tsec_process_mcs_data(s);\n\t\n\treturn s_check_end(s);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int read_public_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I1012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = file->size;\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_public_key(p, keysize, rsa);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid set_content_type(HttpResponse res, const char *mime) {\n        set_header(res, \"Content-Type\", \"%s\", mime);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint __close_fd_get_file(unsigned int fd, struct file **res)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\tget_file(file);\n\t*res = file;\n\treturn 0;\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\t*res = NULL;\n\treturn -ENOENT;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nx86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access)\n{\n\tunsigned int first = 0;\n\tunsigned int last = ARR_SIZE(insn_regs_intel) - 1;\n\tunsigned int mid = ARR_SIZE(insn_regs_intel) / 2;\n\n\tif (!intel_regs_sorted) {\n\t\tmemcpy(insn_regs_intel_sorted, insn_regs_intel,\n\t\t\t\tsizeof(insn_regs_intel_sorted));\n\t\tqsort(insn_regs_intel_sorted,\n\t\t\t\tARR_SIZE(insn_regs_intel_sorted),\n\t\t\t\tsizeof(struct insn_reg), regs_cmp);\n\t\tintel_regs_sorted = true;\n\t}\n\n\twhile (first <= last) {\n\t\tif (insn_regs_intel_sorted[mid].insn < id) {\n\t\t\tfirst = mid + 1;\n\t\t} else if (insn_regs_intel_sorted[mid].insn == id) {\n\t\t\tif (access) {\n\t\t\t\t*access = insn_regs_intel_sorted[mid].access;\n\t\t\t}\n\t\t\treturn insn_regs_intel_sorted[mid].reg;\n\t\t} else {\n\t\t\tif (mid == 0)\n\t\t\t\tbreak;\n\t\t\tlast = mid - 1;\n\t\t}\n\t\tmid = (first + last) / 2;\n\t}\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nget_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void clear() {\n    if (ctx_pktlen_) {\n      EVP_CIPHER_CTX_cleanup(ctx_pktlen_);\n      EVP_CIPHER_CTX_free(ctx_pktlen_);\n      ctx_pktlen_ = nullptr;\n    }\n    if (ctx_main_) {\n      EVP_CIPHER_CTX_cleanup(ctx_main_);\n      EVP_CIPHER_CTX_free(ctx_main_);\n      ctx_main_ = nullptr;\n    }\n    if (polykey_) {\n      EVP_PKEY_free(polykey_);\n      polykey_ = nullptr;\n    }\n    if (md_ctx_) {\n      EVP_MD_CTX_free(md_ctx_);\n      md_ctx_ = nullptr;\n    }\n        }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nResult ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\n{\n    auto* zei = entries.getUnchecked (index);\n\n   #if JUCE_WINDOWS\n    auto entryPath = zei->entry.filename;\n   #else\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\n   #endif\n\n    if (entryPath.isEmpty())\n        return Result::ok();\n\n    auto targetFile = targetDirectory.getChildFile (entryPath);\n\n    if (! targetFile.isAChildOf (targetDirectory))\n        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\n\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\n        return targetFile.createDirectory();\n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\n\n    if (in == nullptr)\n        return Result::fail (\"Failed to open the zip file for reading\");\n\n    if (targetFile.exists())\n    {\n        if (overwriteFiles == OverwriteFiles::no)\n            return Result::ok();\n\n        if (! targetFile.deleteFile())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n    }\n\n    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\n        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\n\n    if (! targetFile.getParentDirectory().createDirectory())\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\n\n    if (zei->entry.isSymbolicLink)\n    {\n        String originalFilePath (in->readEntireStreamAsString()\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\n\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\n    }\n    else\n    {\n        FileOutputStream out (targetFile);\n\n        if (out.failedToOpen())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n\n        out << *in;\n    }\n\n    targetFile.setCreationTime (zei->entry.fileTime);\n    targetFile.setLastModificationTime (zei->entry.fileTime);\n    targetFile.setLastAccessTime (zei->entry.fileTime);\n\n    return Result::ok();\n}\n\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nR_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (!sz) {\n\t\treturn NULL;\n\t}\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;\n\tattr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->size = offset;\n\treturn attr;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nnew_type_comment(const char *s)\n{\n  return PyUnicode_DecodeUTF8(s, strlen(s), NULL);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int __driver_rfc4106_decrypt(struct aead_request *req)\n{\n\tu8 one_entry_in_sg = 0;\n\tu8 *src, *dst, *assoc;\n\tunsigned long tempCipherLen = 0;\n\t__be32 counter = cpu_to_be32(1);\n\tint retval = 0;\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct aesni_rfc4106_gcm_ctx *ctx = aesni_rfc4106_gcm_ctx_get(tfm);\n\tu32 key_len = ctx->aes_key_expanded.key_length;\n\tvoid *aes_ctx = &(ctx->aes_key_expanded);\n\tunsigned long auth_tag_len = crypto_aead_authsize(tfm);\n\tu8 iv_and_authTag[32+AESNI_ALIGN];\n\tu8 *iv = (u8 *) PTR_ALIGN((u8 *)iv_and_authTag, AESNI_ALIGN);\n\tu8 *authTag = iv + 16;\n\tstruct scatter_walk src_sg_walk;\n\tstruct scatter_walk assoc_sg_walk;\n\tstruct scatter_walk dst_sg_walk;\n\tunsigned int i;\n\n\tif (unlikely((req->cryptlen < auth_tag_len) ||\n\t\t(req->assoclen != 8 && req->assoclen != 12)))\n\t\treturn -EINVAL;\n\tif (unlikely(auth_tag_len != 8 && auth_tag_len != 12 && auth_tag_len != 16))\n\t        return -EINVAL;\n\tif (unlikely(key_len != AES_KEYSIZE_128 &&\n\t             key_len != AES_KEYSIZE_192 &&\n\t             key_len != AES_KEYSIZE_256))\n\t        return -EINVAL;\n\n\t\n\t\n\t\n\n\ttempCipherLen = (unsigned long)(req->cryptlen - auth_tag_len);\n\t\n\tfor (i = 0; i < 4; i++)\n\t\t*(iv+i) = ctx->nonce[i];\n\tfor (i = 0; i < 8; i++)\n\t\t*(iv+4+i) = req->iv[i];\n\t*((__be32 *)(iv+12)) = counter;\n\n\tif ((sg_is_last(req->src)) && (sg_is_last(req->assoc))) {\n\t\tone_entry_in_sg = 1;\n\t\tscatterwalk_start(&src_sg_walk, req->src);\n\t\tscatterwalk_start(&assoc_sg_walk, req->assoc);\n\t\tsrc = scatterwalk_map(&src_sg_walk);\n\t\tassoc = scatterwalk_map(&assoc_sg_walk);\n\t\tdst = src;\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_start(&dst_sg_walk, req->dst);\n\t\t\tdst = scatterwalk_map(&dst_sg_walk);\n\t\t}\n\n\t} else {\n\t\t\n\t\tsrc = kmalloc(req->cryptlen + req->assoclen, GFP_ATOMIC);\n\t\tif (!src)\n\t\t\treturn -ENOMEM;\n\t\tassoc = (src + req->cryptlen + auth_tag_len);\n\t\tscatterwalk_map_and_copy(src, req->src, 0, req->cryptlen, 0);\n\t\tscatterwalk_map_and_copy(assoc, req->assoc, 0,\n\t\t\treq->assoclen, 0);\n\t\tdst = src;\n\t}\n\n\taesni_gcm_dec_tfm(aes_ctx, dst, src, tempCipherLen, iv,\n\t\tctx->hash_subkey, assoc, (unsigned long)req->assoclen,\n\t\tauthTag, auth_tag_len);\n\n\t\n\tretval = crypto_memneq(src + tempCipherLen, authTag, auth_tag_len) ?\n\t\t-EBADMSG : 0;\n\n\tif (one_entry_in_sg) {\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_unmap(dst);\n\t\t\tscatterwalk_done(&dst_sg_walk, 0, 0);\n\t\t}\n\t\tscatterwalk_unmap(src);\n\t\tscatterwalk_unmap(assoc);\n\t\tscatterwalk_done(&src_sg_walk, 0, 0);\n\t\tscatterwalk_done(&assoc_sg_walk, 0, 0);\n\t} else {\n\t\tscatterwalk_map_and_copy(dst, req->dst, 0, req->cryptlen, 1);\n\t\tkfree(src);\n\t}\n\treturn retval;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteIntArray* input_dims = input->dims;\n  int input_dims_size = input_dims->size;\n  TF_LITE_ENSURE(context, input_dims_size >= 1);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n   TfLiteIntArray* output_shape = TfLiteIntArrayCreate(input_dims_size + 1);\n  for (int i = 0; i < input_dims_size; i++) {\n    output_shape->data[i] = input_dims->data[i];\n  }\n    output_shape->data[input_dims_size] = input_dims->data[input_dims_size - 1];\n  output->type = input->type;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_shape));\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void queue_delete(struct snd_seq_queue *q)\n{\n\t\n\tmutex_lock(&q->timer_mutex);\n\tsnd_seq_timer_stop(q->timer);\n\tsnd_seq_timer_close(q);\n\tmutex_unlock(&q->timer_mutex);\n\t\n\tsnd_use_lock_sync(&q->use_lock);\n\t\n\tsnd_seq_prioq_delete(&q->tickq);\n\tsnd_seq_prioq_delete(&q->timeq);\n\tsnd_seq_timer_delete(&q->timer);\n\n\tkfree(q);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint ext4_collapse_range(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t punch_start, punch_stop;\n\thandle_t *handle;\n\tunsigned int credits;\n\tloff_t new_size, ioffset;\n\tint ret;\n\n\t\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\treturn -EOPNOTSUPP;\n\n\t\n\tif (offset & (EXT4_CLUSTER_SIZE(sb) - 1) ||\n\t    len & (EXT4_CLUSTER_SIZE(sb) - 1))\n\t\treturn -EINVAL;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\ttrace_ext4_collapse_range(inode, offset, len);\n\n\tpunch_start = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\tpunch_stop = (offset + len) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t\n\tif (ext4_should_journal_data(inode)) {\n\t\tret = ext4_force_commit(inode->i_sb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t\n\tioffset = round_down(offset, PAGE_SIZE);\n\n\t\n\tret = filemap_write_and_wait_range(inode->i_mapping, ioffset,\n\t\t\t\t\t   LLONG_MAX);\n\tif (ret)\n\t\treturn ret;\n\n\t\n\tmutex_lock(&inode->i_mutex);\n\n\t\n\tif (offset + len >= i_size_read(inode)) {\n\t\tret = -EINVAL;\n\t\tgoto out_mutex;\n\t}\n\n\t\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\t\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\t\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\ttruncate_pagecache(inode, ioffset);\n\n\tcredits = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out_mmap;\n\t}\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, punch_start,\n\t\t\t\t    EXT_MAX_BLOCKS - punch_start);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tret = ext4_ext_remove_space(inode, punch_start, punch_stop - 1);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\text4_discard_preallocations(inode);\n\n\tret = ext4_ext_shift_extents(inode, handle, punch_stop,\n\t\t\t\t     punch_stop - punch_start, SHIFT_LEFT);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tnew_size = i_size_read(inode) - len;\n\ti_size_write(inode, new_size);\n\tEXT4_I(inode)->i_disksize = new_size;\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\nout_stop:\n\text4_journal_stop(handle);\nout_mmap:\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TfLiteTensor* output_index_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, 1, &output_index_tensor));\n  TF_LITE_ENSURE_EQ(context, NumElements(output_index_tensor),\n                    NumElements(input));\n\n  switch (input->type) {\n    case kTfLiteInt8:\n      TF_LITE_ENSURE_STATUS(EvalImpl<int8_t>(context, input, node));\n      break;\n    case kTfLiteInt16:\n      TF_LITE_ENSURE_STATUS(EvalImpl<int16_t>(context, input, node));\n      break;\n    case kTfLiteInt32:\n      TF_LITE_ENSURE_STATUS(EvalImpl<int32_t>(context, input, node));\n      break;\n    case kTfLiteInt64:\n      TF_LITE_ENSURE_STATUS(EvalImpl<int64_t>(context, input, node));\n      break;\n    case kTfLiteFloat32:\n      TF_LITE_ENSURE_STATUS(EvalImpl<float>(context, input, node));\n      break;\n    case kTfLiteUInt8:\n      TF_LITE_ENSURE_STATUS(EvalImpl<uint8_t>(context, input, node));\n      break;\n    default:\n      context->ReportError(context, \"Currently Unique doesn't support type: %s\",\n                           TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline void tss_invalidate_io_bitmap(void)\n{\n\tPVOP_VCALL0(cpu.invalidate_io_bitmap);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n{\n    int i, j, v;\n\n    if (get_bits1(gb)) {\n        if (get_bits_left(gb) < 64*8)\n            return AVERROR_INVALIDDATA;\n        \n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n\n    if (get_bits1(gb)) {\n        if (get_bits_left(gb) < 64*8)\n            return AVERROR_INVALIDDATA;\n        \n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n\n    if (get_bits1(gb)) {\n        if (get_bits_left(gb) < 64*8)\n            return AVERROR_INVALIDDATA;\n        \n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n\n    if (get_bits1(gb)) {\n        if (get_bits_left(gb) < 64*8)\n            return AVERROR_INVALIDDATA;\n        \n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n\n    next_start_code_studio(gb);\n    return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint yr_re_fast_exec(\n    uint8_t* code,\n    uint8_t* input_data,\n    size_t input_forwards_size,\n    size_t input_backwards_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args)\n{\n  RE_REPEAT_ANY_ARGS* repeat_any_args;\n\n  uint8_t* code_stack[MAX_FAST_RE_STACK];\n  uint8_t* input_stack[MAX_FAST_RE_STACK];\n  int matches_stack[MAX_FAST_RE_STACK];\n\n  uint8_t* ip = code;\n  uint8_t* input = input_data;\n  uint8_t* next_input;\n  uint8_t* next_opcode;\n  uint8_t mask;\n  uint8_t value;\n\n  int i;\n  int stop;\n  int input_incr;\n  int sp = 0;\n  int bytes_matched;\n  int max_bytes_matched;\n\n  max_bytes_matched = flags & RE_FLAGS_BACKWARDS ?\n      input_backwards_size :\n      input_forwards_size;\n\n  input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;\n\n  if (flags & RE_FLAGS_BACKWARDS)\n    input--;\n\n  code_stack[sp] = code;\n  input_stack[sp] = input;\n  matches_stack[sp] = 0;\n  sp++;\n\n  while (sp > 0)\n  {\n    sp--;\n    ip = code_stack[sp];\n    input = input_stack[sp];\n    bytes_matched = matches_stack[sp];\n    stop = FALSE;\n\n    while(!stop)\n    {\n      if (*ip == RE_OPCODE_MATCH)\n      {\n        if (flags & RE_FLAGS_EXHAUSTIVE)\n        {\n          int cb_result = callback(\n             flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data,\n             bytes_matched,\n             flags,\n             callback_args);\n\n          switch(cb_result)\n          {\n            case ERROR_INSUFFICIENT_MEMORY:\n              return -2;\n            case ERROR_TOO_MANY_MATCHES:\n              return -3;\n            default:\n              if (cb_result != ERROR_SUCCESS)\n                return -4;\n          }\n\n          break;\n        }\n        else\n        {\n          return bytes_matched;\n        }\n      }\n\n      if (bytes_matched >= max_bytes_matched)\n        break;\n\n      switch(*ip)\n      {\n        case RE_OPCODE_LITERAL:\n\n          if (*input == *(ip + 1))\n          {\n            bytes_matched++;\n            input += input_incr;\n            ip += 2;\n          }\n          else\n          {\n            stop = TRUE;\n          }\n\n          break;\n\n        case RE_OPCODE_MASKED_LITERAL:\n\n          value = *(int16_t*)(ip + 1) & 0xFF;\n          mask = *(int16_t*)(ip + 1) >> 8;\n\n          if ((*input & mask) == value)\n          {\n            bytes_matched++;\n            input += input_incr;\n            ip += 3;\n          }\n          else\n          {\n            stop = TRUE;\n          }\n\n          break;\n\n        case RE_OPCODE_ANY:\n\n          bytes_matched++;\n          input += input_incr;\n          ip += 1;\n\n          break;\n\n        case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n\n          repeat_any_args = (RE_REPEAT_ANY_ARGS*)(ip + 1);\n          next_opcode = ip + 1 + sizeof(RE_REPEAT_ANY_ARGS);\n\n          for (i = repeat_any_args->min + 1; i <= repeat_any_args->max; i++)\n          {\n            next_input = input + i * input_incr;\n\n            if (bytes_matched + i >= max_bytes_matched)\n              break;\n\n            if ( *(next_opcode) != RE_OPCODE_LITERAL ||\n                (*(next_opcode) == RE_OPCODE_LITERAL &&\n                 *(next_opcode + 1) == *next_input))\n            {\n              if (sp >= MAX_FAST_RE_STACK)\n                return -4;\n\n              code_stack[sp] = next_opcode;\n              input_stack[sp] = next_input;\n              matches_stack[sp] = bytes_matched + i;\n              sp++;\n            }\n          }\n\n          input += input_incr * repeat_any_args->min;\n          bytes_matched += repeat_any_args->min;\n          ip = next_opcode;\n\n          break;\n\n        default:\n          assert(FALSE);\n      }\n    }\n  }\n\n  return -1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tsize_t copied;\n\tunsigned char *asmptr;\n\tstruct sk_buff *skb;\n\tint n, er, qbit;\n\n\t\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\n\t\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)\n\t\treturn er;\n\n\tqbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\n\tskb_pull(skb, ROSE_MIN_LEN);\n\n\tif (rose->qbitincl) {\n\t\tasmptr  = skb_push(skb, 1);\n\t\t*asmptr = qbit;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_rose *srose;\n\n\t\tmemset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));\n\t\tsrose = msg->msg_name;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tif (msg->msg_namelen >= sizeof(struct full_sockaddr_rose)) {\n\t\t\tstruct full_sockaddr_rose *full_srose = (struct full_sockaddr_rose *)msg->msg_name;\n\t\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\t\tfull_srose->srose_digis[n] = rose->dest_digis[n];\n\t\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_rose);\n\t\t} else {\n\t\t\tif (rose->dest_ndigis >= 1) {\n\t\t\t\tsrose->srose_ndigis = 1;\n\t\t\t\tsrose->srose_digi = rose->dest_digis[0];\n\t\t\t}\n\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_rose);\n\t\t}\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\treturn copied;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\n\thwc->state = !(flags & PERF_EF_START);\n\n\thead = find_swevent_head(swhash, event);\n\tif (!head) {\n\t\t\n\t\tWARN_ON_ONCE(swhash->online);\n\t\treturn -EINVAL;\n\t}\n\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nrdp_protocol_error(const char *message, STREAM s)\n{\n\tlogger(Protocol, Error, \"%s(), %s\", __func__, message);\n\tif (s)\n\t\thexdump(s->p, s_length(s));\n\texit(0);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid kwajd_open_test_01() {\n    struct mskwaj_decompressor *kwajd;\n    struct mskwajd_header *hdr;\n\n    kwajd = mspack_create_kwaj_decompressor(NULL);\n    TEST(kwajd != NULL);\n\n    hdr = kwajd->open(kwajd, \"test_files/kwajd/f00.kwj\");\n    TEST(hdr != NULL);\n    TEST(hdr->filename == NULL);\n    kwajd->close(kwajd, hdr);\n\n#define TEST_FNAME(testfile, fname)      \\\n    hdr = kwajd->open(kwajd, testfile);  \\\n    TEST(hdr != NULL);                   \\\n    TEST(hdr->filename != NULL);         \\\n    TEST(!strcmp(fname, hdr->filename)); \\\n    kwajd->close(kwajd, hdr)\n#define TEST_FNAME_BAD(testfile)         \\\n    hdr = kwajd->open(kwajd, testfile);  \\\n    TEST(hdr == NULL);                   \\\n    TEST(kwajd->last_error(kwajd) == MSPACK_ERR_DATAFORMAT)\n\n    TEST_FNAME(\"test_files/kwajd/f01.kwj\", \".1\");\n    TEST_FNAME(\"test_files/kwajd/f02.kwj\", \".12\");\n    TEST_FNAME(\"test_files/kwajd/f03.kwj\", \".123\");\n\n    TEST_FNAME(\"test_files/kwajd/f10.kwj\", \"1\");\n    TEST_FNAME(\"test_files/kwajd/f11.kwj\", \"1.1\");\n    TEST_FNAME(\"test_files/kwajd/f12.kwj\", \"1.12\");\n    TEST_FNAME(\"test_files/kwajd/f13.kwj\", \"1.123\");\n\n    TEST_FNAME(\"test_files/kwajd/f20.kwj\", \"12\");\n    TEST_FNAME(\"test_files/kwajd/f21.kwj\", \"12.1\");\n    TEST_FNAME(\"test_files/kwajd/f22.kwj\", \"12.12\");\n    TEST_FNAME(\"test_files/kwajd/f23.kwj\", \"12.123\");\n\n    TEST_FNAME(\"test_files/kwajd/f30.kwj\", \"123\");\n    TEST_FNAME(\"test_files/kwajd/f31.kwj\", \"123.1\");\n    TEST_FNAME(\"test_files/kwajd/f32.kwj\", \"123.12\");\n    TEST_FNAME(\"test_files/kwajd/f33.kwj\", \"123.123\");\n\n    TEST_FNAME(\"test_files/kwajd/f40.kwj\", \"1234\");\n    TEST_FNAME(\"test_files/kwajd/f41.kwj\", \"1234.1\");\n    TEST_FNAME(\"test_files/kwajd/f42.kwj\", \"1234.12\");\n    TEST_FNAME(\"test_files/kwajd/f43.kwj\", \"1234.123\");\n\n    TEST_FNAME(\"test_files/kwajd/f50.kwj\", \"12345\");\n    TEST_FNAME(\"test_files/kwajd/f51.kwj\", \"12345.1\");\n    TEST_FNAME(\"test_files/kwajd/f52.kwj\", \"12345.12\");\n    TEST_FNAME(\"test_files/kwajd/f53.kwj\", \"12345.123\");\n\n    TEST_FNAME(\"test_files/kwajd/f60.kwj\", \"123456\");\n    TEST_FNAME(\"test_files/kwajd/f61.kwj\", \"123456.1\");\n    TEST_FNAME(\"test_files/kwajd/f62.kwj\", \"123456.12\");\n    TEST_FNAME(\"test_files/kwajd/f63.kwj\", \"123456.123\");\n\n    TEST_FNAME(\"test_files/kwajd/f70.kwj\", \"1234567\");\n    TEST_FNAME(\"test_files/kwajd/f71.kwj\", \"1234567.1\");\n    TEST_FNAME(\"test_files/kwajd/f72.kwj\", \"1234567.12\");\n    TEST_FNAME(\"test_files/kwajd/f73.kwj\", \"1234567.123\");\n\n    TEST_FNAME(\"test_files/kwajd/f80.kwj\", \"12345678\");\n    TEST_FNAME(\"test_files/kwajd/f81.kwj\", \"12345678.1\");\n    TEST_FNAME(\"test_files/kwajd/f82.kwj\", \"12345678.12\");\n    TEST_FNAME(\"test_files/kwajd/f83.kwj\", \"12345678.123\");\n\n    TEST_FNAME_BAD(\"test_files/kwajd/f04.kwj\");\n    TEST_FNAME_BAD(\"test_files/kwajd/f14.kwj\");\n    TEST_FNAME_BAD(\"test_files/kwajd/f24.kwj\");\n    TEST_FNAME_BAD(\"test_files/kwajd/f34.kwj\");\n    TEST_FNAME_BAD(\"test_files/kwajd/f44.kwj\");\n    TEST_FNAME_BAD(\"test_files/kwajd/f54.kwj\");\n    TEST_FNAME_BAD(\"test_files/kwajd/f64.kwj\");\n    TEST_FNAME_BAD(\"test_files/kwajd/f74.kwj\");\n    TEST_FNAME_BAD(\"test_files/kwajd/f84.kwj\");\n\n    TEST_FNAME_BAD(\"test_files/kwajd/f90.kwj\");\n    TEST_FNAME_BAD(\"test_files/kwajd/f91.kwj\");\n    TEST_FNAME_BAD(\"test_files/kwajd/f92.kwj\");\n    TEST_FNAME_BAD(\"test_files/kwajd/f93.kwj\");\n    TEST_FNAME_BAD(\"test_files/kwajd/f94.kwj\");\n\n\n    mspack_destroy_kwaj_decompressor(kwajd);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid TightDecoder::FilterGradient(const rdr::U8* inbuf,\n                                  const PixelFormat& pf, PIXEL_T* outbuf,\n                                  int stride, const Rect& r)\n{\n  int x, y, c;\n  static rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  static rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n\n  memset(prevRow, 0, sizeof(prevRow));\n\n   int rectHeight = r.height();\n  int rectWidth = r.width();\n\n  for (y = 0; y < rectHeight; y++) {\n    \n    pf.rgbFromBuffer(pix, &inbuf[y*rectWidth], 1);\n    for (c = 0; c < 3; c++)\n      pix[c] += prevRow[c];\n\n    memcpy(thisRow, pix, sizeof(pix));\n\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n\n    \n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 255) {\n          est[c] = 255;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n      }\n\n      pf.rgbFromBuffer(pix, &inbuf[y*rectWidth+x], 1);\n      for (c = 0; c < 3; c++)\n        pix[c] += est[c];\n\n      memcpy(&thisRow[x*3], pix, sizeof(pix));\n\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\t\t\tpmd_t *pmd, unsigned int flags)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = flags & FAULT_FLAG_WRITE;\n\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_chunk_trans_blocks(inode,\n\t\t\t\t\t\t\tPMD_SIZE / PAGE_SIZE));\n\t}\n\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_pmd_fault(vma, addr, pmd, flags,\n\t\t\t\text4_get_block_dax, ext4_end_io_unwritten);\n\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\n\treturn result;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(file->name, d, len);\n\t\t\tfile->namelen = len;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n}\n\nvoid print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)\n{\n\tu32 i, count;\n\n\tcount =  gf_isom_get_udta_count(file, track_number);\n\tif (!count) return;\n\n\tif (has_itags) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 type;\n\t\t\tbin128 uuid;\n\t\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\t\tif (type == GF_ISOM_BOX_TYPE_META) {\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!count) return;\n\t}\n\n\tfprintf(stderr, \"%d UDTA types: \", count);\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t%s\\n\", (char *) udta);\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n    int pos() { return ptr - start; }\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tshm_rmid(ns, shp);\n\tshm_unlock(shp);\n\tif (!is_file_hugepages(shp->shm_file))\n\t\tshmem_lock(shp->shm_file, 0, shp->mlock_user);\n\telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shp->shm_file)->i_size,\n\t\t\t\t\t\tshp->mlock_user);\n\tfput (shp->shm_file);\n\tipc_rcu_putref(shp, shm_rcu_free);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTEST_CASE_METHOD(TestFixture, \"ECDSA AES keygen and signature test\", \"[ecdsa-aes-key-sig-gen]\") {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encrPrivKey(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n\n    uint64_t encLen = 0;\n    PRINT_SRC_LINE\n    auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,\n                                             pubKeyX.data(),\n                                             pubKeyY.data());\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    string hex = SAMPLE_HEX_HASH;\n    vector<char> signatureR(BUF_LEN, 0);\n    vector<char> signatureS(BUF_LEN, 0);\n    uint8_t signatureV = 0;\n\n\n    for (int i = 0; i < 50; i++) {\n        PRINT_SRC_LINE\n        status = trustedEcdsaSignAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), encLen,\n                                     hex.data(),\n                                     signatureR.data(),\n                                     signatureS.data(), &signatureV, 16);\n        REQUIRE(status == SGX_SUCCESS);\n        REQUIRE(errStatus == SGX_SUCCESS);\n    }\n\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n\n  OpData* data = static_cast<OpData*>(node->user_data);\n  auto* params = reinterpret_cast<TfLiteAddParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_STATUS(\n      CalculateOpData(context, params, input1, input2, output, data));\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                      int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                      int *nb_prev_pkt, uint8_t hdr)\n{\n\n    uint8_t buf[16];\n    int channel_id, timestamp, size;\n    uint32_t ts_field;    uint32_t extra = 0;\n    enum RTMPPacketType type;\n    int written = 0;\n    int ret, toread;\n    RTMPPacket *prev_pkt;\n\n    written++;\n    channel_id = hdr & 0x3F;\n\n    if (channel_id < 2) {        buf[1] = 0;\n        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n            return AVERROR(EIO);\n        written += channel_id + 1;\n        channel_id = AV_RL16(buf) + 64;\n    }\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         channel_id)) < 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n    size  = prev_pkt[channel_id].size;\n    type  = prev_pkt[channel_id].type;\n    extra = prev_pkt[channel_id].extra;\n\n    hdr >>= 6;    if (hdr == RTMP_PS_ONEBYTE) {\n        ts_field = prev_pkt[channel_id].ts_field;\n    } else {\n        if (ffurl_read_complete(h, buf, 3) != 3)\n            return AVERROR(EIO);\n        written += 3;\n        ts_field = AV_RB24(buf);\n        if (hdr != RTMP_PS_FOURBYTES) {\n            if (ffurl_read_complete(h, buf, 3) != 3)\n                return AVERROR(EIO);\n            written += 3;\n            size = AV_RB24(buf);\n            if (ffurl_read_complete(h, buf, 1) != 1)\n                return AVERROR(EIO);\n            written++;\n            type = buf[0];\n            if (hdr == RTMP_PS_TWELVEBYTES) {\n                if (ffurl_read_complete(h, buf, 4) != 4)\n                    return AVERROR(EIO);\n                written += 4;\n                extra = AV_RL32(buf);\n            }\n        }\n    }\n    if (ts_field == 0xFFFFFF) {\n        if (ffurl_read_complete(h, buf, 4) != 4)\n            return AVERROR(EIO);\n        timestamp = AV_RB32(buf);\n    } else {\n        timestamp = ts_field;\n    }\n    if (hdr != RTMP_PS_TWELVEBYTES)\n        timestamp += prev_pkt[channel_id].timestamp;\n\n    if (prev_pkt[channel_id].read && size != prev_pkt[channel_id].size) {\n        av_log(NULL, AV_LOG_ERROR, \"RTMP packet size mismatch %d != %d\\n\",\n                size,\n                prev_pkt[channel_id].size);\n        ff_rtmp_packet_destroy(&prev_pkt[channel_id]);\n        prev_pkt[channel_id].read = 0;\n    }\n\n    if (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) < 0)\n            return ret;\n        p->read = written;\n        p->offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n    } else {\n               RTMPPacket *prev = &prev_pkt[channel_id];\n        p->data          = prev->data;\n        p->size          = prev->size;\n        p->channel_id    = prev->channel_id;\n        p->type          = prev->type;\n        p->ts_field      = prev->ts_field;\n        p->extra         = prev->extra;\n        p->offset        = prev->offset;\n        p->read          = prev->read + written;\n        p->timestamp     = prev->timestamp;\n        prev->data       = NULL;\n    }\n    p->extra = extra;\n       prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].size       = size;\n    prev_pkt[channel_id].extra      = extra;\n    size = size - p->offset;\n\n    toread = FFMIN(size, chunk_size);\n    if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    }\n    size      -= toread;\n    p->read   += toread;\n    p->offset += toread;\n\n    if (size > 0) {\n       RTMPPacket *prev = &prev_pkt[channel_id];\n       prev->data = p->data;\n       prev->read = p->read;\n       prev->offset = p->offset;\n       p->data      = NULL;\n       return AVERROR(EAGAIN);\n    }\n\n    prev_pkt[channel_id].read = 0;    return p->read;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\neap_print(netdissect_options *ndo,\n          register const u_char *cp,\n          u_int length)\n{\n    const struct eap_frame_t *eap;\n    const u_char *tptr;\n    u_int tlen, type, subtype;\n    int count=0, len;\n\n    tptr = cp;\n    tlen = length;\n    eap = (const struct eap_frame_t *)cp;\n    ND_TCHECK(*eap);\n\n    \n    if (ndo->ndo_vflag < 1) {\n\tND_PRINT((ndo, \"%s (%u) v%u, len %u\",\n               tok2str(eap_frame_type_values, \"unknown\", eap->type),\n               eap->type,\n               eap->version,\n               EXTRACT_16BITS(eap->length)));\n\treturn;\n    }\n\n    ND_PRINT((ndo, \"%s (%u) v%u, len %u\",\n           tok2str(eap_frame_type_values, \"unknown\", eap->type),\n           eap->type,\n           eap->version,\n           EXTRACT_16BITS(eap->length)));\n\n    tptr += sizeof(const struct eap_frame_t);\n    tlen -= sizeof(const struct eap_frame_t);\n\n    switch (eap->type) {\n    case EAP_FRAME_TYPE_PACKET:\n        ND_TCHECK_8BITS(tptr);\n        type = *(tptr);\n        ND_TCHECK_16BITS(tptr+2);\n        len = EXTRACT_16BITS(tptr+2);\n        ND_PRINT((ndo, \", %s (%u), id %u, len %u\",\n               tok2str(eap_code_values, \"unknown\", type),\n               type,\n               *(tptr+1),\n               len));\n\n        ND_TCHECK2(*tptr, len);\n\n        if (type <= 2) { \n            ND_TCHECK_8BITS(tptr+4);\n            subtype = *(tptr+4);\n            ND_PRINT((ndo, \"\\n\\t\\t Type %s (%u)\",\n                   tok2str(eap_type_values, \"unknown\", subtype),\n                   subtype));\n\n            switch (subtype) {\n            case EAP_TYPE_IDENTITY:\n                if (len - 5 > 0) {\n                    ND_PRINT((ndo, \", Identity: \"));\n                    safeputs(ndo, tptr + 5, len - 5);\n                }\n                break;\n\n            case EAP_TYPE_NOTIFICATION:\n                if (len - 5 > 0) {\n                    ND_PRINT((ndo, \", Notification: \"));\n                    safeputs(ndo, tptr + 5, len - 5);\n                }\n                break;\n\n            case EAP_TYPE_NAK:\n                count = 5;\n\n                \n                while (count < len) {\n                    ND_TCHECK_8BITS(tptr+count);\n                    ND_PRINT((ndo, \" %s (%u),\",\n                           tok2str(eap_type_values, \"unknown\", *(tptr+count)),\n                           *(tptr + count)));\n                    count++;\n                }\n                break;\n\n            case EAP_TYPE_TTLS:\n            case EAP_TYPE_TLS:\n                ND_TCHECK_8BITS(tptr + 5);\n                if (subtype == EAP_TYPE_TTLS)\n                    ND_PRINT((ndo, \" TTLSv%u\",\n                           EAP_TTLS_VERSION(*(tptr + 5))));\n                ND_PRINT((ndo, \" flags [%s] 0x%02x,\",\n                       bittok2str(eap_tls_flags_values, \"none\", *(tptr+5)),\n                       *(tptr + 5)));\n\n                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {\n                    ND_TCHECK_32BITS(tptr + 6);\n\t\t    ND_PRINT((ndo, \" len %u\", EXTRACT_32BITS(tptr + 6)));\n                }\n                break;\n\n            case EAP_TYPE_FAST:\n                ND_TCHECK_8BITS(tptr + 5);\n                ND_PRINT((ndo, \" FASTv%u\",\n                       EAP_TTLS_VERSION(*(tptr + 5))));\n                ND_PRINT((ndo, \" flags [%s] 0x%02x,\",\n                       bittok2str(eap_tls_flags_values, \"none\", *(tptr+5)),\n                       *(tptr + 5)));\n\n                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {\n                    ND_TCHECK_32BITS(tptr + 6);\n                    ND_PRINT((ndo, \" len %u\", EXTRACT_32BITS(tptr + 6)));\n                }\n\n                \n                break;\n\n            case EAP_TYPE_AKA:\n            case EAP_TYPE_SIM:\n                ND_TCHECK_8BITS(tptr + 5);\n                ND_PRINT((ndo, \" subtype [%s] 0x%02x,\",\n                       tok2str(eap_aka_subtype_values, \"unknown\", *(tptr+5)),\n                       *(tptr + 5)));\n\n                \n                break;\n\n            case EAP_TYPE_MD5_CHALLENGE:\n            case EAP_TYPE_OTP:\n            case EAP_TYPE_GTC:\n            case EAP_TYPE_EXPANDED_TYPES:\n            case EAP_TYPE_EXPERIMENTAL:\n            default:\n                break;\n            }\n        }\n        break;\n\n    case EAP_FRAME_TYPE_LOGOFF:\n    case EAP_FRAME_TYPE_ENCAP_ASF_ALERT:\n    default:\n        break;\n    }\n    return;\n\n trunc:\n    ND_PRINT((ndo, \"\\n\\t[|EAP]\"));\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct Context *ctx = (struct Context *) data;\n  if (!ctx)\n    return -1;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  if (!pop_data)\n    return -1;\n\n#ifdef USE_HCACHE\n  \n  if (strcmp(HC_FNAME \".\" HC_FEXT, id) == 0)\n    return 0;\n#endif\n\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    \n    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))\n      return 0;\n  }\n\n  \n  return mutt_bcache_del(bcache, cache_id(id));\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void finish_object(struct object *obj,\n\t\t\t  struct strbuf *path, const char *name,\n\t\t\t  void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tif (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))\n\t\tdie(\"missing blob object '%s'\", oid_to_hex(&obj->oid));\n\tif (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)\n\t\tparse_object(obj->oid.hash);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmcs_recv_connect_response(STREAM mcs_data)\n{\n\tUNUSED(mcs_data);\n\tuint8 result;\n\tuint32 length;\n\tSTREAM s;\n\tstruct stream packet;\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\t\n\tpacket = *s;\n\n\tber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\n\n\tber_parse_header(s, BER_TAG_RESULT, &length);\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);\n\t\treturn False;\n\t}\n\n\tber_parse_header(s, BER_TAG_INTEGER, &length);\n\tin_uint8s(s, length);\t\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\trdp_protocol_error(\"mcs_recv_connect_response(), consume connect id from stream would overrun\", &packet);\n\t}\n\n\tmcs_parse_domain_params(s);\n\n\tber_parse_header(s, BER_TAG_OCTET_STRING, &length);\n\n\tsec_process_mcs_data(s);\n\t\n\treturn s_check_end(s);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic irqreturn_t i8042_interrupt(int irq, void *dev_id)\n{\n\tstruct i8042_port *port;\n\tstruct serio *serio;\n\tunsigned long flags;\n\tunsigned char str, data;\n\tunsigned int dfl;\n\tunsigned int port_no;\n\tbool filtered;\n\tint ret = 1;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tstr = i8042_read_status();\n\tif (unlikely(~str & I8042_STR_OBF)) {\n\t\tspin_unlock_irqrestore(&i8042_lock, flags);\n\t\tif (irq)\n\t\t\tdbg(\"Interrupt %d, without any data\\n\", irq);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdata = i8042_read_data();\n\n\tif (i8042_mux_present && (str & I8042_STR_AUXDATA)) {\n\t\tstatic unsigned long last_transmit;\n\t\tstatic unsigned char last_str;\n\n\t\tdfl = 0;\n\t\tif (str & I8042_STR_MUXERR) {\n\t\t\tdbg(\"MUX error, status is %02x, data is %02x\\n\",\n\t\t\t    str, data);\n\n\n\t\t\tswitch (data) {\n\t\t\t\tdefault:\n\t\t\t\t\tif (time_before(jiffies, last_transmit + HZ/10)) {\n\t\t\t\t\t\tstr = last_str;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tcase 0xfc:\n\t\t\t\tcase 0xfd:\n\t\t\t\tcase 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break;\n\t\t\t\tcase 0xff: dfl = SERIO_PARITY;  data = 0xfe; break;\n\t\t\t}\n\t\t}\n\n\t\tport_no = I8042_MUX_PORT_NO + ((str >> 6) & 3);\n\t\tlast_str = str;\n\t\tlast_transmit = jiffies;\n\t} else {\n\n\t\tdfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |\n\t\t      ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);\n\n\t\tport_no = (str & I8042_STR_AUXDATA) ?\n\t\t\t\tI8042_AUX_PORT_NO : I8042_KBD_PORT_NO;\n\t}\n\n\tport = &i8042_ports[port_no];\n\tserio = port->exists ? port->serio : NULL;\n\n\tfilter_dbg(port->driver_bound, data, \"<- i8042 (interrupt, %d, %d%s%s)\\n\",\n\t\t   port_no, irq,\n\t\t   dfl & SERIO_PARITY ? \", bad parity\" : \"\",\n\t\t   dfl & SERIO_TIMEOUT ? \", timeout\" : \"\");\n\n\tfiltered = i8042_filter(data, str, serio);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (likely(port->exists && !filtered))\n\t\tserio_interrupt(serio, data, dfl);\n\n out:\n\treturn IRQ_RETVAL(ret);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ndecode_unicode_with_escapes(struct compiling *c, const node *n, const char *s,\n                            size_t len)\n{\n    PyObject *v, *u;\n    char *buf;\n    char *p;\n    const char *end;\n    const char *first_invalid_escape;\n\n    \n    if (len > SIZE_MAX / 6)\n        return NULL;\n    \n    u = PyBytes_FromStringAndSize((char *)NULL, len * 6);\n    if (u == NULL)\n        return NULL;\n    p = buf = PyBytes_AsString(u);\n    end = s + len;\n    while (s < end) {\n        if (*s == '\\\\') {\n            *p++ = *s++;\n            if (s >= end || *s & 0x80) {\n                strcpy(p, \"u005c\");\n                p += 5;\n                if (s >= end)\n                    break;\n            }\n        }\n        if (*s & 0x80) { \n            PyObject *w;\n            int kind;\n            void *data;\n            Py_ssize_t len, i;\n            w = decode_utf8(c, &s, end);\n            if (w == NULL) {\n                Py_DECREF(u);\n                return NULL;\n            }\n            kind = PyUnicode_KIND(w);\n            data = PyUnicode_DATA(w);\n            len = PyUnicode_GET_LENGTH(w);\n            for (i = 0; i < len; i++) {\n                Py_UCS4 chr = PyUnicode_READ(kind, data, i);\n                sprintf(p, \"\\\\U%08x\", chr);\n                p += 10;\n            }\n            \n            assert(p - buf <= PyBytes_GET_SIZE(u));\n            Py_DECREF(w);\n        } else {\n            *p++ = *s++;\n        }\n    }\n    len = p - buf;\n    s = buf;\n\n    v = _PyUnicode_DecodeUnicodeEscape(s, len, NULL, &first_invalid_escape);\n\n    if (v != NULL && first_invalid_escape != NULL) {\n        if (warn_invalid_escape_sequence(c, n, *first_invalid_escape) < 0) {\n            \n            Py_XDECREF(u);\n            Py_DECREF(v);\n            return NULL;\n        }\n    }\n    Py_XDECREF(u);\n    return v;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;\n\tsize_t copied;\n\tint qbit, header_len;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\tif (x25->neighbour == NULL)\n\t\tgoto out;\n\n\theader_len = x25->neighbour->extended ?\n\t\tX25_EXT_MIN_LEN : X25_STD_MIN_LEN;\n\n\t\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\n\tif (flags & MSG_OOB) {\n\t\trc = -EINVAL;\n\t\tif (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t    !skb_peek(&x25->interrupt_in_queue))\n\t\t\tgoto out;\n\n\t\tskb = skb_dequeue(&x25->interrupt_in_queue);\n\n\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\n\t\t\tgoto out_free_dgram;\n\n\t\tskb_pull(skb, X25_STD_MIN_LEN);\n\n\t\t\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = 0x00;\n\t\t}\n\n\t\tmsg->msg_flags |= MSG_OOB;\n\t} else {\n\t\t\n\t\trelease_sock(sk);\n\t\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\t\tlock_sock(sk);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tif (!pskb_may_pull(skb, header_len))\n\t\t\tgoto out_free_dgram;\n\n\t\tqbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;\n\n\t\tskb_pull(skb, header_len);\n\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = qbit;\n\t\t}\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t\n\tmsg->msg_flags |= MSG_EOR;\n\n\trc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (rc)\n\t\tgoto out_free_dgram;\n\n\tif (sx25) {\n\t\tsx25->sx25_family = AF_X25;\n\t\tsx25->sx25_addr   = x25->dest_addr;\n\t}\n\n\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n\n\tx25_check_rbuf(sk);\n\trc = copied;\nout_free_dgram:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\tif (!timr->it_interval)\n\t\treturn;\n\n\ttimr->it_overrun += hrtimer_forward(timer, timer->base->get_time(),\n\t\t\t\t\t    timr->it_interval);\n\thrtimer_restart(timer);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int mptctl_do_reset(unsigned long arg)\n{\n\tstruct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg;\n\tstruct mpt_ioctl_diag_reset krinfo;\n\tMPT_ADAPTER\t\t*iocp;\n\n\tif (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_do_reset - \"\n\t\t\t\t\"Unable to copy mpt_ioctl_diag_reset struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, urinfo);\n\t\treturn -EFAULT;\n\t}\n\n\tif (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s@%d::mptctl_do_reset - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, krinfo.hdr.iocnum);\n\t\treturn -ENODEV; \n\t}\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"mptctl_do_reset called.\\n\",\n\t    iocp->name));\n\n\tif (mpt_HardResetHandler(iocp, CAN_SLEEP) != 0) {\n\t\tprintk (MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_reset - reset failed.\\n\",\n\t\t\tiocp->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \"integral size %d is larger than limit of %d\",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  \n  }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint main()\n{\n    gdImagePtr im, clone;\n    int style[] = {0, 0, 0};\n\n    im = gdImageCreate(8, 8);\n    gdImageSetStyle(im, style, sizeof(style)/sizeof(style[0]));\n\n    clone = gdImageClone(im);\n    gdTestAssert(clone != NULL);\n\n    gdTestAssert(clone->styleLength == im->styleLength);\n    gdTestAssert(clone->stylePos == im->stylePos);\n    gdTestAssert(!memcmp(clone->style, im->style, sizeof(style)/sizeof(style[0])));\n\n    gdImageDestroy(clone);\n    gdImageDestroy(im);\n\n    return gdNumFailures();\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nMONGO_EXPORT void gridfile_write_buffer( gridfile *gfile, const char *data,\n        gridfs_offset length ) {\n\n    int bytes_left = 0;\n    int data_partial_len = 0;\n    int chunks_to_write = 0;\n    char *buffer;\n    bson *oChunk;\n    gridfs_offset to_write = length + gfile->pending_len;\n\n    if ( to_write < DEFAULT_CHUNK_SIZE ) { \n        if( gfile->pending_data ) {\n            gfile->pending_data = ( char * )bson_realloc( ( void * )gfile->pending_data, gfile->pending_len + to_write );\n            memcpy( gfile->pending_data + gfile->pending_len, data, length );\n        }\n        else if ( to_write > 0 ) {\n            gfile->pending_data = ( char * )bson_malloc( to_write );\n            memcpy( gfile->pending_data, data, length );\n        }\n        gfile->pending_len += length;\n\n    }\n    else {   \n        chunks_to_write = to_write / DEFAULT_CHUNK_SIZE;\n        bytes_left = to_write % DEFAULT_CHUNK_SIZE;\n\n        \n        if ( gfile->pending_len > 0 ) {\n            data_partial_len = DEFAULT_CHUNK_SIZE - gfile->pending_len;\n            buffer = ( char * )bson_malloc( DEFAULT_CHUNK_SIZE );\n            memcpy( buffer, gfile->pending_data, gfile->pending_len );\n            memcpy( buffer + gfile->pending_len, data, data_partial_len );\n\n            oChunk = chunk_new( gfile->id, gfile->chunk_num, buffer, DEFAULT_CHUNK_SIZE );\n            mongo_insert( gfile->gfs->client, gfile->gfs->chunks_ns, oChunk, NULL );\n            chunk_free( oChunk );\n            gfile->chunk_num++;\n            gfile->length += DEFAULT_CHUNK_SIZE;\n            data += data_partial_len;\n\n            chunks_to_write--;\n\n            bson_free( buffer );\n        }\n\n        while( chunks_to_write > 0 ) {\n            oChunk = chunk_new( gfile->id, gfile->chunk_num, data, DEFAULT_CHUNK_SIZE );\n            mongo_insert( gfile->gfs->client, gfile->gfs->chunks_ns, oChunk, NULL );\n            chunk_free( oChunk );\n            gfile->chunk_num++;\n            chunks_to_write--;\n            gfile->length += DEFAULT_CHUNK_SIZE;\n            data += DEFAULT_CHUNK_SIZE;\n        }\n\n        bson_free( gfile->pending_data );\n\n        \n        if( bytes_left == 0 )\n            gfile->pending_data = NULL;\n        else {\n            gfile->pending_data = ( char * )bson_malloc( bytes_left );\n            memcpy( gfile->pending_data, data, bytes_left );\n        }\n\n        gfile->pending_len = bytes_left;\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic char *mongo_data_append( char *start , const void *data , size_t len ) {\n    memcpy( start , data , len );\n    return start + len;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nFUNC_DECODER(dissector_postgresql)\n{\n   DECLARE_DISP_PTR(ptr);\n   struct ec_session *s = NULL;\n   void *ident = NULL;\n   char tmp[MAX_ASCII_ADDR_LEN];\n   struct postgresql_status *conn_status;\n\n   \n   (void) DECODE_DATA; \n   (void) DECODE_DATALEN;\n   (void) DECODED_LEN;\n   \n   if (FROM_CLIENT(\"postgresql\", PACKET)) {\n      if (PACKET->DATA.len < 4)\n         return NULL;\n\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      \n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {\n         \n         unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);\n         unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);\n         if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {\n            \n            dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));\n\n            \n            SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));\n\n            conn_status = (struct postgresql_status *) s->data;\n            conn_status->status = WAIT_AUTH;\n\n            \n            strncpy((char*)conn_status->user, (char*)(u + 5), 65);\n            conn_status->user[64] = 0;\n\n            \n            strncpy((char*)conn_status->database, (char*)(d + 9), 65);\n            conn_status->database[64] = 0;\n\n            \n            session_put(s);\n         }\n      } else {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_RESPONSE) {\n\n            \n            if (ptr[0] == 'p' && conn_status->type == MD5) {\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");\n               if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               if (PACKET->DATA.len < 40) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               memcpy(conn_status->hash, ptr + 5 + 3, 32);\n               conn_status->hash[32] = 0;\n               DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n            else if (ptr[0] == 'p' && conn_status->type == CT) {\n               int length;\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");\n               GET_ULONG_BE(length, ptr, 1);\n               length -= 4;\n               if (length < 0 || length > 65 || PACKET->DATA.len < length+5) {\n                   dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n                   return NULL;\n               }\n               snprintf((char*)conn_status->password, length+1, \"%s\", (char*)(ptr + 5));\n               DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n         }\n      }\n   } else { \n      if (PACKET->DATA.len < 9)\n         return NULL;\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {\n\n            conn_status->status = WAIT_RESPONSE;\n\n            conn_status->type = MD5;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");\n            hex_encode(ptr + 9, 4, conn_status->salt); \n         }\n         else if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {\n            conn_status->status = WAIT_RESPONSE;\n            conn_status->type = CT;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");\n         }\n      }\n   }\n\n   SAFE_FREE(ident);\n   return NULL;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nrdp_protocol_error(const char *message, STREAM s)\n{\n\tlogger(Protocol, Error, \"%s(), %s\", __func__, message);\n\tif (s)\n\t\thexdump(s->p, s_length(s));\n\texit(0);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  output->type = input->type;\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);\n  return context->ResizeTensor(context, output, output_size);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ngtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileContigRoutine put = img->put.contig;\n\tuint32 row, y, nrow, nrowsub, rowstoread;\n\ttmsize_t pos;\n\tunsigned char* buf = NULL;\n\tuint32 rowsperstrip;\n\tuint16 subsamplinghor,subsamplingver;\n\tuint32 imagewidth = img->width;\n\ttmsize_t scanline;\n\tint32 fromskew, toskew;\n\tint ret = 1, flip;\n        tmsize_t maxstripsize;\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);\n\tif( subsamplingver == 0 ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Invalid vertical YCbCr subsampling\");\n\t\treturn (0);\n\t}\n\t\n\tmaxstripsize = TIFFStripSize(tif);\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(w + w);\n\t} else {\n\t\ty = 0;\n\t\ttoskew = -(int32)(w - w);\n\t}\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\n\tscanline = TIFFScanlineSize(tif);\n\tfromskew = (w < imagewidth ? imagewidth - w : 0);\n\tfor (row = 0; row < h; row += nrow)\n\t{\n\t\tuint32 temp;\n\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\tnrowsub = nrow;\n\t\tif ((nrowsub%subsamplingver)!=0)\n\t\t\tnrowsub+=subsamplingver-nrowsub%subsamplingver;\n\t\ttemp = (row + img->row_offset)%rowsperstrip + nrowsub;\n\t\tif( scanline > 0 && temp > (size_t)(TIFF_TMSIZE_T_MAX / scanline) )\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Integer overflow in gtStripContig\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (_TIFFReadEncodedStripAndAllocBuffer(tif,\n\t\t    TIFFComputeStrip(tif,row+img->row_offset, 0),\n\t\t    (void**)(&buf),\n                    maxstripsize,\n\t\t    temp * scanline)==(tmsize_t)(-1)\n\t\t    && (buf == NULL || img->stoponerr))\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline + \\\n\t\t\t((tmsize_t) img->col_offset * img->samplesperpixel);\n\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos);\n\t\ty += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr || !rela) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")         ||  0==strcmp(symnam, \"__libc_init\")         ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nxd3_selftest (void)\n{\n#define DO_TEST(fn,flags,arg)                                         \\\n  do {                                                                \\\n    xd3_stream stream;                                                \\\n    xd3_config config;                                                \\\n    xd3_init_config (& config, flags);                                \\\n    XPR(NT \"testing \" #fn \"%s...\",                          \\\n             flags ? (\" (\" #flags \")\") : \"\");                         \\\n    if ((ret = xd3_config_stream (& stream, & config) == 0) &&        \\\n        (ret = test_ ## fn (& stream, arg)) == 0) {                   \\\n      XPR(NTR \" success\\n\");                                          \\\n    } else {                                                          \\\n      XPR(NTR \" failed: %s: %s\\n\", xd3_errstring (& stream),          \\\n               xd3_mainerror (ret)); }                                \\\n    xd3_free_stream (& stream);                                       \\\n    if (ret != 0) { goto failure; }                                   \\\n  } while (0)\n\n  int ret;\n  DO_TEST (random_numbers, 0, 0);\n\n  DO_TEST (decode_integer_end_of_input, 0, 0);\n  DO_TEST (decode_integer_overflow, 0, 0);\n  DO_TEST (encode_decode_uint32_t, 0, 0);\n  DO_TEST (encode_decode_uint64_t, 0, 0);\n  DO_TEST (usize_t_overflow, 0, 0);\n  DO_TEST (forward_match, 0, 0);\n\n  DO_TEST (address_cache, 0, 0);\n  IF_GENCODETBL (DO_TEST (address_cache, XD3_ALT_CODE_TABLE, 0));\n\n  DO_TEST (string_matching, 0, 0);\n  DO_TEST (choose_instruction, 0, 0);\n  DO_TEST (identical_behavior, 0, 0);\n  DO_TEST (in_memory, 0, 0);\n\n  IF_GENCODETBL (DO_TEST (choose_instruction, XD3_ALT_CODE_TABLE, 0));\n  IF_GENCODETBL (DO_TEST (encode_code_table, 0, 0));\n\n  DO_TEST (iopt_flush_instructions, 0, 0);\n  DO_TEST (source_cksum_offset, 0, 0);\n\n  DO_TEST (decompress_single_bit_error, 0, 3);\n  DO_TEST (decompress_single_bit_error, XD3_ADLER32, 3);\n\n  IF_LZMA (DO_TEST (decompress_single_bit_error, XD3_SEC_LZMA, 54));\n  IF_FGK (DO_TEST (decompress_single_bit_error, XD3_SEC_FGK, 3));\n  IF_DJW (DO_TEST (decompress_single_bit_error, XD3_SEC_DJW, 8));\n\n  \n  IF_GENCODETBL (\n\t DO_TEST (decompress_single_bit_error, XD3_ALT_CODE_TABLE, 224));\n\n#if SHELL_TESTS\n  DO_TEST (force_behavior, 0, 0);\n  DO_TEST (stdout_behavior, 0, 0);\n  DO_TEST (no_output, 0, 0);\n  DO_TEST (appheader, 0, 0);\n  DO_TEST (command_line_arguments, 0, 0);\n\n#if EXTERNAL_COMPRESSION\n  DO_TEST (source_decompression, 0, 0);\n  DO_TEST (externally_compressed_io, 0, 0);\n#endif\n\n  DO_TEST (recode_command, 0, 0);\n#endif\n\n  IF_LZMA (DO_TEST (secondary_lzma, 0, 1));\n  IF_DJW (DO_TEST (secondary_huff, 0, DJW_MAX_GROUPS));\n  IF_FGK (DO_TEST (secondary_fgk, 0, 1));\n\n  DO_TEST (compressed_stream_overflow, 0, 0);\n  IF_LZMA (DO_TEST (compressed_stream_overflow, XD3_SEC_LZMA, 0));\n\nfailure:\n  test_cleanup ();\n  return ret == 0 ? EXIT_SUCCESS : EXIT_FAILURE;\n#undef DO_TEST\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tbool ret =  __f2fs_init_extent_tree(inode, i_ext);\n\n\tif (!F2FS_I(inode)->extent_tree)\n\t\tset_inode_flag(inode, FI_NO_EXTENT);\n\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nchar *string_crypt(const char *key, const char *salt) {\n  assertx(key);\n  assertx(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,\"$1$\",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = '\\0';\n    return string_crypt(key, random_salt);\n  }\n\n  auto const saltLen = strlen(salt);\n  if ((saltLen > sizeof(\"$2X$00$\")) &&\n    (salt[0] == '$') &&\n    (salt[1] == '2') &&\n    (salt[2] >= 'a') && (salt[2] <= 'z') &&\n    (salt[3] == '$') &&\n    (salt[4] >= '0') && (salt[4] <= '3') &&\n    (salt[5] >= '0') && (salt[5] <= '9') &&\n    (salt[6] == '$')) {\n       char output[61];\n\n    static constexpr size_t maxSaltLength = 123;\n    char paddedSalt[maxSaltLength + 1];\n    paddedSalt[0] = paddedSalt[maxSaltLength] = '\\0';\n\n    memset(&paddedSalt[1], '$', maxSaltLength - 1);\n    memcpy(paddedSalt, salt, std::min(maxSaltLength, saltLen));\n    paddedSalt[saltLen] = '\\0';\n\n    if (php_crypt_blowfish_rn(key, paddedSalt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n   #ifdef USE_PHP_CRYPT_R\n    return php_crypt_r(key, salt);\n#else\n    static Mutex mutex;\n    Lock lock(mutex);\n    char *crypt_res = crypt(key,salt);\n\n    if (crypt_res) {\n      return strdup(crypt_res);\n    }\n#endif\n  }\n\n  return ((salt[0] == '*') && (salt[1] == '0'))\n                  ? strdup(\"*1\") : strdup(\"*0\");\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len;\n\tlong flags = ENT_COMPAT;\n\tchar *replaced;\n\tzend_bool double_encode = 1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!b\", &str, &str_len, &flags, &hint_charset, &hint_charset_len, &double_encode) == FAILURE) {\n\t\treturn;\n\t}\n\n\treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n\tif (new_len > INT_MAX) {\n\t\tefree(replaced);\n\t\tRETURN_FALSE;\n\t}\n\tRETVAL_STRINGL(replaced, (int)new_len, 0);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int f2fs_read_single_page(struct inode *inode, struct page *page,\n\t\t\t\t\tunsigned nr_pages,\n\t\t\t\t\tstruct f2fs_map_blocks *map,\n\t\t\t\t\tstruct bio **bio_ret,\n\t\t\t\t\tsector_t *last_block_in_bio,\n\t\t\t\t\tbool is_readahead)\n{\n\tstruct bio *bio = *bio_ret;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t block_nr;\n\tint ret = 0;\n\n\tblock_in_file = (sector_t)page_index(page);\n\tlast_block = block_in_file + nr_pages;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >>\n\t\t\t\t\t\t\tblkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\n\t\n\tif (block_in_file >= last_block)\n\t\tgoto zero_out;\n\t\n\tif ((map->m_flags & F2FS_MAP_MAPPED) &&\n\t\t\tblock_in_file > map->m_lblk &&\n\t\t\tblock_in_file < (map->m_lblk + map->m_len))\n\t\tgoto got_it;\n\n\t\n\tmap->m_lblk = block_in_file;\n\tmap->m_len = last_block - block_in_file;\n\n\tret = f2fs_map_blocks(inode, map, 0, F2FS_GET_BLOCK_DEFAULT);\n\tif (ret)\n\t\tgoto out;\ngot_it:\n\tif ((map->m_flags & F2FS_MAP_MAPPED)) {\n\t\tblock_nr = map->m_pblk + block_in_file - map->m_lblk;\n\t\tSetPageMappedToDisk(page);\n\n\t\tif (!PageUptodate(page) && (!PageSwapCache(page) &&\n\t\t\t\t\t!cleancache_get_page(page))) {\n\t\t\tSetPageUptodate(page);\n\t\t\tgoto confused;\n\t\t}\n\n\t\tif (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), block_nr,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE_READ)) {\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t} else {\nzero_out:\n\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\tif (!PageUptodate(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\n\t\n\tif (bio && (*last_block_in_bio != block_nr - 1 ||\n\t\t!__same_bdev(F2FS_I_SB(inode), block_nr, bio))) {\nsubmit_and_realloc:\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\t\tbio = NULL;\n\t}\n\tif (bio == NULL) {\n\t\tbio = f2fs_grab_read_bio(inode, block_nr, nr_pages,\n\t\t\t\tis_readahead ? REQ_RAHEAD : 0);\n\t\tif (IS_ERR(bio)) {\n\t\t\tret = PTR_ERR(bio);\n\t\t\tbio = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t\n\tf2fs_wait_on_block_writeback(inode, block_nr);\n\n\tif (bio_add_page(bio, page, blocksize, 0) < blocksize)\n\t\tgoto submit_and_realloc;\n\n\tinc_page_count(F2FS_I_SB(inode), F2FS_RD_DATA);\n\tClearPageError(page);\n\t*last_block_in_bio = block_nr;\n\tgoto out;\nconfused:\n\tif (bio) {\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\t\tbio = NULL;\n\t}\n\tunlock_page(page);\nout:\n\t*bio_ret = bio;\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n#else\n    static int input  (yyscan_t yyscanner)\n#endif\n\n{\n\tint c;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\n\tif ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t\n\t\tif ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t\n\t\t\t*yyg->yy_c_buf_p = '\\0';\n\n\t\telse\n\t\t\t{ \n\t\t\tyy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;\n\t\t\t++yyg->yy_c_buf_p;\n\n\t\t\tswitch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t\n\n\t\t\t\t\t\n\t\t\t\t\tre_yyrestart(yyin ,yyscanner);\n\n\t\t\t\t\t\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( re_yywrap(yyscanner ) )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput(yyscanner);\n#else\n\t\t\t\t\treturn input(yyscanner);\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) yyg->yy_c_buf_p;\t\n\t*yyg->yy_c_buf_p = '\\0';\t\n\tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n\n\tif ( c == '\\n' )\n\t\t\n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\n\treturn c;\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nVariant HHVM_FUNCTION(mcrypt_generic_init, const Resource& td,\n                                           const String& key,\n                                           const String& iv) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  int max_key_size = mcrypt_enc_get_key_size(pm->m_td);\n  int iv_size = mcrypt_enc_get_iv_size(pm->m_td);\n\n  if (key.empty()) {\n    raise_warning(\"Key size is 0\");\n  }\n\n  unsigned char *key_s = (unsigned char *)malloc(key.size());\n  memset(key_s, 0, key.size());\n\n  unsigned char *iv_s = (unsigned char *)malloc(iv_size + 1);\n  memset(iv_s, 0, iv_size + 1);\n\n  int key_size;\n  if (key.size() > max_key_size) {\n    raise_warning(\"Key size too large; supplied length: %d, max: %d\",\n                    key.size(), max_key_size);\n    key_size = max_key_size;\n  } else {\n    key_size = key.size();\n  }\n  memcpy(key_s, key.data(), key.size());\n\n  if (iv.size() != iv_size) {\n    raise_warning(\"Iv size incorrect; supplied length: %d, needed: %d\",\n                    iv.size(), iv_size);\n  }\n  memcpy(iv_s, iv.data(), std::min(iv_size, iv.size()));\n\n  mcrypt_generic_deinit(pm->m_td);\n  int result = mcrypt_generic_init(pm->m_td, key_s, key_size, iv_s);\n\n  \n  if (result < 0) {\n    pm->close();\n    switch (result) {\n    case -3:\n      raise_warning(\"Key length incorrect\");\n      break;\n    case -4:\n      raise_warning(\"Memory allocation error\");\n      break;\n    case -1:\n    default:\n      raise_warning(\"Unknown error\");\n      break;\n    }\n  } else {\n    pm->m_init = true;\n  }\n\n  free(iv_s);\n  free(key_s);\n  return result;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane] && src->linesize[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* cond;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &cond));\n  bool cond_value = cond->data.b[0];\n\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n\n     int active_branch_subgraph_index =\n      cond_value ? op_data->then_subgraph_index : op_data->else_subgraph_index;\n  Subgraph& active_branch_subgraph =\n      *(*subgraphs)[active_branch_subgraph_index];\n  for (int i = 0; i < active_branch_subgraph.inputs().size(); ++i) {\n    const TfLiteTensor* input;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i + 1, &input));\n    TfLiteTensor* subgraph_input =\n        active_branch_subgraph.tensor(active_branch_subgraph.inputs()[i]);\n    TF_LITE_ENSURE_EQ(context, input->bytes, subgraph_input->bytes);\n    memcpy(subgraph_input->data.raw, input->data.raw, input->bytes);\n  }\n\n    TF_LITE_ENSURE_OK(context, active_branch_subgraph.Invoke());\n\n  for (int tensor_index : active_branch_subgraph.outputs()) {\n    active_branch_subgraph.EnsureTensorDataIsReadable(tensor_index);\n  }\n\n  bool has_dynamic_output_tensors = false;\n  for (int i = 0; i < node->outputs->size; ++i) {\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    if (IsDynamicTensor(output)) {\n      has_dynamic_output_tensors = true;\n      break;\n    }\n  }\n\n  if (has_dynamic_output_tensors) {\n    for (int i = 0; i < node->outputs->size; ++i) {\n      TfLiteTensor* output;\n      TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n      TfLiteTensor* subgraph_output =\n          active_branch_subgraph.tensor(active_branch_subgraph.outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(subgraph_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n\n  for (int i = 0; i < active_branch_subgraph.outputs().size(); ++i) {\n    const TfLiteTensor* subgraph_output =\n        active_branch_subgraph.tensor(active_branch_subgraph.outputs()[i]);\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    TF_LITE_ENSURE_EQ(context, output->bytes, subgraph_output->bytes);\n    memcpy(output->data.raw, subgraph_output->data.raw, output->bytes);\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nR_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n\tattr->size = 6;\n\treturn attr;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic float *get_window(vorb *f, int len)\n{\n   len <<= 1;\n   if (len == f->blocksize_0) return f->window[0];\n   if (len == f->blocksize_1) return f->window[1];\n   assert(0);\n   return NULL;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                            UINT32 scanline)\n{\n\tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n\n\tif (context->ChromaSubsamplingLevel > 0)\n\t{\n\t\tnsc_encode_subsampling_sse2(context);\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nrdpsnd_process_training(STREAM in)\n{\n\tuint16 tick;\n\tuint16 packsize;\n\tSTREAM out;\n\tstruct stream packet = *in;\n\n\tif (!s_check_rem(in, 4))\n\t{\n\t\trdp_protocol_error(\"rdpsnd_process_training(), consume of training data from stream would overrun\", &packet);\n\t}\n\n\tin_uint16_le(in, tick);\n\tin_uint16_le(in, packsize);\n\n\tlogger(Sound, Debug, \"rdpsnd_process_training(), tick=0x%04x\", (unsigned) tick);\n\n\tout = rdpsnd_init_packet(SNDC_TRAINING, 4);\n\tout_uint16_le(out, tick);\n\tout_uint16_le(out, packsize);\n\ts_mark_end(out);\n\trdpsnd_send(out);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nl2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tif (length < 5) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\t\n\tND_PRINT((ndo, \"%04x, \", EXTRACT_16BITS(dat)));\n\tdat += 2;\n\tlength -= 2;\n\t\n\tND_PRINT((ndo, \"%04x \",  EXTRACT_16BITS(dat)));\n\tdat += 2;\n\tlength -= 2;\n\t\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_cc_direction2str,\n\t\t\t     \"Direction-#%u\", EXTRACT_8BITS(ptr))));\n\tptr++;\n\tlength--;\n\n\tif (length != 0) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length);\n\t}\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tbitmap_set(base, find_object_pos(object->oid.hash));\n\tmark_as_seen(object);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ngdImagePtr gdImageCreateTrueColor (int sx, int sy)\n{\n  int i;\n  gdImagePtr im;\n\n  if (overflow2(sx, sy)) {\n    return NULL;\n  }\n\n  if (overflow2(sizeof(unsigned char *), sy)) {\n    return NULL;\n  }\n\n  if (overflow2(sizeof(int) + sizeof(unsigned char), sx * sy)) {\n    return NULL;\n  }\n\n   auto allocsz = sizeof(gdImage)\n    + sy * (sizeof(int *) + sizeof(unsigned char *))\n    + sx * sy * (sizeof(int) + sizeof(unsigned char));\n  if (UNLIKELY(precheckOOM(allocsz))) {\n       return NULL;\n  }\n\n  im = (gdImage *) gdMalloc(sizeof(gdImage));\n  memset(im, 0, sizeof(gdImage));\n  im->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n  im->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n  im->polyInts = 0;\n  im->polyAllocated = 0;\n  im->brush = 0;\n  im->tile = 0;\n  im->style = 0;\n  for (i = 0; i < sy; i++) {\n    im->tpixels[i] = (int *) gdCalloc(sx, sizeof(int));\n    im->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n  }\n  im->sx = sx;\n  im->sy = sy;\n  im->transparent = (-1);\n  im->interlace = 0;\n  im->trueColor = 1;\n  \n  im->saveAlphaFlag = 0;\n  im->alphaBlendingFlag = 1;\n  im->thick = 1;\n  im->AA = 0;\n  im->AA_polygon = 0;\n  im->cx1 = 0;\n  im->cy1 = 0;\n  im->cx2 = im->sx - 1;\n  im->cy2 = im->sy - 1;\n  im->interpolation = NULL;\n  im->interpolation_id = GD_BILINEAR_FIXED;\n  return im;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast2obj_alias(void* _o)\n{\n    alias_ty o = (alias_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(alias_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->name);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_identifier(o->asname);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_asname, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsnmp_ber_decode_unsigned_integer(unsigned char *buf, uint32_t *buff_len, uint8_t expected_type, uint32_t *num)\n{\n  uint8_t i, len, type;\n\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n\n  if(buf == NULL || type != expected_type) {\n    \n    return NULL;\n  }\n\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n\n  if(buf == NULL || len > 4) {\n    \n    return NULL;\n  }\n\n  if(*buff_len < len) {\n    return NULL;\n  }\n\n  *num = (uint32_t)(*buf++ & 0xFF);\n  (*buff_len)--;\n  for(i = 1; i < len; ++i) {\n    *num <<= 8;\n    *num |= (uint8_t)(*buf++ & 0xFF);\n    (*buff_len)--;\n  }\n\n  return buf;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nevutil_parse_sockaddr_port(const char *ip_as_string, struct sockaddr *out, int *outlen)\n{\n\tint port;\n\tchar buf[128];\n\tconst char *cp, *addr_part, *port_part;\n\tint is_ipv6;\n\t\n\n\tcp = strchr(ip_as_string, ':');\n\tif (*ip_as_string == '[') {\n\t\tsize_t len;\n\t\tif (!(cp = strchr(ip_as_string, ']'))) {\n\t\t\treturn -1;\n\t\t}\n\t\tlen = ( cp-(ip_as_string + 1) );\n\t\tif (len > sizeof(buf)-1) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(buf, ip_as_string+1, len);\n\t\tbuf[len] = '\\0';\n\t\taddr_part = buf;\n\t\tif (cp[1] == ':')\n\t\t\tport_part = cp+2;\n\t\telse\n\t\t\tport_part = NULL;\n\t\tis_ipv6 = 1;\n\t} else if (cp && strchr(cp+1, ':')) {\n\t\tis_ipv6 = 1;\n\t\taddr_part = ip_as_string;\n\t\tport_part = NULL;\n\t} else if (cp) {\n\t\tis_ipv6 = 0;\n\t\tif (cp - ip_as_string > (int)sizeof(buf)-1) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(buf, ip_as_string, cp-ip_as_string);\n\t\tbuf[cp-ip_as_string] = '\\0';\n\t\taddr_part = buf;\n\t\tport_part = cp+1;\n\t} else {\n\t\taddr_part = ip_as_string;\n\t\tport_part = NULL;\n\t\tis_ipv6 = 0;\n\t}\n\n\tif (port_part == NULL) {\n\t\tport = 0;\n\t} else {\n\t\tport = atoi(port_part);\n\t\tif (port <= 0 || port > 65535) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!addr_part)\n\t\treturn -1; \n#ifdef AF_INET6\n\tif (is_ipv6)\n\t{\n\t\tstruct sockaddr_in6 sin6;\n\t\tmemset(&sin6, 0, sizeof(sin6));\n#ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN\n\t\tsin6.sin6_len = sizeof(sin6);\n#endif\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_port = htons(port);\n\t\tif (1 != evutil_inet_pton(AF_INET6, addr_part, &sin6.sin6_addr))\n\t\t\treturn -1;\n\t\tif ((int)sizeof(sin6) > *outlen)\n\t\t\treturn -1;\n\t\tmemset(out, 0, *outlen);\n\t\tmemcpy(out, &sin6, sizeof(sin6));\n\t\t*outlen = sizeof(sin6);\n\t\treturn 0;\n\t}\n\telse\n#endif\n\t{\n\t\tstruct sockaddr_in sin;\n\t\tmemset(&sin, 0, sizeof(sin));\n#ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n\t\tsin.sin_len = sizeof(sin);\n#endif\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = htons(port);\n\t\tif (1 != evutil_inet_pton(AF_INET, addr_part, &sin.sin_addr))\n\t\t\treturn -1;\n\t\tif ((int)sizeof(sin) > *outlen)\n\t\t\treturn -1;\n\t\tmemset(out, 0, *outlen);\n\t\tmemcpy(out, &sin, sizeof(sin));\n\t\t*outlen = sizeof(sin);\n\t\treturn 0;\n\t}\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n\t\t   struct sockaddr_storage *kern_address, int mode)\n{\n\tint tot_len;\n\n\tif (kern_msg->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tint err = move_addr_to_kernel(kern_msg->msg_name,\n\t\t\t\t\t\t      kern_msg->msg_namelen,\n\t\t\t\t\t\t      kern_address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tkern_msg->msg_name = kern_address;\n\t} else\n\t\tkern_msg->msg_name = NULL;\n\n\ttot_len = iov_from_user_compat_to_kern(kern_iov,\n\t\t\t\t\t  (struct compat_iovec __user *)kern_msg->msg_iov,\n\t\t\t\t\t  kern_msg->msg_iovlen);\n\tif (tot_len >= 0)\n\t\tkern_msg->msg_iov = kern_iov;\n\n\treturn tot_len;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int do_i2c_mw(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tuint\talen;\n\tuchar\tbyte;\n\tuint\tcount;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif ((argc < 4) || (argc > 5))\n\t\treturn CMD_RET_USAGE;\n\n\t\n\tchip = hextoul(argv[1], NULL);\n\n\t\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\t\n\tbyte = hextoul(argv[3], NULL);\n\n\t\n\tif (argc == 5)\n\t\tcount = hextoul(argv[4], NULL);\n\telse\n\t\tcount = 1;\n\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_write(dev, addr++, &byte, 1);\n#else\n\t\tret = i2c_write(chip, addr++, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\t\t\n\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\tudelay(11000);\n#endif\n\t}\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nskip_expr_concatenate(\n\tchar_u\t    **arg,\n\tchar_u\t    **start,\n\tchar_u\t    **end,\n\tevalarg_T   *evalarg)\n{\n    typval_T\trettv;\n    int\t\tres;\n    int\t\tvim9script = in_vim9script();\n    garray_T    *gap = evalarg == NULL ? NULL : &evalarg->eval_ga;\n    garray_T    *freegap = evalarg == NULL ? NULL : &evalarg->eval_freega;\n    int\t\tsave_flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tevaluate = evalarg == NULL\n\t\t\t       ? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    if (vim9script && evaluate\n\t       && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tga_init2(gap, sizeof(char_u *), 10);\n\tif (ga_grow(gap, 1) == OK)\n\t    ++gap->ga_len;\n\tga_init2(freegap, sizeof(char_u *), 10);\n    }\n    *start = *arg;\n\n       if (evalarg != NULL)\n\tevalarg->eval_flags &= ~EVAL_EVALUATE;\n    *arg = skipwhite(*arg);\n    res = eval1(arg, &rettv, evalarg);\n    *end = *arg;\n    if (evalarg != NULL)\n\tevalarg->eval_flags = save_flags;\n\n    if (vim9script && evaluate\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tif (evalarg->eval_ga.ga_len == 1)\n\t{\n\t   \t    ga_clear(gap);\n\t    gap->ga_itemsize = 0;\n\t}\n\telse\n\t{\n\t    char_u\t    *p;\n\t    size_t\t    endoff = STRLEN(*arg);\n\n\t   \t    *((char_u **)gap->ga_data) = *start;\n\t    p = ga_concat_strings(gap, \" \");\n\n\t   \t    if (evalarg->eval_cookie != NULL)\n\t    {\n\t\t\t*((char_u **)gap->ga_data) = NULL;\n\t\t\t\tvim_free(evalarg->eval_tofree);\n\t\tevalarg->eval_tofree =\n\t\t\t\t    ((char_u **)gap->ga_data)[gap->ga_len - 1];\n\t\t((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;\n\t\tga_clear_strings(gap);\n\t    }\n\t    else\n\t    {\n\t\tga_clear(gap);\n\n\t\t\tga_clear_strings(freegap);\n\t    }\n\n\t    gap->ga_itemsize = 0;\n\t    if (p == NULL)\n\t\treturn FAIL;\n\t    *start = p;\n\t    vim_free(evalarg->eval_tofree_lambda);\n\t    evalarg->eval_tofree_lambda = p;\n\t   \t    *end = *start + STRLEN(*start) - endoff;\n\t}\n    }\n\n    return res;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nGF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmcs_recv_connect_response(STREAM mcs_data)\n{\n\tUNUSED(mcs_data);\n\tuint8 result;\n\tuint32 length;\n\tSTREAM s;\n\tstruct stream packet;\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\t\n\tpacket = *s;\n\n\tber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\n\n\tber_parse_header(s, BER_TAG_RESULT, &length);\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);\n\t\treturn False;\n\t}\n\n\tber_parse_header(s, BER_TAG_INTEGER, &length);\n\tin_uint8s(s, length);\t\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\trdp_protocol_error(\"mcs_recv_connect_response(), consume connect id from stream would overrun\", &packet);\n\t}\n\n\tmcs_parse_domain_params(s);\n\n\tber_parse_header(s, BER_TAG_OCTET_STRING, &length);\n\n\tsec_process_mcs_data(s);\n\t\n\treturn s_check_end(s);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void setup_namespaces(struct lo_data *lo, struct fuse_session *se)\n{\n    pid_t child;\n\n    \n    if (unshare(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWPID | CLONE_NEWNS): %m\\n\");\n        exit(1);\n    }\n\n    child = fork();\n    if (child < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fork() failed: %m\\n\");\n        exit(1);\n    }\n    if (child > 0) {\n        pid_t waited;\n        int wstatus;\n\n        setup_wait_parent_capabilities();\n\n        \n        do {\n            waited = waitpid(child, &wstatus, 0);\n        } while (waited < 0 && errno == EINTR && !se->exited);\n\n        \n        if (se->exited) {\n            exit(0);\n        }\n\n        if (WIFEXITED(wstatus)) {\n            exit(WEXITSTATUS(wstatus));\n        }\n\n        exit(1);\n    }\n\n    \n    prctl(PR_SET_PDEATHSIG, SIGTERM);\n\n    \n    if (mount(NULL, \"/\", NULL, MS_REC | MS_SLAVE, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/, MS_REC|MS_SLAVE): %m\\n\");\n        exit(1);\n    }\n\n    \n    if (mount(\"proc\", \"/proc\", \"proc\",\n              MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc): %m\\n\");\n        exit(1);\n    }\n\n    \n    if (mount(\"/proc/self/fd\", \"/proc\", NULL, MS_BIND, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc/self/fd, MS_BIND): %m\\n\");\n        exit(1);\n    }\n\n    \n    lo->proc_self_fd = open(\"/proc\", O_PATH);\n    if (lo->proc_self_fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(/proc, O_PATH): %m\\n\");\n        exit(1);\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n\tint ret;\n\tint chk_addr_ret;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(struct sockaddr_l2tpip))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\n\tread_unlock_bh(&l2tp_ip_lock);\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n\t\tgoto out;\n\n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  \n\tsk_dst_reset(sk);\n\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\nout:\n\trelease_sock(sk);\n\n\treturn ret;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0) {\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t\tif (bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool IsPadOpSupported(const TfLiteRegistration* registration,\n                      const TfLiteNode* node, TfLiteContext* context) {\n   const TfLiteTensor* padding;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &padding));\n  if (!IsConstantTensor(padding)) {\n    TF_LITE_KERNEL_LOG(context,\n                       \"%s: Only constant padding is supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  if (padding->dims->data[0] != 4 || padding->dims->data[1] != 2) {\n    TF_LITE_KERNEL_LOG(context, \"%s: Only 4D inputs are supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  const int32_t* padding_data = GetTensorData<int32_t>(padding);\n  if (!(padding_data[0] == 0 && padding_data[1] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for batch dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n\n  if (!(padding_data[6] == 0 && padding_data[7] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for channel dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n  return true;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nGF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size-8;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic char *pool_strdup(const char *s)\n{\n\tsize_t len = strlen(s) + 1;\n\tchar *r = pool_alloc(len);\n\tmemcpy(r, s, len);\n\treturn r;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = reinterpret_cast<TfLiteBidirectionalSequenceRNNParams*>(\n      node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* fw_input_weights =\n      GetInput(context, node, kFwWeightsTensor);\n  const TfLiteTensor* fw_recurrent_weights =\n      GetInput(context, node, kFwRecurrentWeightsTensor);\n  const TfLiteTensor* fw_bias = GetInput(context, node, kFwBiasTensor);\n  const TfLiteTensor* bw_input_weights =\n      GetInput(context, node, kBwWeightsTensor);\n  const TfLiteTensor* bw_recurrent_weights =\n      GetInput(context, node, kBwRecurrentWeightsTensor);\n  const TfLiteTensor* bw_bias = GetInput(context, node, kBwBiasTensor);\n\n   const TfLiteTensor* aux_input =\n      GetOptionalInputTensor(context, node, kAuxInputTensor);\n  const TfLiteTensor* fw_aux_input_weights =\n      GetOptionalInputTensor(context, node, kFwAuxWeightsTensor);\n  const TfLiteTensor* bw_aux_input_weights =\n      GetOptionalInputTensor(context, node, kBwAuxWeightsTensor);\n\n  TfLiteTensor* fw_hidden_state =\n      GetVariableInput(context, node, kFwHiddenStateTensor);\n  TF_LITE_ENSURE(context, fw_hidden_state != nullptr);\n  TfLiteTensor* bw_hidden_state =\n      GetVariableInput(context, node, kBwHiddenStateTensor);\n  TF_LITE_ENSURE(context, bw_hidden_state != nullptr);\n\n  TfLiteTensor* fw_output = GetOutput(context, node, kFwOutputTensor);\n  TfLiteTensor* bw_output = params->merge_outputs\n                                ? nullptr\n                                : GetOutput(context, node, kBwOutputTensor);\n\n  const bool has_previous_bw_output = (aux_input != nullptr);\n  const bool use_aux_input = (fw_aux_input_weights != nullptr);\n\n              \n  const bool non_stacking_mode = !use_aux_input && has_previous_bw_output;\n  const TfLiteTensor* bw_input = non_stacking_mode ? aux_input : input;\n  const TfLiteTensor* real_aux_input = non_stacking_mode ? nullptr : aux_input;\n\n  switch (fw_input_weights->type) {\n    case kTfLiteFloat32:\n      return EvalFloat(input, bw_input, fw_input_weights, fw_recurrent_weights,\n                       fw_bias, bw_input_weights, bw_recurrent_weights, bw_bias,\n                       real_aux_input, fw_aux_input_weights,\n                       bw_aux_input_weights, params, fw_hidden_state, fw_output,\n                       bw_hidden_state, bw_output);\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      TfLiteTensor* input_quantized =\n          GetTemporary(context, node, kInputQuantized);\n      TfLiteTensor* fw_hidden_state_quantized =\n          GetTemporary(context, node, kFwHiddenStateQuantized);\n      TfLiteTensor* bw_hidden_state_quantized =\n          GetTemporary(context, node, kBwHiddenStateQuantized);\n      TfLiteTensor* scaling_factors =\n          GetTemporary(context, node, kScalingFactors);\n      TfLiteTensor* zero_points = GetTemporary(context, node, kZeroPoints);\n      TfLiteTensor* accum_scratch = GetTemporary(context, node, kAccumScratch);\n      TfLiteTensor* fw_row_sums = GetTemporary(context, node, kFwRowSums);\n      TfLiteTensor* bw_row_sums = GetTemporary(context, node, kBwRowSums);\n      TfLiteTensor* aux_input_quantized =\n          use_aux_input ? GetTemporary(context, node, kAuxInputQuantized)\n                        : nullptr;\n      auto* op_data = reinterpret_cast<OpData*>(node->user_data);\n      return EvalHybrid(\n          input, bw_input, fw_input_weights, fw_recurrent_weights, fw_bias,\n          bw_input_weights, bw_recurrent_weights, bw_bias, real_aux_input,\n          fw_aux_input_weights, bw_aux_input_weights, params, scaling_factors,\n          input_quantized, aux_input_quantized, fw_hidden_state_quantized,\n          fw_hidden_state, fw_output, bw_hidden_state_quantized,\n          bw_hidden_state, bw_output, zero_points, accum_scratch, fw_row_sums,\n          bw_row_sums, &op_data->fw_compute_row_sums,\n          &op_data->bw_compute_row_sums);\n    }\n    default:\n      context->ReportError(context, \"Type not currently supported.\");\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ncliprdr_process(STREAM s)\n{\n\tuint16 type, status;\n\tuint32 length, format;\n\tuint8 *data;\n\tstruct stream packet = *s;\n\n\tin_uint16_le(s, type);\n\tin_uint16_le(s, status);\n\tin_uint32_le(s, length);\n\tdata = s->p;\n\n\tlogger(Clipboard, Debug, \"cliprdr_process(), type=%d, status=%d, length=%d\", type, status,\n\t       length);\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\trdp_protocol_error(\"cliprdr_process(), consume of packet from stream would overrun\", &packet);\n\t}\n\n\tif (status == CLIPRDR_ERROR)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase CLIPRDR_FORMAT_ACK:\n\t\t\t\t\n\t\t\t\tcliprdr_send_native_format_announce(last_formats,\n\t\t\t\t\t\t\t\t    last_formats_length);\n\t\t\t\tbreak;\n\t\t\tcase CLIPRDR_DATA_RESPONSE:\n\t\t\t\tui_clip_request_failed();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger(Clipboard, Warning,\n\t\t\t\t       \"cliprdr_process(), unhandled error (type=%d)\", type);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tswitch (type)\n\t{\n\t\tcase CLIPRDR_CONNECT:\n\t\t\tui_clip_sync();\n\t\t\tbreak;\n\t\tcase CLIPRDR_FORMAT_ANNOUNCE:\n\t\t\tui_clip_format_announce(data, length);\n\t\t\tcliprdr_send_packet(CLIPRDR_FORMAT_ACK, CLIPRDR_RESPONSE, NULL, 0);\n\t\t\treturn;\n\t\tcase CLIPRDR_FORMAT_ACK:\n\t\t\tbreak;\n\t\tcase CLIPRDR_DATA_REQUEST:\n\t\t\tin_uint32_le(s, format);\n\t\t\tui_clip_request_data(format);\n\t\t\tbreak;\n\t\tcase CLIPRDR_DATA_RESPONSE:\n\t\t\tui_clip_handle_data(data, length);\n\t\t\tbreak;\n\t\tcase 7:\t\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger(Clipboard, Warning, \"cliprdr_process(), unhandled packet type %d\",\n\t\t\t       type);\n\t}\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic VALUE cState_object_nl_set(VALUE self, VALUE object_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(object_nl, T_STRING);\n    len = RSTRING_LEN(object_nl);\n    if (len == 0) {\n        if (state->object_nl) {\n            ruby_xfree(state->object_nl);\n            state->object_nl = NULL;\n        }\n    } else {\n        if (state->object_nl) ruby_xfree(state->object_nl);\n        state->object_nl = fstrndup(RSTRING_PTR(object_nl), len);\n        state->object_nl_len = len;\n    }\n    return Qnil;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void sycc420_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n\tconst int *y, *cb, *cr, *ny;\n\tunsigned int maxw, maxh, max;\n\tint offset, upb;\n\tunsigned int i, j;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\n\tfor(i=0U; i < (maxh & ~(unsigned int)1U); i += 2U)\n\t{\n\t\tny = y + maxw;\n\t\tnr = r + maxw; ng = g + maxw; nb = b + maxw;\n\n\t\tfor(j=0; j < (maxw & ~(unsigned int)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\tif(j < maxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\ty += maxw; r += maxw; g += maxw; b += maxw;\n\t}\n\tif(i < maxh)\n\t{\n\t\tfor(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t\tif(j < maxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t}\n\t}\n\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\n#if defined(USE_JPWL) || defined(USE_MJ2)\n\timg->comps[1].w = maxw; img->comps[1].h = maxh;\n\timg->comps[2].w = maxw; img->comps[2].h = maxh;\n#else\n\timg->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;\n\timg->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;\n#endif\n\timg->comps[1].dx = img->comps[0].dx;\n\timg->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[0].dy;\n\timg->comps[2].dy = img->comps[0].dy;\n\treturn;\n\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t      int lookup, struct fscrypt_name *fname)\n{\n\tint ret = 0, bigname = 0;\n\n\tmemset(fname, 0, sizeof(struct fscrypt_name));\n\tfname->usr_fname = iname;\n\n\tif (!dir->i_sb->s_cop->is_encrypted(dir) ||\n\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_crypt_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,\n\t\t\t\t\t\t\t&fname->crypto_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fname_encrypt(dir, iname, &fname->crypto_buf);\n\t\tif (ret)\n\t\t\tgoto errout;\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t\treturn 0;\n\t}\n\tif (!lookup)\n\t\treturn -ENOKEY;\n\n\t\n\tif (iname->name[0] == '_')\n\t\tbigname = 1;\n\tif ((bigname && (iname->len != 33)) || (!bigname && (iname->len > 43)))\n\t\treturn -ENOENT;\n\n\tfname->crypto_buf.name = kmalloc(32, GFP_KERNEL);\n\tif (fname->crypto_buf.name == NULL)\n\t\treturn -ENOMEM;\n\n\tret = digest_decode(iname->name + bigname, iname->len - bigname,\n\t\t\t\tfname->crypto_buf.name);\n\tif (ret < 0) {\n\t\tret = -ENOENT;\n\t\tgoto errout;\n\t}\n\tfname->crypto_buf.len = ret;\n\tif (bigname) {\n\t\tmemcpy(&fname->hash, fname->crypto_buf.name, 4);\n\t\tmemcpy(&fname->minor_hash, fname->crypto_buf.name + 4, 4);\n\t} else {\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t}\n\treturn 0;\n\nerrout:\n\tfscrypt_fname_free_buffer(&fname->crypto_buf);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nerror_t tcpCheckSeqNum(Socket *socket, TcpHeader *segment, size_t length)\n{\n     bool_t acceptable = FALSE;\n\n     if(!length && !socket->rcvWnd)\n   {\n           if(segment->seqNum == socket->rcvNxt)\n      {\n         acceptable = TRUE;\n      }\n   }\n     else if(!length && socket->rcvWnd)\n   {\n           if(TCP_CMP_SEQ(segment->seqNum, socket->rcvNxt) >= 0 &&\n         TCP_CMP_SEQ(segment->seqNum, socket->rcvNxt + socket->rcvWnd) < 0)\n      {\n         acceptable = TRUE;\n      }\n   }\n     else if(length && socket->rcvWnd)\n   {\n           if(TCP_CMP_SEQ(segment->seqNum, socket->rcvNxt) >= 0 &&\n         TCP_CMP_SEQ(segment->seqNum, socket->rcvNxt + socket->rcvWnd) < 0)\n      {\n         acceptable = TRUE;\n      }\n           else if(TCP_CMP_SEQ(segment->seqNum + length - 1, socket->rcvNxt) >= 0 &&\n         TCP_CMP_SEQ(segment->seqNum + length - 1, socket->rcvNxt + socket->rcvWnd) < 0)\n      {\n         acceptable = TRUE;\n      }\n   }\n\n     if(!acceptable)\n   {\n           TRACE_WARNING(\"Sequence number is not acceptable!\\r\\n\");\n\n                if(!(segment->flags & TCP_FLAG_RST))\n      {\n         tcpSendSegment(socket, TCP_FLAG_ACK, socket->sndNxt, socket->rcvNxt,\n            0, FALSE);\n      }\n\n           return ERROR_FAILURE;\n   }\n\n     return NO_ERROR;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int fetchve(char ***argv, char ***envp)\n{\n\tchar *cmdline = NULL, *environ = NULL;\n\tsize_t cmdline_size, environ_size;\n\n\tcmdline = read_file(\"/proc/self/cmdline\", &cmdline_size);\n\tif (!cmdline)\n\t\tgoto error;\n\tenviron = read_file(\"/proc/self/environ\", &environ_size);\n\tif (!environ)\n\t\tgoto error;\n\n\tif (parse_xargs(cmdline, cmdline_size, argv) <= 0)\n\t\tgoto error;\n\tif (parse_xargs(environ, environ_size, envp) <= 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tfree(environ);\n\tfree(cmdline);\n\treturn -EINVAL;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nhybiDecodeCleanup(ws_ctx_t *wsctx)\n{\n  wsctx->header.payloadLen = 0;\n  wsctx->header.mask.u = 0;\n  wsctx->nReadRaw = 0;\n  wsctx->nToRead= 0;\n  wsctx->carrylen = 0;\n  wsctx->readPos = (unsigned char *)wsctx->codeBufDecode;\n  wsctx->readlen = 0;\n  wsctx->hybiDecodeState = WS_HYBI_STATE_HEADER_PENDING;\n  wsctx->writePos = NULL;\n  rfbLog(\"cleaned up wsctx\\n\");\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nssh_kex2(char *host, struct sockaddr *hostaddr, u_short port)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *s;\n\tstruct kex *kex;\n\tint r;\n\n\txxx_host = host;\n\txxx_hostaddr = hostaddr;\n\n\tif ((s = kex_names_cat(options.kex_algorithms, \"ext-info-c\")) == NULL)\n\t\tfatal(\"%s: kex_names_cat\", __func__);\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(s);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] =\n\t    compat_cipher_proposal(options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] =\n\t    compat_cipher_proposal(options.ciphers);\n\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = options.compression ?\n\t    \"zlib@openssh.com,none\" : \"none,zlib@openssh.com\";\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\tif (options.hostkeyalgorithms != NULL) {\n\t\tif (kex_assemble_names(KEX_DEFAULT_PK_ALG,\n\t\t    &options.hostkeyalgorithms) != 0)\n\t\t\tfatal(\"%s: kex_assemble_namelist\", __func__);\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(options.hostkeyalgorithms);\n\t} else {\n\t\t\n\t\toptions.hostkeyalgorithms = xstrdup(KEX_DEFAULT_PK_ALG);\n\t\t\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(\n\t\t    order_hostkeyalgs(host, hostaddr, port));\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tpacket_set_rekey_limits((u_int32_t)options.rekey_limit,\n\t\t    (time_t)options.rekey_interval);\n\n\t\n\tif ((r = kex_setup(active_state, myproposal)) != 0)\n\t\tfatal(\"kex_setup: %s\", ssh_err(r));\n\tkex = active_state->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_client;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_client;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_client;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n\tkex->kex[KEX_ECDH_SHA2] = kexecdh_client;\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kexc25519_client;\n\tkex->client_version_string=client_version_string;\n\tkex->server_version_string=server_version_string;\n\tkex->verify_host_key=&verify_host_key_callback;\n\n\tdispatch_run(DISPATCH_BLOCK, &kex->done, active_state);\n\n\t\n\tmyproposal[PROPOSAL_KEX_ALGS] =\n\t    compat_kex_proposal(options.kex_algorithms);\n\tif ((r = kex_prop2buf(kex->my, myproposal)) != 0)\n\t\tfatal(\"kex_prop2buf: %s\", ssh_err(r));\n\n\tsession_id2 = kex->session_id;\n\tsession_id2_len = kex->session_id_len;\n\n#ifdef DEBUG_KEXDH\n\t\n\tpacket_start(SSH2_MSG_IGNORE);\n\tpacket_put_cstring(\"markus\");\n\tpacket_send();\n\tpacket_write_wait();\n#endif\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint firstBitSet(int x)\n{\n        int position=0;\n        while (x!=0)\n        {\n                x>>=1;\n                ++position;\n        }\n        return position;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nl2tp_result_code_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\t\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr)));\n\tptr++;\n\tlength -= 2;\n\n\t\n\tif (length == 0)\n\t\treturn;\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \" AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"/%u\", EXTRACT_16BITS(ptr)));\n\tptr++;\n\tlength -= 2;\n\n\t\n\tif (length == 0)\n\t\treturn;\n\tND_PRINT((ndo, \" \"));\n\tprint_string(ndo, (const u_char *)ptr, length);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool ServerSecurityFeature::foxxAllowInstallFromRemote() const {\n  return _foxxAllowInstallFromRemote;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ninline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0 && l >= 2) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0 && l >= 3) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0 && l >= 4) {\n      return 4;\n    }\n  }\n  return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_enter *rec;\n\tstruct hlist_head *head;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->enter_event->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\t\n\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = (struct syscall_trace_enter *)perf_trace_buf_prepare(size,\n\t\t\t\tsys_data->enter_event->event.type, regs, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args,\n\t\t\t       (unsigned long *)&rec->args);\n\tperf_trace_buf_submit(rec, size, rctx, 0, 1, regs, head, NULL);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nSPL_METHOD(SplFileInfo, getPathInfo)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = intern->info_class;\n\tzend_error_handling error_handling;\n\t\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tint path_len;\n\t\tchar *path = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n\t\tif (path) {\n\t\t\tchar *dpath = estrndup(path, path_len);\n\t\t\tpath_len = php_dirname(dpath, path_len);\n\t\t\tspl_filesystem_object_create_info(intern, dpath, path_len, 1, ce, return_value TSRMLS_CC);\n\t\t\tefree(dpath);\n\t\t}\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  static NAN_METHOD(Encrypt) {\n    MarkPopErrorOnReturn mark_pop_error_on_return;\n\n    ChaChaPolyCipher* obj = ObjectWrap::Unwrap<ChaChaPolyCipher>(info.Holder());\n\n    if (!Buffer::HasInstance(info[0]))\n      return Nan::ThrowTypeError(\"Missing/Invalid packet\");\n\n    if (!info[1]->IsUint32())\n      return Nan::ThrowTypeError(\"Missing/Invalid sequence number\");\n\n    ErrorType r = obj->encrypt(\n      reinterpret_cast<unsigned char*>(Buffer::Data(info[0])),\n      Buffer::Length(info[0]),\n      Nan::To<uint32_t>(info[1]).FromJust()\n    );\n    switch (r) {\n      case kErrNone:\n        return;\n      case kErrOpenSSL: {\n        char msg_buf[128] = {0};\n        ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));\n        return Nan::ThrowError(msg_buf);\n      }\n      default:\n        return Nan::ThrowError(\"Unknown encrypt failure\");\n    }\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int swevent_hlist_get_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tint err = 0;\n\n\tmutex_lock(&swhash->hlist_mutex);\n\n\tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc(sizeof(*hlist), GFP_KERNEL);\n\t\tif (!hlist) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\n\treturn err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, data, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus PrepareSimple(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  OpContext op_context(context, node);\n  TF_LITE_ENSURE_TYPES_EQ(context, op_context.axis->type, kTfLiteInt32);\n  TF_LITE_ENSURE_OK(context, InitializeTemporaries(context, node, &op_context));\n\n  TfLiteTensor* resolved_axis = GetTemporary(context, node, 1);\n   if (!IsConstantTensor(op_context.axis)) {\n    SetTensorToDynamic(op_context.output);\n    SetTensorToDynamic(resolved_axis);\n    return kTfLiteOk;\n  }\n  resolved_axis->allocation_type = kTfLiteArenaRw;\n  TF_LITE_ENSURE_OK(context,\n                    ResizeTempAxis(context, &op_context, resolved_axis));\n  TF_LITE_ENSURE_OK(context, ResizeOutputTensor(context, &op_context));\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline void fsnotify_oldname_free(const unsigned char *old_name)\n{\n\tkfree(old_name);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_for_expr_stmt(struct compiling *c, const node *n)\n{\n    int num;\n\n    REQ(n, expr_stmt);\n    \n    num = NCH(n);\n\n    if (num == 1 || (num == 2 && TYPE(CHILD(n, 1)) == TYPE_COMMENT)) {\n        expr_ty e = ast_for_testlist(c, CHILD(n, 0));\n        if (!e)\n            return NULL;\n\n        return Expr(e, LINENO(n), n->n_col_offset, c->c_arena);\n    }\n    else if (TYPE(CHILD(n, 1)) == augassign) {\n        expr_ty expr1, expr2;\n        operator_ty newoperator;\n        node *ch = CHILD(n, 0);\n\n        expr1 = ast_for_testlist(c, ch);\n        if (!expr1)\n            return NULL;\n        if(!set_context(c, expr1, Store, ch))\n            return NULL;\n        \n        switch (expr1->kind) {\n            case Name_kind:\n            case Attribute_kind:\n            case Subscript_kind:\n                break;\n            default:\n                ast_error(c, ch, \"illegal expression for augmented assignment\");\n                return NULL;\n        }\n\n        ch = CHILD(n, 2);\n        if (TYPE(ch) == testlist)\n            expr2 = ast_for_testlist(c, ch);\n        else\n            expr2 = ast_for_expr(c, ch);\n        if (!expr2)\n            return NULL;\n\n        newoperator = ast_for_augassign(c, CHILD(n, 1));\n        if (!newoperator)\n            return NULL;\n\n        return AugAssign(expr1, newoperator, expr2, LINENO(n), n->n_col_offset, c->c_arena);\n    }\n    else if (TYPE(CHILD(n, 1)) == annassign) {\n        expr_ty expr1, expr2, expr3;\n        node *ch = CHILD(n, 0);\n        node *deep, *ann = CHILD(n, 1);\n        int simple = 1;\n\n        \n        if (c->c_feature_version < 6) {\n            ast_error(c, ch,\n                    \"Variable annotation syntax is only supported in Python 3.6 and greater\");\n            return NULL;\n        }\n\n        \n        deep = ch;\n        while (NCH(deep) == 1) {\n            deep = CHILD(deep, 0);\n        }\n        if (NCH(deep) > 0 && TYPE(CHILD(deep, 0)) == LPAR) {\n            simple = 0;\n        }\n        expr1 = ast_for_testlist(c, ch);\n        if (!expr1) {\n            return NULL;\n        }\n        switch (expr1->kind) {\n            case Name_kind:\n                if (forbidden_name(c, expr1->v.Name.id, n, 0)) {\n                    return NULL;\n                }\n                expr1->v.Name.ctx = Store;\n                break;\n            case Attribute_kind:\n                if (forbidden_name(c, expr1->v.Attribute.attr, n, 1)) {\n                    return NULL;\n                }\n                expr1->v.Attribute.ctx = Store;\n                break;\n            case Subscript_kind:\n                expr1->v.Subscript.ctx = Store;\n                break;\n            case List_kind:\n                ast_error(c, ch,\n                          \"only single target (not list) can be annotated\");\n                return NULL;\n            case Tuple_kind:\n                ast_error(c, ch,\n                          \"only single target (not tuple) can be annotated\");\n                return NULL;\n            default:\n                ast_error(c, ch,\n                          \"illegal target for annotation\");\n                return NULL;\n        }\n\n        if (expr1->kind != Name_kind) {\n            simple = 0;\n        }\n        ch = CHILD(ann, 1);\n        expr2 = ast_for_expr(c, ch);\n        if (!expr2) {\n            return NULL;\n        }\n        if (NCH(ann) == 2) {\n            return AnnAssign(expr1, expr2, NULL, simple,\n                             LINENO(n), n->n_col_offset, c->c_arena);\n        }\n        else {\n            ch = CHILD(ann, 3);\n            expr3 = ast_for_expr(c, ch);\n            if (!expr3) {\n                return NULL;\n            }\n            return AnnAssign(expr1, expr2, expr3, simple,\n                             LINENO(n), n->n_col_offset, c->c_arena);\n        }\n    }\n    else {\n        int i, nch_minus_type, has_type_comment;\n        asdl_seq *targets;\n        node *value;\n        expr_ty expression;\n        string type_comment;\n\n        \n        REQ(CHILD(n, 1), EQUAL);\n\n        has_type_comment = TYPE(CHILD(n, num - 1)) == TYPE_COMMENT;\n        nch_minus_type = num - has_type_comment;\n\n        targets = _Ta3_asdl_seq_new(nch_minus_type / 2, c->c_arena);\n        if (!targets)\n            return NULL;\n        for (i = 0; i < nch_minus_type - 2; i += 2) {\n            expr_ty e;\n            node *ch = CHILD(n, i);\n            if (TYPE(ch) == yield_expr) {\n                ast_error(c, ch, \"assignment to yield expression not possible\");\n                return NULL;\n            }\n            e = ast_for_testlist(c, ch);\n            if (!e)\n              return NULL;\n\n            \n            if (!set_context(c, e, Store, CHILD(n, i)))\n              return NULL;\n\n            asdl_seq_SET(targets, i / 2, e);\n        }\n        value = CHILD(n, nch_minus_type - 1);\n        if (TYPE(value) == testlist_star_expr)\n            expression = ast_for_testlist(c, value);\n        else\n            expression = ast_for_expr(c, value);\n        if (!expression)\n            return NULL;\n        if (has_type_comment)\n            type_comment = NEW_TYPE_COMMENT(CHILD(n, nch_minus_type));\n        else\n            type_comment = NULL;\n        return Assign(targets, expression, type_comment, LINENO(n), n->n_col_offset, c->c_arena);\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_for_arguments(struct compiling *c, const node *n)\n{\n    \n    int i, j, k, nposargs = 0, nkwonlyargs = 0;\n    int nposdefaults = 0, found_default = 0;\n    asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;\n    arg_ty vararg = NULL, kwarg = NULL;\n    arg_ty arg = NULL;\n    node *ch;\n\n    if (TYPE(n) == parameters) {\n        if (NCH(n) == 2) \n            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);\n        n = CHILD(n, 1);\n    }\n    assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);\n\n    \n    for (i = 0; i < NCH(n); i++) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == STAR) {\n            \n            i++;\n            if (i < NCH(n) && \n                (TYPE(CHILD(n, i)) == tfpdef ||\n                 TYPE(CHILD(n, i)) == vfpdef)) {\n                i++;\n            }\n            break;\n        }\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;\n        if (TYPE(ch) == EQUAL) nposdefaults++;\n    }\n    \n    for ( ; i < NCH(n); ++i) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;\n    }\n    posargs = (nposargs ? _Ta3_asdl_seq_new(nposargs, c->c_arena) : NULL);\n    if (!posargs && nposargs)\n        return NULL;\n    kwonlyargs = (nkwonlyargs ?\n                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwonlyargs && nkwonlyargs)\n        return NULL;\n    posdefaults = (nposdefaults ?\n                    _Ta3_asdl_seq_new(nposdefaults, c->c_arena) : NULL);\n    if (!posdefaults && nposdefaults)\n        return NULL;\n    \n    kwdefaults = (nkwonlyargs ?\n                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwdefaults && nkwonlyargs)\n        return NULL;\n\n    \n    i = 0;\n    j = 0;  \n    k = 0;  \n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case tfpdef:\n            case vfpdef:\n                \n                \n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        return NULL;\n                    assert(posdefaults != NULL);\n                    asdl_seq_SET(posdefaults, j++, expression);\n                    i += 2;\n                    found_default = 1;\n                }\n                else if (found_default) {\n                    ast_error(c, n,\n                             \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                arg = ast_for_arg(c, ch);\n                if (!arg)\n                    return NULL;\n                asdl_seq_SET(posargs, k++, arg);\n                i += 1; \n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case STAR:\n                if (i+1 >= NCH(n) ||\n                    (i+2 == NCH(n) && (TYPE(CHILD(n, i+1)) == COMMA\n                                       || TYPE(CHILD(n, i+1)) == TYPE_COMMENT))) {\n                    ast_error(c, CHILD(n, i),\n                        \"named arguments must follow bare *\");\n                    return NULL;\n                }\n                ch = CHILD(n, i+1);  \n                if (TYPE(ch) == COMMA) {\n                    int res = 0;\n                    i += 2; \n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        ast_error(c, CHILD(n, i),\n                                \"bare * has associated type comment\");\n                        return NULL;\n                    }\n\n                    res = handle_keywordonly_args(c, n, i,\n                                                  kwonlyargs, kwdefaults);\n                    if (res == -1) return NULL;\n                    i = res; \n                }\n                else {\n                    vararg = ast_for_arg(c, ch);\n                    if (!vararg)\n                        return NULL;\n\n                    i += 2; \n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                        i += 1; \n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        vararg->type_comment = NEW_TYPE_COMMENT(CHILD(n, i));\n                        if (!vararg->type_comment)\n                            return NULL;\n                        i += 1;\n                    }\n\n                    if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef\n                                    || TYPE(CHILD(n, i)) == vfpdef)) {\n                        int res = 0;\n                        res = handle_keywordonly_args(c, n, i,\n                                                      kwonlyargs, kwdefaults);\n                        if (res == -1) return NULL;\n                        i = res; \n                    }\n                }\n                break;\n            case DOUBLESTAR:\n                ch = CHILD(n, i+1);  \n                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);\n                kwarg = ast_for_arg(c, ch);\n                if (!kwarg)\n                    return NULL;\n                i += 2; \n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                assert(i);\n\n                if (kwarg)\n                    arg = kwarg;\n\n                \n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    return NULL;\n                i += 1;\n                break;\n            default:\n                PyErr_Format(PyExc_SystemError,\n                             \"unexpected node in varargslist: %d @ %d\",\n                             TYPE(ch), i);\n                return NULL;\n        }\n    }\n    return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nStatus genTableRowsForSqliteTable(const fs::path& sqlite_db,\n                                  const std::string& sqlite_query,\n                                  TableRows& results,\n                                  bool respect_locking) {\n  sqlite3* db = nullptr;\n  if (!pathExists(sqlite_db).ok()) {\n    return Status(1, \"Database path does not exist\");\n  }\n\n  auto rc = sqlite3_open_v2(\n      sqlite_db.string().c_str(),\n      &db,\n      (SQLITE_OPEN_READONLY | SQLITE_OPEN_PRIVATECACHE | SQLITE_OPEN_NOMUTEX),\n      getSystemVFS(respect_locking));\n  if (rc != SQLITE_OK || db == nullptr) {\n    VLOG(1) << \"Cannot open specified database: \"\n            << getStringForSQLiteReturnCode(rc);\n    if (db != nullptr) {\n      sqlite3_close(db);\n    }\n    return Status(1, \"Could not open database\");\n  }\n\n  rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    auto errMsg =\n        std::string(\"Failed to set sqlite authorizer: \") + sqlite3_errmsg(db);\n    return Status(1, errMsg);\n  }\n\n  sqlite3_stmt* stmt = nullptr;\n  rc = sqlite3_prepare_v2(db, sqlite_query.c_str(), -1, &stmt, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    VLOG(1) << \"ATC table: Could not prepare database at path: \" << sqlite_db;\n    return Status(rc, \"Could not prepare database\");\n  }\n\n  while ((sqlite3_step(stmt)) == SQLITE_ROW) {\n    auto s = genSqliteTableRow(stmt, results, sqlite_db);\n    if (!s.ok()) {\n      break;\n    }\n  }\n\n   sqlite3_finalize(stmt);\n  sqlite3_close(db);\n\n  return Status{};\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  Status BuildFeatureReaders(const OpInputList& ragged_values_list,\n                             const OpInputList& ragged_splits_list,\n                             const OpInputList& sparse_indices_list,\n                             const OpInputList& sparse_values_list,\n                             const OpInputList& dense_list, int64 batch_size,\n                             FeatureReaders* features) {\n    features->reserve(input_order_.size());\n\n    int next_ragged = 0;\n    int next_sparse = 0;\n    int next_dense = 0;\n    for (char c : input_order_) {\n      if (c == 'R') {\n        if (next_ragged >= ragged_values_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a ragged tensor value at index \",\n              next_ragged, \" from a list of \", ragged_values_list.size(),\n              \" values.\");\n        if (next_ragged >= ragged_splits_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a ragged tensor split at index \",\n              next_ragged, \" from a list of \", ragged_splits_list.size(),\n              \" splits.\");\n        TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(\n            ragged_values_list[next_ragged], ragged_splits_list[next_ragged],\n            features));\n        next_ragged++;\n      } else if (c == 'S') {\n        if (next_sparse >= sparse_values_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a sparse tensor value at index \",\n              next_sparse, \" from a list of \", sparse_values_list.size(),\n              \" values.\");\n        if (next_sparse >= sparse_indices_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a sparse tensor index at index \",\n              next_sparse, \" from a list of \", sparse_indices_list.size(),\n              \" indices.\");\n        TF_RETURN_IF_ERROR(BuildSparseFeatureReader(\n            sparse_indices_list[next_sparse], sparse_values_list[next_sparse],\n            batch_size, features));\n        next_sparse++;\n      } else if (c == 'D') {\n        if (next_dense >= dense_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a dense tensor at index \", next_dense,\n              \" from a list of \", dense_list.size(), \" tensors.\");\n        TF_RETURN_IF_ERROR(\n            BuildDenseFeatureReader(dense_list[next_dense++], features));\n      } else {\n        return errors::InvalidArgument(\"Unexpected input_order value.\");\n      }\n    }\n\n    return Status::OK();\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n\n    \n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        \n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    return close(sr->fd_file);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\njp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\t\t\tbox->ops = &boxinfo->ops;\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ngplotGenCommandFile(GPLOT  *gplot)\n{\nchar     buf[L_BUF_SIZE];\nchar    *cmdstr, *plottitle, *dataname;\nl_int32  i, plotstyle, nplots;\nFILE    *fp;\n\n    PROCNAME(\"gplotGenCommandFile\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n        \n    sarrayClear(gplot->cmddata);\n\n        \n    if (gplot->title) {   \n        snprintf(buf, L_BUF_SIZE, \"set title '%s'\", gplot->title);\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n    if (gplot->xlabel) {   \n        snprintf(buf, L_BUF_SIZE, \"set xlabel '%s'\", gplot->xlabel);\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n    if (gplot->ylabel) {   \n        snprintf(buf, L_BUF_SIZE, \"set ylabel '%s'\", gplot->ylabel);\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n\n        \n    if (gplot->outformat == GPLOT_PNG) {\n        snprintf(buf, L_BUF_SIZE, \"set terminal png; set output '%s'\",\n                 gplot->outname);\n    } else if (gplot->outformat == GPLOT_PS) {\n        snprintf(buf, L_BUF_SIZE, \"set terminal postscript; set output '%s'\",\n                 gplot->outname);\n    } else if (gplot->outformat == GPLOT_EPS) {\n        snprintf(buf, L_BUF_SIZE,\n                 \"set terminal postscript eps; set output '%s'\",\n                 gplot->outname);\n    } else if (gplot->outformat == GPLOT_LATEX) {\n        snprintf(buf, L_BUF_SIZE, \"set terminal latex; set output '%s'\",\n                 gplot->outname);\n    }\n    sarrayAddString(gplot->cmddata, buf, L_COPY);\n\n    if (gplot->scaling == GPLOT_LOG_SCALE_X ||\n        gplot->scaling == GPLOT_LOG_SCALE_X_Y) {\n        snprintf(buf, L_BUF_SIZE, \"set logscale x\");\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n    if (gplot->scaling == GPLOT_LOG_SCALE_Y ||\n        gplot->scaling == GPLOT_LOG_SCALE_X_Y) {\n        snprintf(buf, L_BUF_SIZE, \"set logscale y\");\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n\n    nplots = sarrayGetCount(gplot->datanames);\n    for (i = 0; i < nplots; i++) {\n        plottitle = sarrayGetString(gplot->plottitles, i, L_NOCOPY);\n        dataname = sarrayGetString(gplot->datanames, i, L_NOCOPY);\n        numaGetIValue(gplot->plotstyles, i, &plotstyle);\n        if (nplots == 1) {\n            snprintf(buf, L_BUF_SIZE, \"plot '%s' title '%s' %s\",\n                     dataname, plottitle, gplotstylenames[plotstyle]);\n        } else {\n            if (i == 0)\n                snprintf(buf, L_BUF_SIZE, \"plot '%s' title '%s' %s, \\\\\",\n                     dataname, plottitle, gplotstylenames[plotstyle]);\n            else if (i < nplots - 1)\n                snprintf(buf, L_BUF_SIZE, \" '%s' title '%s' %s, \\\\\",\n                     dataname, plottitle, gplotstylenames[plotstyle]);\n            else\n                snprintf(buf, L_BUF_SIZE, \" '%s' title '%s' %s\",\n                     dataname, plottitle, gplotstylenames[plotstyle]);\n        }\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n\n        \n    cmdstr = sarrayToString(gplot->cmddata, 1);\n    if ((fp = fopenWriteStream(gplot->cmdname, \"w\")) == NULL) {\n        LEPT_FREE(cmdstr);\n        return ERROR_INT(\"cmd stream not opened\", procName, 1);\n    }\n    fwrite(cmdstr, 1, strlen(cmdstr), fp);\n    fclose(fp);\n    LEPT_FREE(cmdstr);\n    return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig)\n{\n  const ceph_msg_header& header = m->get_header();\n  const ceph_msg_footer& footer = m->get_footer();\n\n     struct {\n    __u8 v;\n    __le64 magic;\n    __le32 len;\n    __le32 header_crc;\n    __le32 front_crc;\n    __le32 middle_crc;\n    __le32 data_crc;\n  } __attribute__ ((packed)) sigblock = {\n    1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n    mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n    mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n  };\n\n  char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n\n  try {\n    const CryptoKey::in_slice_t in {\n      sizeof(sigblock),\n      reinterpret_cast<const unsigned char*>(&sigblock)\n    };\n    const CryptoKey::out_slice_t out {\n      sizeof(exp_buf),\n      reinterpret_cast<unsigned char*>(&exp_buf)\n    };\n\n    key.encrypt(cct, in, out);\n  } catch (std::exception& e) {\n    lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n    return -1;\n  }\n\n  *psig = *reinterpret_cast<__le64*>(exp_buf);\n\n  ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()\n\t\t << \" front_crc_ = \" << footer.front_crc\n\t\t << \" middle_crc = \" << footer.middle_crc\n\t\t << \" data_crc = \" << footer.data_crc\n\t\t << \" sig = \" << *psig\n\t\t << dendl;\n  return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Authentication"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic struct sock *dccp_v6_request_recv_sock(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *ireq6 = inet6_rsk(req);\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t\n\n\t\t\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (dst == NULL) {\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_DCCP;\n\t\tipv6_addr_copy(&fl6.daddr, &ireq6->rmt_addr);\n\t\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\t\tipv6_addr_copy(&fl6.saddr, &ireq6->loc_addr);\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.fl6_dport = inet_rsk(req)->rmt_port;\n\t\tfl6.fl6_sport = inet_rsk(req)->loc_port;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p, false);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t\n\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &ireq6->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &ireq6->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &ireq6->loc_addr);\n\tnewsk->sk_bound_dev_if = ireq6->iif;\n\n\t\n\tnewinet->opt = NULL;\n\n\t\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\t\n\tnewnp->pktoptions = NULL;\n\tif (ireq6->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(ireq6->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(ireq6->pktopts);\n\t\tireq6->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t\n\tif (opt != NULL) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt != NULL)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\tif (opt != NULL && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\treturn NULL;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void mpeg4_encode_gop_header(MpegEncContext *s)\n{\n    int64_t hours, minutes, seconds;\n    int64_t time;\n\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, GOP_STARTCODE);\n\n    time = s->current_picture_ptr->f->pts;\n    if (s->reordered_input_picture[1])\n        time = FFMIN(time, s->reordered_input_picture[1]->f->pts);\n    time = time * s->avctx->time_base.num;\n    s->last_time_base = FFUDIV(time, s->avctx->time_base.den);\n\n    seconds = FFUDIV(time, s->avctx->time_base.den);\n    minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);\n    hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);\n    hours   = FFUMOD(hours  , 24);\n\n    put_bits(&s->pb, 5, hours);\n    put_bits(&s->pb, 6, minutes);\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 6, seconds);\n\n    put_bits(&s->pb, 1, !!(s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP));\n    put_bits(&s->pb, 1, 0); \n    ff_mpeg4_stuffing(&s->pb);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmcs_parse_domain_params(STREAM s)\n{\n\tint length;\n\n\tber_parse_header(s, MCS_TAG_DOMAIN_PARAMS, &length);\n\tin_uint8s(s, length);\n\n\treturn s_check(s);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void Compute(OpKernelContext* context) override {\n       OpInputList params_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"params_nested_splits\",\n                                                &params_nested_splits_in));\n    const Tensor& params_dense_values_in =\n        context->input(params_nested_splits_in.size());\n    const Tensor& indices_in =\n        context->input(params_nested_splits_in.size() + 1);\n\n    DCHECK_GT(params_nested_splits_in.size(), 0);     SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;\n    OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));\n\n    OP_REQUIRES(context, params_dense_values_in.dims() > 0,\n                errors::InvalidArgument(\"params.rank must be nonzero\"));\n    SPLITS_TYPE num_params_dense_values = params_dense_values_in.dim_size(0);\n\n          std::vector<std::pair<SPLITS_TYPE, SPLITS_TYPE>> value_slices;\n    SPLITS_TYPE num_values = 0;\n    std::vector<std::vector<SPLITS_TYPE>> out_splits;\n    OP_REQUIRES_OK(context, MakeSplits(indices_in, params_nested_splits_in,\n                                       num_params_dense_values, &out_splits,\n                                       &value_slices, &num_values));\n\n       OP_REQUIRES_OK(context, WriteSplits(out_splits, context));\n    OP_REQUIRES_OK(context,\n                   WriteValues(params_dense_values_in, value_slices,\n                               out_splits.size(), num_values, context));\n  }\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  \n  int nextra = actual - nfixparams;  \n  ci->u.l.nextraargs = nextra;\n  luaD_checkstack(L, p->maxstacksize + 1);\n  \n  setobjs2s(L, L->top++, ci->func);\n  \n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);\n    setnilvalue(s2v(ci->func + i));  \n  }\n  ci->func += actual + 1;\n  ci->top += actual + 1;\n  lua_assert(L->top <= ci->top && ci->top <= L->stack_last);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTEST_F(QuantizedConv2DTest, SmallWithNoZero) {\n  const int stride = 1;\n  TF_ASSERT_OK(NodeDefBuilder(\"quantized_conv_op\", \"QuantizedConv2D\")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"out_type\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"strides\", {1, stride, stride, 1})\n                   .Attr(\"padding\", \"SAME\")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  const int depth = 1;\n  const int image_width = 4;\n  const int image_height = 3;\n  const int image_batch_count = 1;\n     const float image_min = 1.0f;\n  const float image_max = 12.0f;\n  Tensor image_float(DT_FLOAT,\n                     {image_batch_count, image_height, image_width, depth});\n  test::FillValues<float>(&image_float,\n                          {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});\n  Tensor image_quantized =\n      FloatTensorToQuantized<quint8>(image_float, image_min, image_max);\n  const int filter_size = 3;\n  const int filter_count = 1;\n  const float filter_min = 1.0f;\n  const float filter_max = 9.0f;\n  Tensor filter_float(DT_FLOAT,\n                      {filter_size, filter_size, depth, filter_count});\n  test::FillValues<float>(&filter_float, {1, 4, 7, 2, 5, 8, 3, 6, 9});\n  Tensor filter_quantized =\n      FloatTensorToQuantized<quint8>(filter_float, filter_min, filter_max);\n  AddInputFromArray<quint8>(image_quantized.shape(),\n                            image_quantized.flat<quint8>());\n  AddInputFromArray<quint8>(filter_quantized.shape(),\n                            filter_quantized.flat<quint8>());\n  AddInputFromArray<float>(TensorShape({1}), {image_min});\n  AddInputFromArray<float>(TensorShape({1}), {image_max});\n  AddInputFromArray<float>(TensorShape({1}), {filter_min});\n  AddInputFromArray<float>(TensorShape({1}), {filter_max});\n  TF_ASSERT_OK(RunOpKernel());\n  const int expected_width = image_width;\n  const int expected_height = image_height * filter_count;\n  Tensor expected_float(\n      DT_FLOAT, TensorShape({image_batch_count, expected_height, expected_width,\n                             filter_count}));\n  test::FillValues<float>(&expected_float, {105, 150, 183, 95, 235, 312, 357,\n                                            178, 187, 234, 261, 121});\n  const Tensor& output_quantized = *GetOutput(0);\n  const float output_min = GetOutput(1)->flat<float>()(0);\n  const float output_max = GetOutput(2)->flat<float>()(0);\n  Tensor output_float =\n      QuantizedTensorToFloat<qint32>(output_quantized, output_min, output_max);\n  test::ExpectTensorNear<float>(expected_float, output_float, 1.0);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nJsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    \n    if (obj->isarrlist) {\n        if (key >= 0 && (uint)key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[JSI_MAX_NUMBER_STRING];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool IsIdentityConsumingSwitch(const MutableGraphView& graph,\n                               const NodeDef& node) {\n  if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&\n      node.input_size() > 0) {\n    TensorId tensor_id = ParseTensorName(node.input(0));\n    if (IsTensorIdControlling(tensor_id)) {\n      return false;\n    }\n\n    NodeDef* input_node = graph.GetNode(tensor_id.node());\n    if (input_node == nullptr) {\n      return false;\n    }\n    return IsSwitch(*input_node);\n  }\n  return false;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ngplotMakeOutput(GPLOT  *gplot)\n{\nchar     buf[L_BUF_SIZE];\nchar    *cmdname;\nl_int32  ignore;\n\n    PROCNAME(\"gplotMakeOutput\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n    gplotGenCommandFile(gplot);\n    gplotGenDataFiles(gplot);\n    cmdname = genPathname(gplot->cmdname, NULL);\n\n#ifndef _WIN32\n    snprintf(buf, L_BUF_SIZE, \"gnuplot %s\", cmdname);\n#else\n    snprintf(buf, L_BUF_SIZE, \"wgnuplot %s\", cmdname);\n#endif  \n\n#ifndef OS_IOS \n    ignore = system(buf);  \n#endif \n\n    LEPT_FREE(cmdname);\n    return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  switch (input1->type) {\n    case kTfLiteInt32: {\n      return EvalImpl<int32_t>(context, data->requires_broadcast, input1,\n                               input2, output);\n    }\n    case kTfLiteFloat32: {\n      return EvalImpl<float>(context, data->requires_broadcast, input1, input2,\n                             output);\n    }\n    default: {\n      context->ReportError(context, \"Type '%s' is not supported by floor_div.\",\n                           TfLiteTypeGetName(input1->type));\n      return kTfLiteError;\n    }\n  }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    \n       if ((file_path.Find(\"../\") >= 0) || (file_path.Find(\"..\\\\\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n       const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    \n       NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        \n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        \n        if (timestamp >= file_info.m_ModificationTime) {\n                       NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    \n       if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n       if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n           }\n    \n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  static inline Nan::Persistent<Function> & constructor() {\n    static Nan::Persistent<Function> my_constructor;\n    return my_constructor;\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nBOOL nego_process_negotiation_response(rdpNego* nego, wStream* s)\n{\n\tUINT16 length;\n\tWLog_DBG(TAG, \"RDP_NEG_RSP\");\n\n\tif (Stream_GetRemainingLength(s) < 7)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid RDP_NEG_RSP\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, nego->flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->SelectedProtocol);\n\tnego->state = NEGO_STATE_FINAL;\n\treturn TRUE;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data\n\t\t\t\t\t&& ((st_entry *)stack->elements[i])->type != ST_FIELD)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ntemplate <class T> void testFeatTable(const T & table, const char * testName)\n{\n    FeatureMap testFeatureMap;\n    dummyFace.replace_table(TtfUtil::Tag::Feat, &table, sizeof(T));\n    gr_face * face = gr_make_face_with_ops(&dummyFace, &face_handle::ops, 0);\n    if (!face) throw std::runtime_error(\"failed to load font\");\n    bool readStatus = testFeatureMap.readFeats(*face);\n    testAssert(\"readFeats\", readStatus);\n    fprintf(stderr, testName, NULL);\n    testAssertEqual(\"test num features %hu,%hu\\n\", testFeatureMap.numFeats(), table.m_header.m_numFeat);\n\n    for (size_t i = 0; i < sizeof(table.m_defs) / sizeof(FeatDefn); i++)\n    {\n        const FeatureRef * ref = testFeatureMap.findFeatureRef(table.m_defs[i].m_featId);\n        testAssert(\"test feat\\n\", ref);\n        testAssertEqual(\"test feat settings %hu %hu\\n\", ref->getNumSettings(), table.m_defs[i].m_numFeatSettings);\n        testAssertEqual(\"test feat label %hu %hu\\n\", ref->getNameId(), table.m_defs[i].m_label);\n        size_t settingsIndex = (table.m_defs[i].m_settingsOffset - sizeof(FeatHeader)\n            - (sizeof(FeatDefn) * table.m_header.m_numFeat)) / sizeof(FeatSetting);\n        for (size_t j = 0; j < table.m_defs[i].m_numFeatSettings; j++)\n        {\n            testAssertEqual(\"setting label %hu %hu\\n\", ref->getSettingName(j),\n                       table.m_settings[settingsIndex+j].m_label);\n        }\n    }\n    gr_face_destroy(face);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\npimv1_join_prune_print(netdissect_options *ndo,\n                       register const u_char *bp, register u_int len)\n{\n\tint ngroups, njoin, nprune;\n\tint njp;\n\n\t\n\tif (ND_TTEST2(bp[0], 30) && bp[11] == 1 &&\n\t    ((njoin = EXTRACT_16BITS(&bp[20])) + EXTRACT_16BITS(&bp[22])) == 1) {\n\t\tint hold;\n\n\t\tND_PRINT((ndo, \" RPF %s \", ipaddr_string(ndo, bp)));\n\t\thold = EXTRACT_16BITS(&bp[6]);\n\t\tif (hold != 180) {\n\t\t\tND_PRINT((ndo, \"Hold \"));\n\t\t\tunsigned_relts_print(ndo, hold);\n\t\t}\n\t\tND_PRINT((ndo, \"%s (%s/%d, %s\", njoin ? \"Join\" : \"Prune\",\n\t\tipaddr_string(ndo, &bp[26]), bp[25] & 0x3f,\n\t\tipaddr_string(ndo, &bp[12])));\n\t\tif (EXTRACT_32BITS(&bp[16]) != 0xffffffff)\n\t\t\tND_PRINT((ndo, \"/%s\", ipaddr_string(ndo, &bp[16])));\n\t\tND_PRINT((ndo, \") %s%s %s\",\n\t\t    (bp[24] & 0x01) ? \"Sparse\" : \"Dense\",\n\t\t    (bp[25] & 0x80) ? \" WC\" : \"\",\n\t\t    (bp[25] & 0x40) ? \"RP\" : \"SPT\"));\n\t\treturn;\n\t}\n\n\tif (len < sizeof(struct in_addr))\n\t\tgoto trunc;\n\tND_TCHECK2(bp[0], sizeof(struct in_addr));\n\tif (ndo->ndo_vflag > 1)\n\t\tND_PRINT((ndo, \"\\n\"));\n\tND_PRINT((ndo, \" Upstream Nbr: %s\", ipaddr_string(ndo, bp)));\n\tbp += 4;\n\tlen -= 4;\n\tif (len < 4)\n\t\tgoto trunc;\n\tND_TCHECK2(bp[2], 2);\n\tif (ndo->ndo_vflag > 1)\n\t\tND_PRINT((ndo, \"\\n\"));\n\tND_PRINT((ndo, \" Hold time: \"));\n\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[2]));\n\tif (ndo->ndo_vflag < 2)\n\t\treturn;\n\tbp += 4;\n\tlen -= 4;\n\n\tif (len < 4)\n\t\tgoto trunc;\n\tND_TCHECK2(bp[0], 4);\n\tngroups = bp[3];\n\tbp += 4;\n\tlen -= 4;\n\twhile (ngroups--) {\n\t\t\n\t\tif (len < 4)\n\t\t\tgoto trunc;\n\t\tND_TCHECK2(bp[0], sizeof(struct in_addr));\n\t\tND_PRINT((ndo, \"\\n\\tGroup: %s\", ipaddr_string(ndo, bp)));\n\t\tbp += 4;\n\t\tlen -= 4;\n\t\tif (len < 4)\n\t\t\tgoto trunc;\n\t\tND_TCHECK2(bp[0], sizeof(struct in_addr));\n\t\tif (EXTRACT_32BITS(&bp[0]) != 0xffffffff)\n\t\t\tND_PRINT((ndo, \"/%s\", ipaddr_string(ndo, &bp[0])));\n\t\tbp += 4;\n\t\tlen -= 4;\n\t\tif (len < 4)\n\t\t\tgoto trunc;\n\t\tND_TCHECK2(bp[0], 4);\n\t\tnjoin = EXTRACT_16BITS(&bp[0]);\n\t\tnprune = EXTRACT_16BITS(&bp[2]);\n\t\tND_PRINT((ndo, \" joined: %d pruned: %d\", njoin, nprune));\n\t\tbp += 4;\n\t\tlen -= 4;\n\t\tfor (njp = 0; njp < (njoin + nprune); njp++) {\n\t\t\tconst char *type;\n\n\t\t\tif (njp < njoin)\n\t\t\t\ttype = \"Join \";\n\t\t\telse\n\t\t\t\ttype = \"Prune\";\n\t\t\tif (len < 6)\n\t\t\t\tgoto trunc;\n\t\t\tND_TCHECK2(bp[0], 6);\n\t\t\tND_PRINT((ndo, \"\\n\\t%s %s%s%s%s/%d\", type,\n\t\t\t    (bp[0] & 0x01) ? \"Sparse \" : \"Dense \",\n\t\t\t    (bp[1] & 0x80) ? \"WC \" : \"\",\n\t\t\t    (bp[1] & 0x40) ? \"RP \" : \"SPT \",\n\t\t\t    ipaddr_string(ndo, &bp[2]),\n\t\t\t    bp[1] & 0x3f));\n\t\t\tbp += 6;\n\t\t\tlen -= 6;\n\t\t}\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|pim]\"));\n\treturn;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPHP_FUNCTION(locale_get_display_language)\n{\n    get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint FdInStream::pos()\n{\n  return offset + ptr - start;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"sock=%p\\n\", sock);\n\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &rawsock_raw_ops;\n\t} else {\n\t\tsock->ops = &rawsock_ops;\n\t}\n\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\npdf_t *pdf_new(const char *name)\n{\n    const char *n;\n    pdf_t      *pdf;\n   \n    pdf = safe_calloc(sizeof(pdf_t));\n\n    if (name)\n    {\n        \n        if ((n = strrchr(name, '/')))\n          ++n;\n        else\n          n = name;\n\n        pdf->name = safe_calloc(strlen(n) + 1);\n        strcpy(pdf->name, n);\n    }\n    else \n    {\n        pdf->name = safe_calloc(strlen(\"Unknown\") + 1);\n        strcpy(pdf->name, \"Unknown\");\n    }\n\n    return pdf;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid HTML_put_string(HTStructured * me, const char *s)\n{\n#ifdef USE_PRETTYSRC\n    char *translated_string = NULL;\n#endif\n\n    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))\n\treturn;\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tStrAllocCopy(translated_string, s);\n\tTRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);\n\ts = (const char *) translated_string;\n    }\n#endif\n\n    switch (me->sp[0].tag_number) {\n\n    case HTML_COMMENT:\n\tbreak;\t\t\t\n\n    case HTML_TITLE:\n\tHTChunkPuts(&me->title, s);\n\tbreak;\n\n    case HTML_STYLE:\n\tHTChunkPuts(&me->style_block, s);\n\tbreak;\n\n    case HTML_SCRIPT:\n\tHTChunkPuts(&me->script, s);\n\tbreak;\n\n    case HTML_PRE:\t\t\n    case HTML_LISTING:\t\t\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n\t\n\tHText_appendText(me->text, s);\n\tbreak;\n\n    case HTML_OBJECT:\n\tHTChunkPuts(&me->object, s);\n\tbreak;\n\n    case HTML_TEXTAREA:\n\tHTChunkPuts(&me->textarea, s);\n\tbreak;\n\n    case HTML_SELECT:\n    case HTML_OPTION:\n\tHTChunkPuts(&me->option, s);\n\tbreak;\n\n    case HTML_MATH:\n\tHTChunkPuts(&me->math, s);\n\tbreak;\n\n    default:\t\t\t\n\tif (!me->sp->style->freeFormat) {\n\t    \n#ifdef USE_PRETTYSRC\n\t    if (psrc_view) {\n\t\t\n\t\tfor (; *s; ++s)\n\t\t    HTML_put_character(me, *s);\n\t    } else\n#endif\n\t\tHText_appendText(me->text, s);\n\t    break;\n\t} else {\n\t    const char *p = s;\n\t    char c;\n\n\t    if (me->style_change) {\n\t\tfor (; *p && ((*p == '\\n') || (*p == '\\r') ||\n\t\t\t      (*p == ' ') || (*p == '\\t')); p++) ;\t\n\t\tif (!*p)\n\t\t    break;\n\t\tUPDATE_STYLE;\n\t    }\n\t    for (; *p; p++) {\n\t\tif (*p == 13 && p[1] != 10) {\n\t\t    \n\t\t    c = '\\n';\n\t\t} else {\n\t\t    c = *p;\n\t\t}\n\t\tif (me->style_change) {\n\t\t    if ((c == '\\n') || (c == ' ') || (c == '\\t'))\n\t\t\tcontinue;\t\n\t\t    UPDATE_STYLE;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t    if (!FIX_JAPANESE_SPACES) {\n\t\t\tif (me->in_word) {\n\t\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\t\tHText_appendCharacter(me->text, ' ');\n\t\t\t    me->in_word = NO;\n\t\t\t}\n\t\t    }\n\n\t\t} else if (c == ' ' || c == '\\t') {\n\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\tHText_appendCharacter(me->text, ' ');\n\n\t\t} else if (c == '\\r') {\n\t\t    \n\t\t} else {\n\t\t    HText_appendCharacter(me->text, c);\n\t\t    me->in_word = YES;\n\t\t}\n\n\t\t\n\t\tif (c == '\\n' || c == '\\t') {\n\t\t    \n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else if (c == '\\r' &&\n\t\t\t   HText_getLastChar(me->text) == ' ') {\n\t\t    \n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else {\n\t\t    HText_setLastChar(me->text, c);\n\t\t}\n\n\t    }\t\t\t\n\t}\n    }\t\t\t\t\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tpsrc_convert_string = FALSE;\n\tFREE(translated_string);\n    }\n#endif\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\njuniper_atm1_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n\n        struct juniper_l2info_t l2info;\n\n        l2info.pictype = DLT_JUNIPER_ATM1;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n\n        if (l2info.cookie[0] == 0x80) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n\n        ND_TCHECK2(p[0], 3);\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n\n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1);\n            \n            return l2info.header_len;\n        }\n\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\n\treturn l2info.header_len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_atm1]\"));\n\treturn l2info.header_len;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nexif_mnote_data_canon_load (ExifMnoteData *ne,\n\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tExifShort c;\n\tsize_t i, tcount, o, datao;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif ((datao + 2 < datao) || (datao + 2 < 2) || (datao + 2 > buf_size)) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t\n\texif_mnote_data_canon_clear (n);\n\n\t\n\tn->entries = exif_mem_alloc (ne->mem, sizeof (MnoteCanonEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", sizeof (MnoteCanonEntry) * c);\n\t\treturn;\n\t}\n\n\t\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\t\tif ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\"ExifMnoteCanon\", \"Short MakerNote\");\n\t\t\tbreak;\n\t        }\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteCanon\",\n\t\t\t\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t mnote_canon_tag_get_name (n->entries[tcount].tag));\n\n\t\t\n\t\ts = exif_format_get_size (n->entries[tcount].format) * \n\t\t\t\t\t\t\t\t  n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (!s) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\",\n\t\t\t\t  \"Invalid zero-length tag size\");\n\t\t\tcontinue;\n\n\t\t} else {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\t\t\tif ((dataofs + s < s) || (dataofs + s < dataofs) || (dataofs + s > buf_size)) {\n\t\t\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\"ExifMnoteCanon\",\n\t\t\t\t\t\"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t(unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (ne->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t\n\t\t++tcount;\n\t}\n\t\n\tn->count = tcount;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid trustedEnclaveInit(uint32_t _logLevel) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n\n    globalLogLevel_ = _logLevel;\n\n    oc_realloc_func = &reallocate_function;\n    oc_free_func = &free_function;\n\n    LOG_INFO(\"Setting memory functions\");\n\n    mp_get_memory_functions(NULL, &gmp_realloc_func, &gmp_free_func);\n    mp_set_memory_functions(NULL, oc_realloc_func, oc_free_func);\n\n    LOG_INFO(\"Calling enclave init\");\n\n\n    enclave_init();\n\n\n    LOG_INFO(\"Reading random\");\n\n    globalRandom = calloc(32,1);\n\n    int ret = sgx_read_rand(globalRandom, 32);\n\n    if(ret != SGX_SUCCESS)\n    {\n        LOG_ERROR(\"sgx_read_rand failed. Aboring enclave.\");\n        abort();\n    }\n\n    LOG_INFO(\"Successfully inited enclave. Signed enclave version:\" SIGNED_ENCLAVE_VERSION );\n#ifndef SGX_DEBUG\n    LOG_INFO(\"SECURITY WARNING: sgxwallet is running in INSECURE DEBUG MODE! NEVER USE IN PRODUCTION!\");\n#endif\n\n#if SGX_DEBUG != 0\n    LOG_INFO(\"SECURITY WARNING: sgxwallet is running in INSECURE DEBUG MODE! NEVER USE IN PRODUCTION!\");\n#endif\n\n#if SGX_MODE == SIM\n    LOG_INFO(\"SECURITY WARNING: sgxwallet is running in INSECURE SIMULATION MODE! NEVER USE IN PRODUCTION!\");\n#endif\n\n\n\n\n\n\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\n\t\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset))) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  int max_index = -1;\n  const int segment_id_size = segment_ids->dims->data[0];\n  if (segment_id_size > 0) {\n    max_index = segment_ids->data.i32[segment_id_size - 1];\n  }\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0) {\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t\tif (bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsysContact_handler(snmp_varbind_t *varbind, snmp_oid_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"Contiki-NG, https://github.com/contiki-ng/contiki-ng\");\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\n\t\n\tif (len < sizeof(sctp_assoc_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&sas, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\n\t\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\n\t\n\tasoc->stats.max_obs_rto = asoc->rto_min;\n\n\t\n\tlen = min_t(size_t, len, sizeof(sas));\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus EvalHybridPerChannel(TfLiteContext* context, TfLiteNode* node,\n                                  TfLiteDepthwiseConvParams* params,\n                                  OpData* data, const TfLiteTensor* input,\n                                  const TfLiteTensor* filter,\n                                  const TfLiteTensor* bias,\n                                  TfLiteTensor* output) {\n  float output_activation_min, output_activation_max;\n  CalculateActivationRange(params->activation, &output_activation_min,\n                           &output_activation_max);\n  const int input_size = NumElements(input) / SizeOfDimension(input, 0);\n  const int batch_size = SizeOfDimension(input, 0);\n  const TfLiteTensor* input_quantized =\n      GetTemporary(context, node, data->input_quantized_index);\n  int8_t* quantized_input_ptr_batch = input_quantized->data.int8;\n  float* scaling_factors_ptr = GetTensorData<float>(\n      GetTemporary(context, node, data->scaling_factors_index));\n  int32_t* input_offset_ptr = GetTensorData<int32_t>(\n      GetTemporary(context, node, data->input_offset_index));\n\n  for (int b = 0; b < batch_size; ++b) {\n    const int offset = b * input_size;\n    tensor_utils::AsymmetricQuantizeFloats(\n        GetTensorData<float>(input) + offset, input_size,\n        quantized_input_ptr_batch + offset, &scaling_factors_ptr[b],\n        &input_offset_ptr[b]);\n  }\n\n  DepthwiseParams op_params;\n  op_params.padding_type = PaddingType::kSame;\n  op_params.padding_values.width = data->padding.width;\n  op_params.padding_values.height = data->padding.height;\n  op_params.stride_width = params->stride_width;\n  op_params.stride_height = params->stride_height;\n  op_params.dilation_width_factor = params->dilation_width_factor;\n  op_params.dilation_height_factor = params->dilation_height_factor;\n  op_params.depth_multiplier = params->depth_multiplier;\n\n  op_params.weights_offset = 0;\n  op_params.float_activation_min = output_activation_min;\n  op_params.float_activation_max = output_activation_max;\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);\n  if (kernel_type == kReference) {\n    reference_integer_ops::DepthwiseConvHybridPerChannel(\n        op_params, scaling_factors_ptr, GetTensorShape(input),\n        quantized_input_ptr_batch, GetTensorShape(filter),\n        GetTensorData<int8>(filter), GetTensorShape(bias),\n        GetTensorData<float>(bias), GetTensorShape(output),\n        GetTensorData<float>(output), affine_quantization->scale->data,\n        input_offset_ptr);\n  } else {\n    optimized_integer_ops::DepthwiseConvHybridPerChannel(\n        op_params, scaling_factors_ptr, GetTensorShape(input),\n        quantized_input_ptr_batch, GetTensorShape(filter),\n        GetTensorData<int8>(filter), GetTensorShape(bias),\n        GetTensorData<float>(bias), GetTensorShape(output),\n        GetTensorData<float>(output), affine_quantization->scale->data,\n        input_offset_ptr, CpuBackendContext::GetFromContext(context));\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint insn_get_code_seg_params(struct pt_regs *regs)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\n\tif (v8086_mode(regs))\n\t\t\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\n\tsel = get_segment_selector(regs, INAT_SEG_REG_CS);\n\tif (sel < 0)\n\t\treturn sel;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t\n\tif (!(desc->type & BIT(3)))\n\t\treturn -EINVAL;\n\n\tswitch ((desc->l << 1) | desc->d) {\n\tcase 0: \n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tcase 1: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 4);\n\tcase 2: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 8);\n\tcase 3: \n\t\t\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nterm_and_job_init(\n\tterm_T\t    *term,\n\ttypval_T    *argvar,\n\tchar\t    **argv,\n\tjobopt_T    *opt,\n\tjobopt_T    *orig_opt UNUSED)\n{\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (opt->jo_set2 & JO2_ANSI_COLORS)\n\tset_vterm_palette(term->tl_vterm, opt->jo_ansi_colors);\n    else\n\tinit_vterm_ansi_colors(term->tl_vterm);\n#endif\n\n    \n    term->tl_job = job_start(argvar, argv, opt, TRUE);\n    if (term->tl_job != NULL)\n\t++term->tl_job->jv_refcount;\n\n    return term->tl_job != NULL\n\t&& term->tl_job->jv_channel != NULL\n\t&& term->tl_job->jv_status != JOB_FAILED ? OK : FAIL;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus NonMaxSuppressionMultiClass(TfLiteContext* context,\n                                         TfLiteNode* node, OpData* op_data) {\n   const TfLiteTensor* input_box_encodings;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorBoxEncodings,\n                                 &input_box_encodings));\n  const TfLiteTensor* input_class_predictions;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorClassPredictions,\n                                 &input_class_predictions));\n  const int num_boxes = input_box_encodings->dims->data[1];\n  const int num_classes = op_data->num_classes;\n  TF_LITE_ENSURE_EQ(context, input_class_predictions->dims->data[0],\n                    kBatchSize);\n  TF_LITE_ENSURE_EQ(context, input_class_predictions->dims->data[1], num_boxes);\n  const int num_classes_with_background =\n      input_class_predictions->dims->data[2];\n\n  TF_LITE_ENSURE(context, (num_classes_with_background - num_classes <= 1));\n  TF_LITE_ENSURE(context, (num_classes_with_background >= num_classes));\n\n  const TfLiteTensor* scores;\n  switch (input_class_predictions->type) {\n    case kTfLiteUInt8: {\n      TfLiteTensor* temporary_scores = &context->tensors[op_data->scores_index];\n      DequantizeClassPredictions(input_class_predictions, num_boxes,\n                                 num_classes_with_background, temporary_scores);\n      scores = temporary_scores;\n    } break;\n    case kTfLiteFloat32:\n      scores = input_class_predictions;\n      break;\n    default:\n           return kTfLiteError;\n  }\n  if (op_data->use_regular_non_max_suppression)\n    TF_LITE_ENSURE_STATUS(NonMaxSuppressionMultiClassRegularHelper(\n        context, node, op_data, GetTensorData<float>(scores)));\n  else\n    TF_LITE_ENSURE_STATUS(NonMaxSuppressionMultiClassFastHelper(\n        context, node, op_data, GetTensorData<float>(scores)));\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success)\n{\n    if (wcschr(Src,(wchar)MappedStringMark)==NULL)\n    return false;\n\n  Success=true;\n  uint SrcPos=0,DestPos=0;\n  while (Src[SrcPos]!=0 && DestPos<DestSize-MB_CUR_MAX)\n  {\n    if (uint(Src[SrcPos])==MappedStringMark)\n    {\n      SrcPos++;\n      continue;\n    }\n          if (uint(Src[SrcPos])>=MapAreaStart+0x80 && uint(Src[SrcPos])<MapAreaStart+0x100)\n      Dest[DestPos++]=char(uint(Src[SrcPos++])-MapAreaStart);\n    else\n    {\n      mbstate_t ps;\n      memset(&ps,0,sizeof(ps));\n      if (wcrtomb(Dest+DestPos,Src[SrcPos],&ps)==-1)\n      {\n        Dest[DestPos]='_';\n        Success=false;\n      }\n      SrcPos++;\n      memset(&ps,0,sizeof(ps));\n      int Length=mbrlen(Dest+DestPos,MB_CUR_MAX,&ps);\n      DestPos+=Max(Length,1);\n    }\n  }\n  Dest[Min(DestPos,DestSize-1)]=0;\n  return true;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid SpaceToBatch(XlaOpKernelContext* ctx, const xla::XlaOp& input,\n                  DataType input_dtype, const TensorShape& input_tensor_shape,\n                  absl::Span<const int64_t> block_shape,\n                  const xla::Literal& paddings) {\n  const int input_rank = input_tensor_shape.dims();\n  const absl::InlinedVector<int64_t, 4> input_shape =\n      input_tensor_shape.dim_sizes();\n  const int block_rank = block_shape.size();\n\n  OP_REQUIRES(\n      ctx, input_rank >= 1 + block_rank,\n      errors::InvalidArgument(\"input rank should be >= \", 1 + block_rank,\n                              \" instead of \", input_rank));\n  absl::Span<const int64_t> remainder_shape(input_shape);\n  remainder_shape.remove_prefix(1 + block_rank);\n\n  OP_REQUIRES(\n      ctx,\n      paddings.shape().rank() == 2 &&\n          block_rank == xla::ShapeUtil::GetDimension(paddings.shape(), 0) &&\n          2 == xla::ShapeUtil::GetDimension(paddings.shape(), 1),\n      errors::InvalidArgument(\"paddings should have shape [\", block_rank,\n                              \", 2] instead of \",\n                              xla::ShapeUtil::HumanString(paddings.shape())));\n\n  xla::XlaBuilder* b = ctx->builder();\n\n    xla::PaddingConfig padding_config;\n  std::vector<int64_t> padded_shape(input_shape.begin(), input_shape.end());\n  int64_t block_num_elems = 1LL;\n  padding_config.add_dimensions();   for (int i = 0; i < block_rank; ++i) {\n    auto* dim = padding_config.add_dimensions();\n    int64_t pad_start = paddings.Get<int64_t>({i, 0});\n    int64_t pad_end = paddings.Get<int64_t>({i, 1});\n    OP_REQUIRES(ctx, pad_start >= 0 && pad_end >= 0,\n                errors::InvalidArgument(\"Paddings must be non-negative\"));\n    dim->set_edge_padding_low(pad_start);\n    dim->set_edge_padding_high(pad_end);\n    padded_shape[1 + i] += pad_start + pad_end;\n    block_num_elems *= block_shape[i];\n  }\n   for (int i = 0; i < remainder_shape.size(); ++i) {\n    padding_config.add_dimensions();\n  }\n  OP_REQUIRES(ctx, block_num_elems > 0,\n              errors::InvalidArgument(\n                  \"The product of the block dimensions must be positive\"));\n\n  xla::XlaOp padded =\n      xla::Pad(input, XlaHelpers::Zero(b, input_dtype), padding_config);\n\n           const int64_t batch_size = input_shape[0];\n  std::vector<int64_t> reshaped_padded_shape(input_rank + block_rank);\n  reshaped_padded_shape[0] = batch_size;\n  for (int i = 0; i < block_rank; ++i) {\n    OP_REQUIRES(ctx, padded_shape[1 + i] % block_shape[i] == 0,\n                errors::InvalidArgument(\"padded_shape[\", 1 + i,\n                                        \"]=\", padded_shape[1 + i],\n                                        \" is not divisible by block_shape[\", i,\n                                        \"]=\", block_shape[i]));\n\n    reshaped_padded_shape[1 + i * 2] = padded_shape[1 + i] / block_shape[i];\n    reshaped_padded_shape[1 + i * 2 + 1] = block_shape[i];\n  }\n  std::copy(remainder_shape.begin(), remainder_shape.end(),\n            reshaped_padded_shape.begin() + 1 + 2 * block_rank);\n\n  xla::XlaOp reshaped_padded = xla::Reshape(padded, reshaped_padded_shape);\n\n           std::vector<int64_t> permutation(reshaped_padded_shape.size());\n  for (int i = 0; i < block_rank; ++i) {\n    permutation[i] = 1 + 2 * i + 1;\n    permutation[block_rank + 1 + i] = 1 + 2 * i;\n  }\n  permutation[block_rank] = 0;\n  std::iota(permutation.begin() + 1 + block_rank * 2, permutation.end(),\n            1 + block_rank * 2);\n  xla::XlaOp permuted_reshaped_padded =\n      xla::Transpose(reshaped_padded, permutation);\n\n            std::vector<int64_t> output_shape(input_rank);\n  output_shape[0] = batch_size * block_num_elems;\n  for (int i = 0; i < block_rank; ++i) {\n    output_shape[1 + i] = padded_shape[1 + i] / block_shape[i];\n  }\n  std::copy(remainder_shape.begin(), remainder_shape.end(),\n            output_shape.begin() + 1 + block_rank);\n\n  xla::XlaOp output = xla::Reshape(permuted_reshaped_padded, output_shape);\n  ctx->SetOutput(0, output);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid gen_SEK() {\n    vector<char> errMsg(1024, 0);\n    int err_status = 0;\n    vector <uint8_t> encrypted_SEK(1024, 0);\n    uint64_t enc_len = 0;\n\n    SAFE_CHAR_BUF(SEK, 65);\n\n    spdlog::info(\"Generating backup key. Will be stored in backup_key.txt ... \");\n\n    sgx_status_t status = trustedGenerateSEK(eid, &err_status, errMsg.data(), encrypted_SEK.data(), &enc_len, SEK);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());\n\n\n    if (strnlen(SEK, 33) != 32) {\n        throw SGXException(-1, \"strnlen(SEK,33) != 32\");\n    }\n\n    vector<char> hexEncrKey(2 * enc_len + 1, 0);\n\n    carray2Hex(encrypted_SEK.data(), enc_len, hexEncrKey.data(), 2 * enc_len + 1);\n\n    spdlog::info(string(\"Encrypted storage encryption key:\") + hexEncrKey.data());\n\n    ofstream sek_file(BACKUP_PATH);\n    sek_file.clear();\n\n    sek_file << SEK;\n\n\n    cout << \"ATTENTION! YOUR BACKUP KEY HAS BEEN WRITTEN INTO sgx_data/backup_key.txt \\n\" <<\n         \"PLEASE COPY IT TO THE SAFE PLACE AND THEN DELETE THE FILE MANUALLY BY RUNNING THE FOLLOWING COMMAND:\\n\" <<\n         \"apt-get install secure-delete && srm -vz sgx_data/backup_key.txt\" << endl;\n\n\n    if (!autoconfirm) {\n        string confirm_str = \"I confirm\";\n        string buffer;\n        do {\n            cout << \" DO YOU CONFIRM THAT YOU COPIED THE KEY? (if you confirm type - I confirm)\"\n                 << endl;\n            getline(cin, buffer);\n        } while (case_insensitive_match(confirm_str, buffer));\n    }\n\n\n    LevelDB::getLevelDb()->writeDataUnique(\"SEK\", hexEncrKey.data());\n\n    create_test_key();\n\n    validate_SEK();\n\n    shared_ptr <string> encrypted_SEK_ptr = LevelDB::getLevelDb()->readString(\"SEK\");\n\n    setSEK(encrypted_SEK_ptr);\n\n    validate_SEK();\n\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid error_handler(int priority, const char *format, ...)\n{\n    gdTestAssert(priority == GD_WARNING);\n    gdTestAssert(!strcmp(format, MSG));\n}\n\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void rose_loopback_timer(unsigned long param)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\trose_address *dest;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci_i, lci_o;\n\n\twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n\t\tif (skb->len < ROSE_MIN_LEN) {\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tlci_i     = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\t\tframetype = skb->data[2];\n\t\tif (frametype == ROSE_CALL_REQUEST &&\n\t\t    (skb->len <= ROSE_CALL_REQ_FACILITIES_OFF ||\n\t\t     skb->data[ROSE_CALL_REQ_ADDR_LEN_OFF] !=\n\t\t     ROSE_CALL_REQ_ADDR_LEN_VAL)) {\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tdest      = (rose_address *)(skb->data + ROSE_CALL_REQ_DEST_ADDR_OFF);\n\t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n\n\t\tskb_reset_transport_header(skb);\n\n\t\tsk = rose_find_socket(lci_o, rose_loopback_neigh);\n\t\tif (sk) {\n\t\t\tif (rose_process_rx_frame(sk, skb) == 0)\n\t\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tif ((dev = rose_dev_get(dest)) != NULL) {\n\t\t\t\tif (rose_rx_call_request(skb, dev, rose_loopback_neigh, lci_o) == 0)\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void expectTrailers(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onTrailers(testing::_))\n          .WillOnce(testing::InvokeWithoutArgs(callback))\n          .RetiresOnSaturation();\n    } else {\n      EXPECT_CALL(*this, onTrailers(testing::_));\n    }\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key)) {\n\t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbit_write_MC (Bit_Chain *dat, BITCODE_MC val)\n{\n  int i, j;\n  int negative = 0;\n  unsigned char byte[5];\n  BITCODE_UMC mask = 0x0000007f;\n  BITCODE_UMC value = (BITCODE_UMC)val;\n\n  if (val < 0)\n    {\n      negative = 1;\n      value = (BITCODE_UMC)-val;\n    }\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  if (negative)\n    byte[i] |= 0x40;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    LutContext *s = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    AVFrame *out;\n    uint8_t *inrow, *outrow, *inrow0, *outrow0;\n    int i, j, plane, direct = 0;\n\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n\n    if (s->is_rgb) {\n        \n        inrow0  = in ->data[0];\n        outrow0 = out->data[0];\n\n        for (i = 0; i < in->height; i ++) {\n            int w = inlink->w;\n            const uint8_t (*tab)[256] = (const uint8_t (*)[256])s->lut;\n            inrow  = inrow0;\n            outrow = outrow0;\n            for (j = 0; j < w; j++) {\n                switch (s->step) {\n                case 4:  outrow[3] = tab[3][inrow[3]];                case 3:  outrow[2] = tab[2][inrow[2]];                case 2:  outrow[1] = tab[1][inrow[1]];                default: outrow[0] = tab[0][inrow[0]];\n                }\n                outrow += s->step;\n                inrow  += s->step;\n            }\n            inrow0  += in ->linesize[0];\n            outrow0 += out->linesize[0];\n        }\n    } else {\n        \n        for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n            int vsub = plane == 1 || plane == 2 ? s->vsub : 0;\n            int hsub = plane == 1 || plane == 2 ? s->hsub : 0;\n            int h = FF_CEIL_RSHIFT(inlink->h, vsub);\n            int w = FF_CEIL_RSHIFT(inlink->w, hsub);\n\n            inrow  = in ->data[plane];\n            outrow = out->data[plane];\n\n            for (i = 0; i < h; i++) {\n                const uint8_t *tab = s->lut[plane];\n                for (j = 0; j < w; j++)\n                    outrow[j] = tab[inrow[j]];\n                inrow  += in ->linesize[plane];\n                outrow += out->linesize[plane];\n            }\n        }\n    }\n\n    if (!direct)\n        av_frame_free(&in);\n\n    return ff_filter_frame(outlink, out);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (sec_attr == NULL) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,\n                                       TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n   const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  if (input->type != kTfLiteUInt8) return kTfLiteError;\n  if (NumElements(input->dims) == 0) return kTfLiteError;\n\n   TF_LITE_ENSURE_STATUS(context->RequestScratchBufferInArena(\n      context, sizeof(uint8_t) * NumElements(input->dims),\n      &data->sorting_buffer));\n   data->invoke_count = reinterpret_cast<int*>(\n      context->AllocatePersistentBuffer(context, sizeof(int)));\n  *data->invoke_count = 0;\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nR_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_io_submap_to (bd) == r_io_submap_to (sm) &&\n\t\tr_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t\t\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\tfree (sm);\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t\tbool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tif (!a) {\n\t\t\tbreak;\n\t\t}\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\tfree (sm);\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tr_list_append (bank->maprefs, mapref);\n\treturn true;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int get_time_seed()\n{\n    DEBUG_SEED(\"get_time_seed\");\n    \n    return (int)time(NULL) * 433494437;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nRemoteFsDevice::RemoteFsDevice(MusicLibraryModel *m, const DeviceOptions &options, const Details &d)\n    : FsDevice(m, d.name, createUdi(d.name))\n    , mountToken(0)\n    , currentMountStatus(false)\n    , details(d)\n    , proc(0)\n    , mounterIface(0)\n    , messageSent(false)\n{\n    opts=options;    load();\n    mount();\n    icn=MonoIcon::icon(details.isLocalFile()\n                       ? FontAwesome::foldero\n                       : constSshfsProtocol==details.url.scheme()\n                         ? FontAwesome::linux_os\n                         : FontAwesome::windows, Utils::monoIconColor());\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Path Traversal"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void snd_usb_mixer_free(struct usb_mixer_interface *mixer)\n{\n\t\n\tsnd_usb_mixer_disconnect(mixer);\n\n\tkfree(mixer->id_elems);\n\tif (mixer->urb) {\n\t\tkfree(mixer->urb->transfer_buffer);\n\t\tusb_free_urb(mixer->urb);\n\t}\n\tusb_free_urb(mixer->rc_urb);\n\tkfree(mixer->rc_setup_packet);\n\tkfree(mixer);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, ( int )strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, ( int )strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tbitmap_set(base, find_object_pos(object->oid.hash));\n\tmark_as_seen(object);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void handle_service(HttpRequest req, HttpResponse res) {\n        char *name = req->url;\n        Service_T s = Util_getService(++name);\n        if (! s) {\n                send_error(req, res, SC_NOT_FOUND, \"There is no service named \\\"%s\\\"\", name ? name : \"\");\n                return;\n        }\n        do_service(req, res, s);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid send_file_direct(char *file_name) {\n   int fh, i, length, delta;\n   char str[MAX_PATH_LENGTH], dir[MAX_PATH_LENGTH], charset[80];\n\n   getcwd(dir, sizeof(dir));\n   fh = open(file_name, O_RDONLY | O_BINARY);\n   if (fh > 0) {\n      lseek(fh, 0, SEEK_END);\n      length = TELL(fh);\n      lseek(fh, 0, SEEK_SET);\n\n      rsprintf(\"HTTP/1.1 200 Document follows\\r\\n\");\n      rsprintf(\"Server: ELOG HTTP %s-%s\\r\\n\", VERSION, git_revision());\n      rsprintf(\"Accept-Ranges: bytes\\r\\n\");\n\n      \n      if (isparam(\"thumb\")) {\n         rsprintf(\"Pragma: no-cache\\r\\n\");\n         rsprintf(\"Cache-control: private, max-age=0, no-cache, no-store\\r\\n\");\n      } else {\n         rsprintf(\"Cache-control: public, max-age=86400\\r\\n\");\n      }\n\n      if (keep_alive) {\n         rsprintf(\"Connection: Keep-Alive\\r\\n\");\n         rsprintf(\"Keep-Alive: timeout=60, max=10\\r\\n\");\n      }\n\n      \n      for (i = 0; i < (int) strlen(file_name); i++)\n         str[i] = toupper(file_name[i]);\n      str[i] = 0;\n\n      for (i = 0; filetype[i].ext[0]; i++)\n         if (chkext(str, filetype[i].ext))\n            break;\n\n      if (!getcfg(\"global\", \"charset\", charset, sizeof(charset)))\n         strcpy(charset, DEFAULT_HTTP_CHARSET);\n\n      if (filetype[i].ext[0]) {\n         if (strncmp(filetype[i].type, \"text\", 4) == 0)\n            rsprintf(\"Content-Type: %s;charset=%s\\r\\n\", filetype[i].type, charset);\n         else\n            rsprintf(\"Content-Type: %s\\r\\n\", filetype[i].type);\n      } else if (is_ascii(file_name))\n         rsprintf(\"Content-Type: text/plain;charset=%s\\r\\n\", charset);\n      else\n         rsprintf(\"Content-Type: application/octet-stream;charset=%s\\r\\n\", charset);\n\n      rsprintf(\"Content-Length: %d\\r\\n\\r\\n\", length);\n\n      \n      if (length > return_buffer_size - (int) strlen(return_buffer)) {\n         delta = length - (return_buffer_size - strlen(return_buffer)) + 1000;\n\n         return_buffer = xrealloc(return_buffer, return_buffer_size + delta);\n         memset(return_buffer + return_buffer_size, 0, delta);\n         return_buffer_size += delta;\n      }\n\n      return_length = strlen(return_buffer) + length;\n      read(fh, return_buffer + strlen(return_buffer), length);\n\n      close(fh);\n   } else {\n      char encodedname[256];\n      show_html_header(NULL, FALSE, \"404 Not Found\", TRUE, FALSE, NULL, FALSE, 0);\n\n      rsprintf(\"<body><h1>Not Found</h1>\\r\\n\");\n      rsprintf(\"The requested file <b>\");\n      strencode2(encodedname, file_name, sizeof(encodedname));\n      if (strchr(file_name, DIR_SEPARATOR))\n         rsprintf(\"%s\", encodedname);\n      else\n         rsprintf(\"%s%c%s\", dir, DIR_SEPARATOR, encodedname);\n      rsprintf(\"</b> was not found on this server<p>\\r\\n\");\n      rsprintf(\"<hr><address>ELOG version %s</address></body></html>\\r\\n\\r\\n\", VERSION);\n      return_length = strlen_retbuf;\n      keep_alive = FALSE;\n   }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Cross Site Scripting"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic UINT printer_process_irp_write(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\trdpPrintJob* printjob = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\n\tif (printer_dev->printer)\n\t\tprintjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);\n\n\tif (!printjob)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse\n\t{\n\t\terror = printjob->Write(printjob, Stream_Pointer(irp->input), Length);\n\t}\n\n\tif (error)\n\t{\n\t\tWLog_ERR(TAG, \"printjob->Write failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid Transform::interpolate_nearestneighbour( RawTile& in, unsigned int resampled_width, unsigned int resampled_height ){\n\n   unsigned char *input = (unsigned char*) in.data;\n\n  int channels = in.channels;\n  unsigned int width = in.width;\n  unsigned int height = in.height;\n\n   unsigned char *output;\n\n   bool new_buffer = false;\n  if( resampled_width*resampled_height > in.width*in.height ){\n    new_buffer = true;\n    output = new unsigned char[(unsigned long long)resampled_width*resampled_height*in.channels];\n  }\n  else output = (unsigned char*) in.data;\n\n   float xscale = (float)width / (float)resampled_width;\n  float yscale = (float)height / (float)resampled_height;\n\n  for( unsigned int j=0; j<resampled_height; j++ ){\n    for( unsigned int i=0; i<resampled_width; i++ ){\n\n                unsigned long ii = (unsigned int) floorf(i*xscale);\n      unsigned long jj = (unsigned int) floorf(j*yscale);\n      unsigned long pyramid_index = (unsigned int) channels * ( ii + jj*width );\n\n      unsigned long long resampled_index = (unsigned long long)(i + j*resampled_width)*channels;\n      for( int k=0; k<in.channels; k++ ){\n\toutput[resampled_index+k] = input[pyramid_index+k];\n      }\n    }\n  }\n\n   if( new_buffer ) delete[] (unsigned char*) input;\n\n   in.width = resampled_width;\n  in.height = resampled_height;\n  in.dataLength = resampled_width * resampled_height * channels * (in.bpc/8);\n  in.data = output;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int wdm_post_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\n\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\tclear_bit(WDM_RESETTING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nrndr_quote(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\n\tBUFPUTSL(ob, \"<q>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</q>\");\n\n\treturn 1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Cross Site Scripting"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nSYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint __user *, addr_len)\n{\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tstruct sockaddr_storage address;\n\tint err, err2;\n\tint fput_needed;\n\n\tif (size > INT_MAX)\n\t\tsize = INT_MAX;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov = &iov;\n\tiov.iov_len = size;\n\tiov.iov_base = ubuf;\n\tmsg.msg_name = (struct sockaddr *)&address;\n\tmsg.msg_namelen = sizeof(address);\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = sock_recvmsg(sock, &msg, size, flags);\n\n\tif (err >= 0 && addr != NULL) {\n\t\terr2 = move_addr_to_user(&address,\n\t\t\t\t\t msg.msg_namelen, addr, addr_len);\n\t\tif (err2 < 0)\n\t\t\terr = err2;\n\t}\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nclear_evalarg(evalarg_T *evalarg, exarg_T *eap)\n{\n    if (evalarg != NULL)\n    {\n\tif (evalarg->eval_tofree != NULL)\n\t{\n\t    if (eap != NULL)\n\t    {\n\t\t\t\t\tvim_free(eap->cmdline_tofree);\n\t\teap->cmdline_tofree = *eap->cmdlinep;\n\t\t*eap->cmdlinep = evalarg->eval_tofree;\n\t    }\n\t    else\n\t\tvim_free(evalarg->eval_tofree);\n\t    evalarg->eval_tofree = NULL;\n\t}\n\n\tga_clear_strings(&evalarg->eval_tofree_ga);\n\tVIM_CLEAR(evalarg->eval_tofree_lambda);\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n\n\tif (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {\n\t\tcrypto_skcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((unsigned long)key & alignmask)\n\t\treturn skcipher_setkey_unaligned(tfm, key, keylen);\n\n\treturn cipher->setkey(tfm, key, keylen);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nhtmlGetText(tree_t *t)\t\t\n{\n  uchar\t\t*s,\t\t\t*s2,\t\t\t*tdata = NULL,\t\t*talloc = NULL;  size_t\tslen,\t\t\ttlen;\t\n\n   slen = 0;\n  s    = NULL;\n\n  while (t != NULL)\n  {\n    if (t->child)\n      tdata = talloc = htmlGetText(t->child);\n    else\n      tdata = t->data;\n\n    if (tdata != NULL)\n    {\n           tlen = strlen((char *)tdata);\n\n      if (s)\n        s2 = (uchar *)realloc(s, 1 + slen + tlen);\n      else\n        s2 = (uchar *)malloc(1 + tlen);\n\n      if (!s2)\n        break;\n\n      s = s2;\n\n      memcpy((char *)s + slen, (char *)tdata, tlen);\n\n      slen += tlen;\n\n      if (talloc)\n      {\n\tfree(talloc);\n\ttalloc = NULL;\n      }\n    }\n\n    t = t->next;\n  }\n\n  if (slen)\n    s[slen] = '\\0';\n\n  if (talloc)\n    free(talloc);\n\n  return (s);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nWith(asdl_seq * items, asdl_seq * body, string type_comment, int lineno, int\n     col_offset, int end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = With_kind;\n    p->v.With.items = items;\n    p->v.With.body = body;\n    p->v.With.type_comment = type_comment;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int spl_filesystem_file_open(spl_filesystem_object *intern, int use_include_path, int silent TSRMLS_DC) \n{\n\tzval  tmp;\n\n\tintern->type = SPL_FS_FILE;\n\n\tphp_stat(intern->file_name, intern->file_name_len, FS_IS_DIR, &tmp TSRMLS_CC);\n\tif (Z_LVAL(tmp)) {\n\t\tintern->u.file.open_mode = NULL;\n\t\tintern->file_name = NULL;\n\t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Cannot use SplFileObject with directories\");\n\t\treturn FAILURE;\n\t}\n\n\tintern->u.file.context = php_stream_context_from_zval(intern->u.file.zcontext, 0);\n\tintern->u.file.stream = php_stream_open_wrapper_ex(intern->file_name, intern->u.file.open_mode, (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, intern->u.file.context);\n\n\tif (!intern->file_name_len || !intern->u.file.stream) {\n\t\tif (!EG(exception)) {\n\t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot open file '%s'\", intern->file_name_len ? intern->file_name : \"\");\n\t\t}\n\t\tintern->file_name = NULL; \n\t\tintern->u.file.open_mode = NULL;\n\t\treturn FAILURE;\n\t}\n\n\tif (intern->u.file.zcontext) {\n\t\tzend_list_addref(Z_RESVAL_P(intern->u.file.zcontext));\n\t}\n\n\tif (intern->file_name_len > 1 && IS_SLASH_AT(intern->file_name, intern->file_name_len-1)) {\n\t\tintern->file_name_len--;\n\t}\n\n\tintern->orig_path = estrndup(intern->u.file.stream->orig_path, strlen(intern->u.file.stream->orig_path));\n\n\tintern->file_name = estrndup(intern->file_name, intern->file_name_len);\n\tintern->u.file.open_mode = estrndup(intern->u.file.open_mode, intern->u.file.open_mode_len);\n\n\t\n\tZVAL_RESOURCE(&intern->u.file.zresource, php_stream_get_resource_id(intern->u.file.stream));\n\tZ_SET_REFCOUNT(intern->u.file.zresource, 1);\n\t\n\tintern->u.file.delimiter = ',';\n\tintern->u.file.enclosure = '\"';\n\tintern->u.file.escape = '\\\\';\n\n\tzend_hash_find(&intern->std.ce->function_table, \"getcurrentline\", sizeof(\"getcurrentline\"), (void **) &intern->u.file.func_getCurr);\n\n\treturn SUCCESS;\n} \n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmark_desktop_file_trusted (CommonJob    *common,\n                           GCancellable *cancellable,\n                           GFile        *file,\n                           gboolean      interactive)\n{\n    char *contents, *new_contents;\n    gsize length, new_length;\n    GError *error;\n    guint32 current_perms, new_perms;\n    int response;\n    GFileInfo *info;\n\nretry:\n    error = NULL;\n    if (!g_file_load_contents (file,\n                               cancellable,\n                               &contents, &length,\n                               NULL, &error))\n    {\n        if (interactive)\n        {\n            response = run_error (common,\n                                  g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                  error->message,\n                                  NULL,\n                                  FALSE,\n                                  CANCEL, RETRY,\n                                  NULL);\n        }\n        else\n        {\n            response = 0;\n        }\n\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (common);\n        }\n        else if (response == 1)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\n    if (!g_str_has_prefix (contents, \"#!\"))\n    {\n        new_length = length + strlen (TRUSTED_SHEBANG);\n        new_contents = g_malloc (new_length);\n\n        strcpy (new_contents, TRUSTED_SHEBANG);\n        memcpy (new_contents + strlen (TRUSTED_SHEBANG),\n                contents, length);\n\n        if (!g_file_replace_contents (file,\n                                      new_contents,\n                                      new_length,\n                                      NULL,\n                                      FALSE, 0,\n                                      NULL, cancellable, &error))\n        {\n            g_free (contents);\n            g_free (new_contents);\n\n            if (interactive)\n            {\n                response = run_error (common,\n                                      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                      error->message,\n                                      NULL,\n                                      FALSE,\n                                      CANCEL, RETRY,\n                                      NULL);\n            }\n            else\n            {\n                response = 0;\n            }\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (common);\n            }\n            else if (response == 1)\n            {\n                goto retry;\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n\n            goto out;\n        }\n        g_free (new_contents);\n    }\n    g_free (contents);\n\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_UNIX_MODE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              common->cancellable,\n                              &error);\n\n    if (info == NULL)\n    {\n        if (interactive)\n        {\n            response = run_error (common,\n                                  g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                  error->message,\n                                  NULL,\n                                  FALSE,\n                                  CANCEL, RETRY,\n                                  NULL);\n        }\n        else\n        {\n            response = 0;\n        }\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (common);\n        }\n        else if (response == 1)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\n\n    if (g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE))\n    {\n        current_perms = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n        new_perms = current_perms | S_IXGRP | S_IXUSR | S_IXOTH;\n\n        if ((current_perms != new_perms) &&\n            !g_file_set_attribute_uint32 (file, G_FILE_ATTRIBUTE_UNIX_MODE,\n                                          new_perms, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                          common->cancellable, &error))\n        {\n            g_object_unref (info);\n\n            if (interactive)\n            {\n                response = run_error (common,\n                                      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                      error->message,\n                                      NULL,\n                                      FALSE,\n                                      CANCEL, RETRY,\n                                      NULL);\n            }\n            else\n            {\n                response = 0;\n            }\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (common);\n            }\n            else if (response == 1)\n            {\n                goto retry;\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n\n            goto out;\n        }\n    }\n    g_object_unref (info);\nout:\n    ;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int gemsafe_get_cert_len(sc_card_t *card)\n{\n\tint r;\n\tu8  ibuf[GEMSAFE_MAX_OBJLEN];\n\tu8 *iptr;\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tsize_t objlen, certlen;\n\tunsigned int ind, i=0;\n\n\tsc_format_path(GEMSAFE_PATH, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r != SC_SUCCESS || !file)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t\n\tr = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t\n\tobjlen = (((size_t) ibuf[0]) << 8) | ibuf[1];\n\tsc_log(card->ctx, \"Stored object is of size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       objlen);\n\tif (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {\n\t    sc_log(card->ctx, \"Invalid object size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t   objlen);\n\t    return SC_ERROR_INTERNAL;\n\t}\n\n\t\n\tind = 2; \n\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n\t\tif (ibuf[ind+1] == 0xFE) {\n\t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n\t\t\tsc_log(card->ctx, \"Key container %d is allocated and uses key_ref %d\",\n\t\t\t\t\ti+1, gemsafe_prkeys[i].ref);\n\t\t\tind += 9;\n\t\t}\n\t\telse {\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t\tsc_log(card->ctx, \"Key container %d is unallocated\", i+1);\n\t\t\tind += 8;\n\t\t}\n\t\ti++;\n\t}\n\n\t\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tgemsafe_prkeys[i].label = NULL;\n\t\tgemsafe_cert[i].label = NULL;\n\t}\n\n\t\n\tiptr = ibuf + GEMSAFE_READ_QUANTUM;\n\twhile ((size_t)(iptr - ibuf) < objlen) {\n\t\tr = sc_read_binary(card, iptr - ibuf, iptr,\n\t\t\t\t   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);\n\t\tif (r < 0) {\n\t\t\tsc_log(card->ctx, \"Could not read cert object\");\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t\tiptr += GEMSAFE_READ_QUANTUM;\n\t}\n\n\t\n\ti = 0;\n\twhile (ind < objlen - 1) {\n\t\tif (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {\n\t\t\t\n\t\t\twhile (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)\n\t\t\t\ti++;\n\t\t\tif (i == gemsafe_cert_max) {\n\t\t\t\tsc_log(card->ctx, \"Warning: Found orphaned certificate at offset %d\", ind);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\t\t\t\n\t\t\tif (ind+3 >= sizeof ibuf)\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\tcertlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;\n\t\t\tsc_log(card->ctx,\n\t\t\t       \"Found certificate of key container %d at offset %d, len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       i+1, ind, certlen);\n\t\t\tgemsafe_cert[i].index = ind;\n\t\t\tgemsafe_cert[i].count = certlen;\n\t\t\tind += certlen;\n\t\t\ti++;\n\t\t} else\n\t\t\tind++;\n\t}\n\n\t\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tif (gemsafe_cert[i].label) {\n\t\t\tsc_log(card->ctx, \"Warning: Certificate of key container %d is missing\", i+1);\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t}\n\t}\n\n\treturn SC_SUCCESS;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tint i;\n\tint j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < mat0->numrows_; i++) {\n\t\tfor (j = 0; j < mat0->numcols_; j++) {\n\t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool HHVM_FUNCTION(mb_parse_str,\n                   const String& encoded_string,\n                   VRefParam result ) {\n  php_mb_encoding_handler_info_t info;\n  info.data_type              = PARSE_STRING;\n  info.separator              = \";&\";\n  info.force_register_globals = false;\n  info.report_errors          = 1;\n  info.to_encoding            = MBSTRG(current_internal_encoding);\n  info.to_language            = MBSTRG(current_language);\n  info.from_encodings         = MBSTRG(http_input_list);\n  info.num_from_encodings     = MBSTRG(http_input_list_size);\n  info.from_language          = MBSTRG(current_language);\n\n  char *encstr = strndup(encoded_string.data(), encoded_string.size());\n  Array resultArr = Array::Create();\n  mbfl_encoding *detected =\n    _php_mb_encoding_handler_ex(&info, resultArr, encstr);\n  free(encstr);\n  result.assignIfRef(resultArr);\n\n  MBSTRG(http_input_identify) = detected;\n  return detected != nullptr;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n\tstruct iw_exif_state *e, iw_uint32 ifd)\n{\n\tunsigned int tag_count;\n\tunsigned int i;\n\tunsigned int tag_pos;\n\tunsigned int tag_id;\n\tunsigned int v;\n\tdouble v_dbl;\n\n\tif(ifd<8 || ifd>e->d_len-18) return;\n\n\ttag_count = iw_get_ui16_e(&e->d[ifd],e->endian);\n\tif(tag_count>1000) return;\n\tfor(i=0;i<tag_count;i++) {\n\t\ttag_pos = ifd+2+i*12;\n\t\tif(tag_pos+12 > e->d_len) return;\t\ttag_id = iw_get_ui16_e(&e->d[tag_pos],e->endian);\n\n\t\tswitch(tag_id) {\n\t\tcase 274:\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_orientation = v;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 296:\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_density_unit = v;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 282:\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_x = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 283:\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_y = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\natmarp_spaddr_print(netdissect_options *ndo,\n\t\t    const struct atmarp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (ATMSPROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong splen>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, ATMSPA(ap))));\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nrdpsnddbg_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tstatic char *rest = NULL;\n\tchar *buf;\n\n\tif (!s_check(s))\n\t{\n\t\trdp_protocol_error(\"rdpsnddbg_process(), stream is in unstable state\", s);\n\t}\n\n\tpkglen = s->end - s->p;\n\t\n\tbuf = (char *) xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\n\tstr_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);\n\n\txfree(buf);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\"PLEN %d type %d len %d\\n\",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len); \n\n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\n\treturn nh.nh_type;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n   const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 2);\n  if (input->type != kTfLiteFloat32) {\n    context->ReportError(context,\n                         \"Type '%s' for input is not supported by rfft2d.\",\n                         TfLiteTypeGetName(input->type));\n    return kTfLiteError;\n  }\n\n   const TfLiteTensor* fft_length = GetInput(context, node, kFftLengthTensor);\n  const RuntimeShape fft_length_shape = GetTensorShape(fft_length);\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(fft_length), 1);\n  TF_LITE_ENSURE_EQ(context, fft_length_shape.Dims(0), 2);\n  if (fft_length->type != kTfLiteInt32) {\n    context->ReportError(context,\n                         \"Type '%s' for fft_length is not supported by rfft2d.\",\n                         TfLiteTypeGetName(fft_length->type));\n    return kTfLiteError;\n  }\n\n   TF_LITE_ENSURE_STATUS(InitTemporaryTensors(context, node));\n\n   TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = kTfLiteComplex64;\n\n     if (!IsConstantTensor(fft_length)) {\n    TfLiteTensor* fft_integer_working_area =\n        GetTemporary(context, node, kFftIntegerWorkingAreaTensor);\n    TfLiteTensor* fft_double_working_area =\n        GetTemporary(context, node, kFftDoubleWorkingAreaTensor);\n    SetTensorToDynamic(fft_integer_working_area);\n    SetTensorToDynamic(fft_double_working_area);\n    SetTensorToDynamic(output);\n    return kTfLiteOk;\n  }\n\n  TF_LITE_ENSURE_STATUS(ResizeOutputandTemporaryTensors(context, node));\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPyParser_AddToken(parser_state *ps, int type, char *str,\n                  int lineno, int col_offset,\n                  int end_lineno, int end_col_offset,\n                  int *expected_ret)\n{\n    int ilabel;\n    int err;\n\n    D(printf(\"Token %s/'%s' ... \", _PyParser_TokenNames[type], str));\n\n    \n    ilabel = classify(ps, type, str);\n    if (ilabel < 0)\n        return E_SYNTAX;\n\n    \n    for (;;) {\n        \n        dfa *d = ps->p_stack.s_top->s_dfa;\n        state *s = &d->d_state[ps->p_stack.s_top->s_state];\n\n        D(printf(\" DFA '%s', state %d:\",\n            d->d_name, ps->p_stack.s_top->s_state));\n\n        \n        if (s->s_lower <= ilabel && ilabel < s->s_upper) {\n            int x = s->s_accel[ilabel - s->s_lower];\n            if (x != -1) {\n                if (x & (1<<7)) {\n                    \n                    int nt = (x >> 8) + NT_OFFSET;\n                    int arrow = x & ((1<<7)-1);\n                    dfa *d1;\n                    if (nt == func_body_suite && !(ps->p_flags & PyCF_TYPE_COMMENTS)) {\n                        \n                        D(printf(\" [switch func_body_suite to suite]\"));\n                        nt = suite;\n                    }\n                    d1 = PyGrammar_FindDFA(\n                        ps->p_grammar, nt);\n                    if ((err = push(&ps->p_stack, nt, d1,\n                        arrow, lineno, col_offset,\n                        end_lineno, end_col_offset)) > 0) {\n                        D(printf(\" MemError: push\\n\"));\n                        return err;\n                    }\n                    D(printf(\" Push '%s'\\n\", d1->d_name));\n                    continue;\n                }\n\n                \n                if ((err = shift(&ps->p_stack, type, str,\n                                x, lineno, col_offset,\n                                end_lineno, end_col_offset)) > 0) {\n                    D(printf(\" MemError: shift.\\n\"));\n                    return err;\n                }\n                D(printf(\" Shift.\\n\"));\n                \n                while (s = &d->d_state\n                                [ps->p_stack.s_top->s_state],\n                    s->s_accept && s->s_narcs == 1) {\n                    D(printf(\"  DFA '%s', state %d: \"\n                             \"Direct pop.\\n\",\n                             d->d_name,\n                             ps->p_stack.s_top->s_state));\n#ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD\n#if 0\n                    if (d->d_name[0] == 'i' &&\n                        strcmp(d->d_name,\n                           \"import_stmt\") == 0)\n                        future_hack(ps);\n#endif\n#endif\n                    s_pop(&ps->p_stack);\n                    if (s_empty(&ps->p_stack)) {\n                        D(printf(\"  ACCEPT.\\n\"));\n                        return E_DONE;\n                    }\n                    d = ps->p_stack.s_top->s_dfa;\n                }\n                return E_OK;\n            }\n        }\n\n        if (s->s_accept) {\n#ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD\n#if 0\n            if (d->d_name[0] == 'i' &&\n                strcmp(d->d_name, \"import_stmt\") == 0)\n                future_hack(ps);\n#endif\n#endif\n            \n            s_pop(&ps->p_stack);\n            D(printf(\" Pop ...\\n\"));\n            if (s_empty(&ps->p_stack)) {\n                D(printf(\" Error: bottom of stack.\\n\"));\n                return E_SYNTAX;\n            }\n            continue;\n        }\n\n        \n        D(printf(\" Error.\\n\"));\n        if (expected_ret) {\n            if (s->s_lower == s->s_upper - 1) {\n                \n                *expected_ret = ps->p_grammar->\n                    g_ll.ll_label[s->s_lower].lb_type;\n            }\n            else\n                *expected_ret = -1;\n        }\n        return E_SYNTAX;\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void Compute(OpKernelContext* c) override {\n    const Tensor& tag = c->input(0);\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(tag.shape()),\n                errors::InvalidArgument(\"tag must be scalar\"));\n    const Tensor& tensor = c->input(1);\n    const Tensor& serialized_summary_metadata_tensor = c->input(2);\n    OP_REQUIRES(\n        c,\n        TensorShapeUtils::IsScalar(serialized_summary_metadata_tensor.shape()),\n        errors::InvalidArgument(\"serialized_summary_metadata must be scalar\"));\n\n    Summary s;\n    Summary::Value* v = s.add_value();\n    v->set_tag(string(tag.scalar<tstring>()())); \n    if (tensor.dtype() == DT_STRING) {\n           tensor.AsProtoField(v->mutable_tensor());\n    } else {\n      tensor.AsProtoTensorContent(v->mutable_tensor());\n    }\n\n    ParseFromTString(serialized_summary_metadata_tensor.scalar<tstring>()(),\n                     v->mutable_metadata());\n\n    Tensor* summary_tensor = nullptr;\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape({}), &summary_tensor));\n    CHECK(SerializeToTString(s, &summary_tensor->scalar<tstring>()()));\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* lhs = GetInput(context, node, kInputLHSTensor);\n  const TfLiteTensor* rhs = GetInput(context, node, kInputRHSTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  RuntimeShape orig_lhs_shape = GetTensorShape(lhs);\n  RuntimeShape orig_rhs_shape = GetTensorShape(rhs);\n\n  bool adj_y = op_context.params->adj_y;\n  bool adj_x = op_context.params->adj_x;\n\n  const TfLiteTensor* rhs_tensor = adj_y ? rhs : GetTempRhs(context, node, rhs);\n  const TfLiteTensor* lhs_tensor = adj_x ? GetTempLhs(context, node, lhs) : lhs;\n  if (!adj_y) {\n          if (!(IsConstantTensor(rhs) && op_data->rhs_transposed)) {\n      TransposeRowsColumns(context, rhs, GetTemporary(context, node, 1));\n      op_data->rhs_transposed = true;\n    }\n  }\n  if (adj_x) {\n    TransposeRowsColumns(context, lhs, GetTemporary(context, node, 0));\n  }\n  RuntimeShape rhs_shape =\n      adj_y ? orig_rhs_shape : SwapRowColumnDims(orig_rhs_shape);\n  RuntimeShape lhs_shape =\n      adj_x ? orig_lhs_shape : SwapRowColumnDims(orig_lhs_shape);\n\n  switch (rhs->type) {\n    case kTfLiteFloat32:\n           if (kernel_type == kGenericOptimized) {\n        optimized_ops::BatchMatMul(rhs_shape, GetTensorData<float>(rhs_tensor),\n                                   lhs_shape, GetTensorData<float>(lhs_tensor),\n                                   GetTensorShape(output),\n                                   GetTensorData<float>(output),\n                                   CpuBackendContext::GetFromContext(context));\n      } else {\n        reference_ops::BatchMatMul(rhs_shape, GetTensorData<float>(rhs_tensor),\n                                   lhs_shape, GetTensorData<float>(lhs_tensor),\n                                   GetTensorShape(output),\n                                   GetTensorData<float>(output));\n      }\n      break;\n    case kTfLiteInt8:\n      EvalQuantized<kernel_type>(context, node, op_data, lhs_shape, lhs_tensor,\n                                 rhs_shape, rhs_tensor, output);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Currently BatchMatMul doesn't support type: %s\",\n                         TfLiteTypeGetName(lhs->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteIntArray* input_dims = input->dims;\n  int input_dims_size = input_dims->size;\n  TF_LITE_ENSURE(context, input_dims_size >= 2);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(input_dims_size);\n  for (int i = 0; i < input_dims_size; i++) {\n    output_shape->data[i] = input_dims->data[i];\n  }\n\n   output->type = input->type;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_shape));\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n\n       OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() >= 2,\n        errors::InvalidArgument(\"sorted input argument must be a matrix\"));\n       OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n\n       OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    OP_REQUIRES_OK(\n        ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid sock_release(struct socket *sock)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\n\t\tsock->ops->release(sock);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tpr_err(\"%s: fasync list not empty!\\n\", __func__);\n\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t\n\tftrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->enter_event->event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)\n{\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct net *net = dev_net(rt->dst.dev);\n\tstruct sock *sk;\n\tstruct inet_sock *inet;\n\t__be32 daddr;\n\n\tif (ip_options_echo(&icmp_param->replyopts, skb))\n\t\treturn;\n\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\tinet = inet_sk(sk);\n\n\ticmp_param->data.icmph.checksum = 0;\n\n\tinet->tos = ip_hdr(skb)->tos;\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tif (icmp_param->replyopts.optlen) {\n\t\tipc.opt = &icmp_param->replyopts;\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = icmp_param->replyopts.faddr;\n\t}\n\t{\n\t\tstruct flowi4 fl4 = {\n\t\t\t.daddr = daddr,\n\t\t\t.saddr = rt->rt_spec_dst,\n\t\t\t.flowi4_tos = RT_TOS(ip_hdr(skb)->tos),\n\t\t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t};\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto out_unlock;\n\t}\n\tif (icmpv4_xrlim_allow(net, rt, icmp_param->data.icmph.type,\n\t\t\t       icmp_param->data.icmph.code))\n\t\ticmp_push_reply(icmp_param, &ipc, &rt);\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ninline void StringData::setSize(int len) {\n  assertx(!isImmutable() && !hasMultipleRefs());\n  assertx(len >= 0 && len <= capacity());\n  mutableData()[len] = 0;\n  m_lenAndHash = len;\n  assertx(m_hash == 0);\n  assertx(checkSane());\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                    return 0;\n                }\n                i+=2;\n                if (i + 1 < data_size)\n                    block_length = data[i] * 256 + data[i+1];\n            }\n        }\n    }\n\n    return -1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_for_arg(struct compiling *c, const node *n)\n{\n    identifier name;\n    expr_ty annotation = NULL;\n    node *ch;\n    arg_ty ret;\n\n    assert(TYPE(n) == tfpdef || TYPE(n) == vfpdef);\n    ch = CHILD(n, 0);\n    name = NEW_IDENTIFIER(ch);\n    if (!name)\n        return NULL;\n    if (forbidden_name(c, name, ch, 0))\n        return NULL;\n\n    if (NCH(n) == 3 && TYPE(CHILD(n, 1)) == COLON) {\n        annotation = ast_for_expr(c, CHILD(n, 2));\n        if (!annotation)\n            return NULL;\n    }\n\n    ret = arg(name, annotation, LINENO(n), n->n_col_offset,\n              n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    if (!ret)\n        return NULL;\n    return ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic s32 gf_avc_read_pps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 nal_hdr)\n{\n\ts32 pps_id;\n\tAVC_PPS *pps;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id >= 255) {\n\t\treturn -1;\n\t}\n\tpps = &avc->pps[pps_id];\n\tpps->id = pps_id;\n\n\tif (!pps->status) pps->status = 1;\n\tpps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif (pps->sps_id >= 32) {\n\t\tpps->sps_id = 0;\n\t\treturn -1;\n\t}\n\t\n\tif (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) {\n\t\treturn -1;\n\t}\n\tavc->pps_active_idx = pps->id; \n\tavc->sps_active_idx = pps->sps_id; \n\tpps->entropy_coding_mode_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_mode_flag\");\n\tpps->pic_order_present = gf_bs_read_int_log(bs, 1, \"pic_order_present\");\n\tpps->slice_group_count = gf_bs_read_ue_log(bs, \"slice_group_count_minus1\") + 1;\n\tif (pps->slice_group_count > 1) {\n\t\tu32 iGroup;\n\t\tpps->mb_slice_group_map_type = gf_bs_read_ue_log(bs, \"mb_slice_group_map_type\");\n\t\tif (pps->mb_slice_group_map_type == 0) {\n\t\t\tfor (iGroup = 0; iGroup <= pps->slice_group_count - 1; iGroup++)\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"run_length_minus1\", iGroup);\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 2) {\n\t\t\tfor (iGroup = 0; iGroup < pps->slice_group_count - 1; iGroup++) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"top_left\", iGroup);\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"bottom_right\", iGroup);\n\t\t\t}\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 3 || pps->mb_slice_group_map_type == 4 || pps->mb_slice_group_map_type == 5) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_group_change_direction_flag\");\n\t\t\tgf_bs_read_ue_log(bs, \"slice_group_change_rate_minus1\");\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 6) {\n\t\t\tu32 i;\n\t\t\tpps->pic_size_in_map_units_minus1 = gf_bs_read_ue_log(bs, \"pic_size_in_map_units_minus1\");\n\t\t\tfor (i = 0; i <= pps->pic_size_in_map_units_minus1; i++) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, (u32)ceil(log(pps->slice_group_count) / log(2)), \"slice_group_id\", i);\n\t\t\t}\n\t\t}\n\t}\n\tpps->num_ref_idx_l0_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active_minus1\");\n\tpps->num_ref_idx_l1_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active_minus1\");\n\n\t\n\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");\n\tgf_bs_read_int_log(bs, 2, \"weighted_bipred_idc\");\n\tgf_bs_read_se_log(bs, \"init_qp_minus26\");\n\tgf_bs_read_se_log(bs, \"init_qs_minus26\");\n\tgf_bs_read_se_log(bs, \"chroma_qp_index_offset\");\n\tpps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\");\n\tgf_bs_read_int_log(bs, 1, \"constrained_intra_pred\");\n\tpps->redundant_pic_cnt_present = gf_bs_read_int_log(bs, 1, \"redundant_pic_cnt_present\");\n\n\treturn pps_id;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150) \n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void Compute(OpKernelContext* context) override {\n          const Tensor& input = context->input(0);\n\n          const Tensor& filter = context->input(1);\n\n       OP_REQUIRES(context, input.dims() == 4,\n                errors::InvalidArgument(\"input must be 4-dimensional\",\n                                        input.shape().DebugString()));\n    OP_REQUIRES(context, filter.dims() == 4,\n                errors::InvalidArgument(\"filter must be 4-dimensional: \",\n                                        filter.shape().DebugString()));\n\n    const float min_input = context->input(2).flat<float>()(0);\n    const float max_input = context->input(3).flat<float>()(0);\n    const float min_filter = context->input(4).flat<float>()(0);\n    const float max_filter = context->input(5).flat<float>()(0);\n    const int32_t offset_input =\n        FloatToQuantizedUnclamped<T1>(0.0f, min_input, max_input);\n    const int32_t offset_filter =\n        FloatToQuantizedUnclamped<T2>(0.0f, min_filter, max_filter);\n    const int32_t offset_output = 0;\n    const int32_t mult_output = 1;\n    const int32_t shift_output = 0;\n\n          const int64_t in_depth = input.dim_size(3);\n    OP_REQUIRES(context, in_depth == filter.dim_size(2),\n                errors::InvalidArgument(\n                    \"input and filter must have the same depth: \", in_depth,\n                    \" vs \", filter.dim_size(2)));\n\n       const int64_t out_depth = filter.dim_size(3);\n\n          const int64_t input_rows = input.dim_size(1);\n    const int64_t filter_rows = filter.dim_size(0);\n\n          const int64_t input_cols = input.dim_size(2);\n    const int64_t filter_cols = filter.dim_size(1);\n\n       const int64_t batch = input.dim_size(0);\n\n             const int stride = strides_[1];\n\n    int64_t out_rows = 0, out_cols = 0, pad_rows = 0, pad_cols = 0;\n    OP_REQUIRES_OK(context,\n                   GetWindowedOutputSize(input_rows, filter_rows, stride,\n                                         padding_, &out_rows, &pad_rows));\n    OP_REQUIRES_OK(context,\n                   GetWindowedOutputSize(input_cols, filter_cols, stride,\n                                         padding_, &out_cols, &pad_cols));\n    CHECK_GT(batch, 0);\n    CHECK_GT(out_rows, 0);\n    CHECK_GT(out_cols, 0);\n    CHECK_GT(out_depth, 0);\n    TensorShape out_shape({batch, out_rows, out_cols, out_depth});\n\n          Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n\n          ConvFunctor<T1, T2, T3> conv_functor;\n    conv_functor(context, input.flat<T1>().data(), batch, input_rows,\n                 input_cols, in_depth, offset_input, filter.flat<T2>().data(),\n                 filter_rows, filter_cols, out_depth, offset_filter, stride,\n                 padding_, output->flat<T3>().data(), out_rows, out_cols,\n                 shift_output, offset_output, mult_output);\n\n    float min_output_value;\n    float max_output_value;\n    QuantizationRangeForMultiplication<T1, T2, T3>(\n        min_input, max_input, min_filter, max_filter, &min_output_value,\n        &max_output_value);\n\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_output_value;\n\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_output_value;\n  }\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE(context, node->inputs->size > 0);\n\n   const TfLiteTensor* cond;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &cond));\n     TF_LITE_ENSURE_EQ(context, cond->type, kTfLiteBool);\n  TF_LITE_ENSURE_EQ(context, NumElements(cond), 1);\n\n     int num_inputs = node->inputs->size - 1;\n  int num_outputs = node->outputs->size;\n\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n  TF_LITE_ENSURE(context, op_data->then_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context, op_data->else_subgraph_index < subgraphs->size());\n\n  Subgraph* then_subgraph = (*subgraphs)[op_data->then_subgraph_index].get();\n  Subgraph* else_subgraph = (*subgraphs)[op_data->else_subgraph_index].get();\n\n  for (auto* subgraph : {then_subgraph, else_subgraph}) {\n    TF_LITE_ENSURE_EQ(context, num_inputs, subgraph->inputs().size());\n    TF_LITE_ENSURE_EQ(context, num_outputs, subgraph->outputs().size());\n  }\n\n  bool has_dynamic_output_tensors = false;\n  for (auto* subgraph : {then_subgraph, else_subgraph}) {\n    for (int i = 0; i < num_inputs; ++i) {\n                const TfLiteTensor* input;\n      TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i + 1, &input));\n      std::vector<int> dims(input->dims->data,\n                            input->dims->data + input->dims->size);\n      subgraph->ResizeInputTensor(i, dims);\n      TfLiteTensor* subgraph_input = subgraph->tensor(subgraph->inputs()[i]);\n      TF_LITE_ENSURE_TYPES_EQ(context, input->type, subgraph_input->type);\n    }\n             TF_LITE_ENSURE_OK(context, subgraph->AllocateTensors());\n    has_dynamic_output_tensors |= subgraph->HasDynamicTensors();\n  }\n\n  if (!has_dynamic_output_tensors) {\n    for (int i = 0; i < num_outputs; ++i) {\n      TfLiteTensor* then_output =\n          then_subgraph->tensor(then_subgraph->outputs()[i]);\n      TfLiteTensor* else_output =\n          else_subgraph->tensor(else_subgraph->outputs()[i]);\n                if (!TfLiteIntArrayEqual(then_output->dims, else_output->dims)) {\n        has_dynamic_output_tensors = true;\n        break;\n      }\n    }\n  }\n\n  for (int i = 0; i < num_outputs; ++i) {\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    if (has_dynamic_output_tensors) {\n      SetTensorToDynamic(output);\n    } else {\n                TfLiteTensor* then_output =\n          then_subgraph->tensor(then_subgraph->outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(then_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nDECLAREwriteFunc(writeBufferToContigTiles)\n{\n\tuint32 imagew = TIFFScanlineSize(out);\n\tuint32 tilew  = TIFFTileRowSize(out);\n\tint iskew = imagew - tilew;\n\ttsize_t tilesize = TIFFTileSize(out);\n\ttdata_t obuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tl, tw;\n\tuint32 row;\n\n\t(void) spp;\n\n\tobuf = _TIFFmalloc(TIFFTileSize(out));\n\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\t\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tint oskew = tilew - width;\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew);\n\t\t\t} else\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, tilew,\n\t\t\t\t    0, iskew);\n\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\t_TIFFfree(obuf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += nrow * imagew;\n\t}\n\t_TIFFfree(obuf);\n\treturn 1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\tsize_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\tunsigned int ulen, copied;\n\tint peeked, off = 0;\n\tint err;\n\tint is_udplite = IS_UDPLITE(sk);\n\tbool slow;\n\n\t\n\tif (addr_len)\n\t\t*addr_len = sizeof(*sin);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ip_recv_error(sk, msg, len);\n\ntry_again:\n\tskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n\t\t\t\t  &peeked, &off, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tulen = skb->len - sizeof(struct udphdr);\n\tcopied = len;\n\tif (copied > ulen)\n\t\tcopied = ulen;\n\telse if (copied < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\t\n\n\tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (skb_csum_unnecessary(skb))\n\t\terr = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),\n\t\t\t\t\t      msg->msg_iov, copied);\n\telse {\n\t\terr = skb_copy_and_csum_datagram_iovec(skb,\n\t\t\t\t\t\t       sizeof(struct udphdr),\n\t\t\t\t\t\t       msg->msg_iov);\n\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (unlikely(err)) {\n\t\ttrace_kfree_skb(skb, udp_recvmsg);\n\t\tif (!peeked) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t   UDP_MIB_INERRORS, is_udplite);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tif (!peeked)\n\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = udp_hdr(skb)->source;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\n\nout_free:\n\tskb_free_datagram_locked(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tslow = lock_sock_fast(sk);\n\tif (!skb_kill_datagram(sk, skb, flags)) {\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t}\n\tunlock_sock_fast(sk, slow);\n\n\tif (noblock)\n\t\treturn -EAGAIN;\n\n\t\n\tmsg->msg_flags &= ~MSG_TRUNC;\n\tgoto try_again;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nheader_put_marker (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} \n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmptctl_readtest (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n\t\n\n#ifdef MFCNT\n\tkarg.chip_type = ioc->mfcnt;\n#else\n\tkarg.chip_type = ioc->pcidev->device;\n#endif\n\tstrncpy (karg.name, ioc->name, MPT_MAX_NAME);\n\tkarg.name[MPT_MAX_NAME-1]='\\0';\n\tstrncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);\n\tkarg.product[MPT_PRODUCT_LENGTH-1]='\\0';\n\n\t\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to write out mpt_ioctl_test struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  \n  int nextra = actual - nfixparams;  \n  ci->u.l.nextraargs = nextra;\n  checkstackGC(L, p->maxstacksize + 1);\n  \n  setobjs2s(L, L->top++, ci->func);\n  \n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);\n    setnilvalue(s2v(ci->func + i));  \n  }\n  ci->func += actual + 1;\n  ci->top += actual + 1;\n  lua_assert(L->top <= ci->top && ci->top <= L->stack_last);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; \n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t\n\tif ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\n\tif ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tunlock_mount_hash();\n\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\n\t\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\n\treturn mnt;\n\n out_free:\n\tmnt_free_id(mnt);\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Privilege Management"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size)\n{\n\tunsigned int i;\n\tstruct hash_cell *hc;\n\tsize_t len, needed = 0;\n\tstruct gendisk *disk;\n\tstruct dm_name_list *orig_nl, *nl, *old_nl = NULL;\n\tuint32_t *event_nr;\n\n\tdown_write(&_hash_lock);\n\n\t\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tneeded += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1);\n\t\t\tneeded += align_val(sizeof(uint32_t));\n\t\t}\n\t}\n\n\t\n\tnl = orig_nl = get_result_buffer(param, param_size, &len);\n\tif (len < needed || len < sizeof(nl->dev)) {\n\t\tparam->flags |= DM_BUFFER_FULL_FLAG;\n\t\tgoto out;\n\t}\n\tparam->data_size = param->data_start + needed;\n\n\tnl->dev = 0;\t\n\n\t\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tif (old_nl)\n\t\t\t\told_nl->next = (uint32_t) ((void *) nl -\n\t\t\t\t\t\t\t   (void *) old_nl);\n\t\t\tdisk = dm_disk(hc->md);\n\t\t\tnl->dev = huge_encode_dev(disk_devt(disk));\n\t\t\tnl->next = 0;\n\t\t\tstrcpy(nl->name, hc->name);\n\n\t\t\told_nl = nl;\n\t\t\tevent_nr = align_ptr(nl->name + strlen(hc->name) + 1);\n\t\t\t*event_nr = dm_get_event_nr(hc->md);\n\t\t\tnl = align_ptr(event_nr + 1);\n\t\t}\n\t}\n\t\n\tBUG_ON((char *)nl - (char *)orig_nl != needed);\n\n out:\n\tup_write(&_hash_lock);\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool_t enc28j60IrqHandler(NetInterface *interface)\n{\n   bool_t flag;\n   uint8_t status;\n\n     flag = FALSE;\n\n     enc28j60ClearBit(interface, ENC28J60_EIE, ENC28J60_EIE_INTIE);\n\n     status = enc28j60ReadReg(interface, ENC28J60_EIR);\n\n     if((status & ENC28J60_EIR_LINKIF) != 0)\n   {\n           enc28j60ClearBit(interface, ENC28J60_EIE, ENC28J60_EIE_LINKIE);\n\n           interface->nicEvent = TRUE;\n           flag |= osSetEventFromIsr(&netEvent);\n   }\n\n     if(enc28j60ReadReg(interface, ENC28J60_EPKTCNT) != 0)\n   {\n           enc28j60ClearBit(interface, ENC28J60_EIE, ENC28J60_EIE_PKTIE);\n\n           interface->nicEvent = TRUE;\n           flag |= osSetEventFromIsr(&netEvent);\n   }\n\n     if((status & (ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE)) != 0)\n   {\n           enc28j60ClearBit(interface, ENC28J60_EIR, ENC28J60_EIR_TXIF |\n         ENC28J60_EIE_TXERIE);\n\n           flag |= osSetEventFromIsr(&interface->nicTxEvent);\n   }\n\n       enc28j60SetBit(interface, ENC28J60_EIE, ENC28J60_EIE_INTIE);\n\n     return flag;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_secondary_order(STREAM s)\n{\n\t\n\tuint16 length;\n\tuint16 flags;\n\tuint8 type;\n\tuint8 *next_order;\n\tstruct stream packet = *s;\n\n\tin_uint16_le(s, length);\n\tin_uint16_le(s, flags);\t\n\tin_uint8(s, type);\n\n\tif (!s_check_rem(s, length + 7))\n\t{\n\t\trdp_protocol_error(\"process_secondary_order(), next order pointer would overrun stream\", &packet);\n\t}\n\n\tnext_order = s->p + (sint16) length + 7;\n\n\tswitch (type)\n\t{\n\t\tcase RDP_ORDER_RAW_BMPCACHE:\n\t\t\tprocess_raw_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_COLCACHE:\n\t\t\tprocess_colcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE:\n\t\t\tprocess_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_FONTCACHE:\n\t\t\tprocess_fontcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_RAW_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, False);\t\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, True);\t\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BRUSHCACHE:\n\t\t\tprocess_brushcache(s, flags);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_secondary_order(), unhandled secondary order %d\", type);\n\t}\n\n\ts->p = next_order;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *address, int mode)\n{\n\tint size, ct, err;\n\n\tif (m->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tvoid __user *namep;\n\t\t\tnamep = (void __user __force *) m->msg_name;\n\t\t\terr = move_addr_to_kernel(namep, m->msg_namelen,\n\t\t\t\t\t\t  address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (m->msg_name)\n\t\t\tm->msg_name = address;\n\t} else {\n\t\tm->msg_name = NULL;\n\t}\n\n\tsize = m->msg_iovlen * sizeof(struct iovec);\n\tif (copy_from_user(iov, (void __user __force *) m->msg_iov, size))\n\t\treturn -EFAULT;\n\n\tm->msg_iov = iov;\n\terr = 0;\n\n\tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n\t\tsize_t len = iov[ct].iov_len;\n\n\t\tif (len > INT_MAX - err) {\n\t\t\tlen = INT_MAX - err;\n\t\t\tiov[ct].iov_len = len;\n\t\t}\n\t\terr += len;\n\t}\n\n\treturn err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n        }\n\tif (priv->cac_id_len) {\n\t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,\n\t\tint closing, int tx_ring)\n{\n\tstruct pgv *pg_vec = NULL;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tint was_running, order = 0;\n\tstruct packet_ring_buffer *rb;\n\tstruct sk_buff_head *rb_queue;\n\t__be16 num;\n\tint err = -EINVAL;\n\t\n\tstruct tpacket_req *req = &req_u->req;\n\n\t\n\tif (!closing && tx_ring && (po->tp_version > TPACKET_V2)) {\n\t\tnet_warn_ratelimited(\"Tx-ring is not supported.\\n\");\n\t\tgoto out;\n\t}\n\n\trb = tx_ring ? &po->tx_ring : &po->rx_ring;\n\trb_queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue;\n\n\terr = -EBUSY;\n\tif (!closing) {\n\t\tif (atomic_read(&po->mapped))\n\t\t\tgoto out;\n\t\tif (packet_read_pending(rb))\n\t\t\tgoto out;\n\t}\n\n\tif (req->tp_block_nr) {\n\t\t\n\t\terr = -EBUSY;\n\t\tif (unlikely(rb->pg_vec))\n\t\t\tgoto out;\n\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V1:\n\t\t\tpo->tp_hdrlen = TPACKET_HDRLEN;\n\t\t\tbreak;\n\t\tcase TPACKET_V2:\n\t\t\tpo->tp_hdrlen = TPACKET2_HDRLEN;\n\t\t\tbreak;\n\t\tcase TPACKET_V3:\n\t\t\tpo->tp_hdrlen = TPACKET3_HDRLEN;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (unlikely((int)req->tp_block_size <= 0))\n\t\t\tgoto out;\n\t\tif (unlikely(!PAGE_ALIGNED(req->tp_block_size)))\n\t\t\tgoto out;\n\t\tif (po->tp_version >= TPACKET_V3 &&\n\t\t    (int)(req->tp_block_size -\n\t\t\t  BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) <= 0)\n\t\t\tgoto out;\n\t\tif (unlikely(req->tp_frame_size < po->tp_hdrlen +\n\t\t\t\t\tpo->tp_reserve))\n\t\t\tgoto out;\n\t\tif (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1)))\n\t\t\tgoto out;\n\n\t\trb->frames_per_block = req->tp_block_size / req->tp_frame_size;\n\t\tif (unlikely(rb->frames_per_block == 0))\n\t\t\tgoto out;\n\t\tif (unlikely((rb->frames_per_block * req->tp_block_nr) !=\n\t\t\t\t\treq->tp_frame_nr))\n\t\t\tgoto out;\n\n\t\terr = -ENOMEM;\n\t\torder = get_order(req->tp_block_size);\n\t\tpg_vec = alloc_pg_vec(req, order);\n\t\tif (unlikely(!pg_vec))\n\t\t\tgoto out;\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V3:\n\t\t\n\t\t\tif (!tx_ring)\n\t\t\t\tinit_prb_bdqc(po, rb, pg_vec, req_u);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\telse {\n\t\terr = -EINVAL;\n\t\tif (unlikely(req->tp_frame_nr))\n\t\t\tgoto out;\n\t}\n\n\tlock_sock(sk);\n\n\t\n\tspin_lock(&po->bind_lock);\n\twas_running = po->running;\n\tnum = po->num;\n\tif (was_running) {\n\t\tpo->num = 0;\n\t\t__unregister_prot_hook(sk, false);\n\t}\n\tspin_unlock(&po->bind_lock);\n\n\tsynchronize_net();\n\n\terr = -EBUSY;\n\tmutex_lock(&po->pg_vec_lock);\n\tif (closing || atomic_read(&po->mapped) == 0) {\n\t\terr = 0;\n\t\tspin_lock_bh(&rb_queue->lock);\n\t\tswap(rb->pg_vec, pg_vec);\n\t\trb->frame_max = (req->tp_frame_nr - 1);\n\t\trb->head = 0;\n\t\trb->frame_size = req->tp_frame_size;\n\t\tspin_unlock_bh(&rb_queue->lock);\n\n\t\tswap(rb->pg_vec_order, order);\n\t\tswap(rb->pg_vec_len, req->tp_block_nr);\n\n\t\trb->pg_vec_pages = req->tp_block_size/PAGE_SIZE;\n\t\tpo->prot_hook.func = (po->rx_ring.pg_vec) ?\n\t\t\t\t\t\ttpacket_rcv : packet_rcv;\n\t\tskb_queue_purge(rb_queue);\n\t\tif (atomic_read(&po->mapped))\n\t\t\tpr_err(\"packet_mmap: vma is busy: %d\\n\",\n\t\t\t       atomic_read(&po->mapped));\n\t}\n\tmutex_unlock(&po->pg_vec_lock);\n\n\tspin_lock(&po->bind_lock);\n\tif (was_running) {\n\t\tpo->num = num;\n\t\tregister_prot_hook(sk);\n\t}\n\tspin_unlock(&po->bind_lock);\n\tif (closing && (po->tp_version > TPACKET_V2)) {\n\t\t\n\t\tif (!tx_ring)\n\t\t\tprb_shutdown_retire_blk_timer(po, rb_queue);\n\t}\n\trelease_sock(sk);\n\n\tif (pg_vec)\n\t\tfree_pg_vec(pg_vec, order, req->tp_block_nr);\nout:\n\treturn err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int __ext4_expand_extra_isize(struct inode *inode,\n\t\t\t\t     unsigned int new_extra_isize,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     handle_t *handle, int *no_expand)\n{\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\tunsigned int inode_size = EXT4_INODE_SIZE(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tint error;\n\n\t\n\tif ((EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize > inode_size) ||\n\t    (ei->i_extra_isize & 3)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extra_isize %u (inode size %u)\",\n\t\t\t\t ei->i_extra_isize,\n\t\t\t\t EXT4_INODE_SIZE(inode->i_sb));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif ((new_extra_isize < ei->i_extra_isize) ||\n\t    (new_extra_isize < 4) ||\n\t    (new_extra_isize > inode_size - EXT4_GOOD_OLD_INODE_SIZE))\n\t\treturn -EINVAL;\t\n\n\traw_inode = ext4_raw_inode(iloc);\n\n\theader = IHDR(inode, raw_inode);\n\n\t\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||\n\t    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\tmemset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE +\n\t\t       EXT4_I(inode)->i_extra_isize, 0,\n\t\t       new_extra_isize - EXT4_I(inode)->i_extra_isize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\treturn 0;\n\t}\n\n\t\n\terror = ext4_expand_extra_isize_ea(inode, new_extra_isize,\n\t\t\t\t\t   raw_inode, handle);\n\tif (error) {\n\t\t\n\t\t*no_expand = 1;\n\t}\n\n\treturn error;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic struct page *follow_page_pte(struct vm_area_struct *vma,\n\t\tunsigned long address, pmd_t *pmd, unsigned int flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct dev_pagemap *pgmap = NULL;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t *ptep, pte;\n\nretry:\n\tif (unlikely(pmd_bad(*pmd)))\n\t\treturn no_page_table(vma, flags);\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tpte = *ptep;\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry;\n\t\t\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\tgoto no_page;\n\t\tif (pte_none(pte))\n\t\t\tgoto no_page;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (!is_migration_entry(entry))\n\t\t\tgoto no_page;\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto retry;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n\t\tgoto no_page;\n\tif ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn NULL;\n\t}\n\n\tpage = vm_normal_page(vma, address, pte);\n\tif (!page && pte_devmap(pte) && (flags & FOLL_GET)) {\n\t\t\n\t\tpgmap = get_dev_pagemap(pte_pfn(pte), NULL);\n\t\tif (pgmap)\n\t\t\tpage = pte_page(pte);\n\t\telse\n\t\t\tgoto no_page;\n\t} else if (unlikely(!page)) {\n\t\tif (flags & FOLL_DUMP) {\n\t\t\t\n\t\t\tpage = ERR_PTR(-EFAULT);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (is_zero_pfn(pte_pfn(pte))) {\n\t\t\tpage = pte_page(pte);\n\t\t} else {\n\t\t\tint ret;\n\n\t\t\tret = follow_pfn_pte(vma, address, ptep, flags);\n\t\t\tpage = ERR_PTR(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (flags & FOLL_SPLIT && PageTransCompound(page)) {\n\t\tint ret;\n\t\tget_page(page);\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tlock_page(page);\n\t\tret = split_huge_page(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tgoto retry;\n\t}\n\n\tif (flags & FOLL_GET) {\n\t\tget_page(page);\n\n\t\t\n\t\tif (pgmap) {\n\t\t\tput_dev_pagemap(pgmap);\n\t\t\tpgmap = NULL;\n\t\t}\n\t}\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\t\n\t\tmark_page_accessed(page);\n\t}\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t\n\t\tif (PageTransCompound(page))\n\t\t\tgoto out;\n\n\t\t\n\t\tif (page->mapping && trylock_page(page)) {\n\t\t\tlru_add_drain();  \n\t\t\t\n\t\t\tmlock_vma_page(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\treturn page;\nno_page:\n\tpte_unmap_unlock(ptep, ptl);\n\tif (!pte_none(pte))\n\t\treturn NULL;\n\treturn no_page_table(vma, flags);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nparse_file (FILE* input_file, char* directory, \n\t    char *body_filename, char *body_pref,\n\t    int flags)\n{\n    uint32 d;\n    uint16 key;\n    Attr *attr = NULL;\n    File *file = NULL;\n    int rtf_size = 0, html_size = 0;\n    MessageBody body;\n    memset (&body, '\\0', sizeof (MessageBody));\n\n    \n    g_flags = flags;\n\n    \n    d = geti32(input_file);\n    if (d != TNEF_SIGNATURE)\n    {\n\tfprintf (stdout, \"Seems not to be a TNEF file\\n\");\n\treturn 1;\n    }\n\n    \n    key = geti16(input_file);\n    debug_print (\"TNEF Key: %hx\\n\", key);\n\n    \n    while ( data_left( input_file ) )\n    {\n\tattr = read_object( input_file );\n\n\tif ( attr == NULL ) break;\n\n\t\n\tif (attr->name == attATTACHRENDDATA)\n\t{\n\t    if (file)\n\t    {\n\t\tfile_write (file, directory);\n\t\tfile_free (file);\n\t    }\n\t    else\n\t    {\n\t\tfile = CHECKED_XCALLOC (File, 1);\n\t    }\n\t}\n\n\t\n\tswitch (attr->lvl_type)\n\t{\n\tcase LVL_MESSAGE:\n\t    if (attr->name == attBODY)\n\t    {\n\t\tbody.text_body = get_text_data (attr);\n\t    }\n\t    else if (attr->name == attMAPIPROPS) \n\t    { \n\t\tMAPI_Attr **mapi_attrs \n\t\t    = mapi_attr_read (attr->len, attr->buf); \n\t\tif (mapi_attrs)\n\t\t{ \n\t\t    int i;\n\t\t    for (i = 0; mapi_attrs[i]; i++)\n\t\t    {\n\t\t\tMAPI_Attr *a = mapi_attrs[i];\n\t\t\t    \n\t\t\tif (a->name == MAPI_BODY_HTML)\n\t\t\t{\n\t\t\t    body.html_bodies = get_html_data (a);\n                                html_size = a->num_values;\n\t\t\t}\n\t\t\telse if (a->name == MAPI_RTF_COMPRESSED)\n\t\t\t{\n\t\t\t    body.rtf_bodies = get_rtf_data (a);\n                                rtf_size = a->num_values;\n\t\t\t}\n\t\t    }\n\t\t     \n\t\t    \n\t\t    mapi_attr_free_list (mapi_attrs); \n\t\t    XFREE (mapi_attrs); \n\t\t}\n\t    }\n\t    break;\n\tcase LVL_ATTACHMENT:\n\t    file_add_attr (file, attr);\n\t    break;\n\tdefault:\n\t    fprintf (stderr, \"Invalid lvl type on attribute: %d\\n\",\n\t\t     attr->lvl_type);\n\t    return 1;\n\t    break;\n\t}\n\tattr_free (attr);\n\tXFREE (attr);\n    }\n\n    if (file)\n    {\n\tfile_write (file, directory);\n\tfile_free (file);\n\tXFREE (file);\n    }\n    \n    \n    if (flags & SAVEBODY)\n    {\n\tint i = 0;\n\tint all_flag = 0;\n\tif (strcmp (body_pref, \"all\") == 0) \n\t{\n\t    all_flag = 1;\n\t    body_pref = \"rht\";\n\t}\n\n\tfor (; i < 3; i++)\n\t{\n\t    File **files\n\t\t= get_body_files (body_filename, body_pref[i], &body);\n\t    if (files)\n\t    {\n\t\tint j = 0; \n\t\tfor (; files[j]; j++)\n\t\t{\n\t\t    file_write(files[j], directory);\n\t\t    file_free (files[j]);\n                    XFREE(files[j]);\n\t\t}\n\t\tXFREE(files);\n\t\tif (!all_flag) break;\n\t    }\n\t}\n    }\n\n    if (body.text_body)\n    {\n        free_bodies(body.text_body, 1);\n        XFREE(body.text_body);\n    }\n    if (rtf_size > 0)\n    {\n        free_bodies(body.rtf_bodies, rtf_size);\n        XFREE(body.rtf_bodies);\n    }\n    if (html_size > 0)\n    {\n        free_bodies(body.html_bodies, html_size);\n        XFREE(body.html_bodies);\n    }\n    return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nwrite_node(FILE   *out,\t\t\n           tree_t *t,\t\t\n           int    col)\t\t\n{\n  int\t\ti;\t\t\n  uchar\t\t*ptr,\t\t\n\t\t*entity,\t\n\t\t*src,\t\t\n\t\t*realsrc,\t\n\t\tnewsrc[1024];\t\n\n\n  if (out == NULL)\n    return (0);\n\n  switch (t->markup)\n  {\n    case MARKUP_NONE :\n        if (t->data == NULL)\n\t  break;\n\n\tif (t->preformatted)\n\t{\n          for (ptr = t->data; *ptr; ptr ++)\n            fputs((char *)iso8859(*ptr), out);\n\n\t  if (t->data[strlen((char *)t->data) - 1] == '\\n')\n            col = 0;\n\t  else\n            col += strlen((char *)t->data);\n\t}\n\telse\n\t{\n\t  if ((col + (int)strlen((char *)t->data)) > 72 && col > 0)\n\t  {\n            putc('\\n', out);\n            col = 0;\n\t  }\n\n          for (ptr = t->data; *ptr; ptr ++)\n            fputs((char *)iso8859(*ptr), out);\n\n\t  col += strlen((char *)t->data);\n\n\t  if (col > 72)\n\t  {\n            putc('\\n', out);\n            col = 0;\n\t  }\n\t}\n\tbreak;\n\n    case MARKUP_COMMENT :\n    case MARKUP_UNKNOWN :\n        fputs(\"\\n<!--\", out);\n\tfor (ptr = t->data; *ptr; ptr ++)\n\t  fputs((char *)iso8859(*ptr), out);\n\tfputs(\"-->\\n\", out);\n\tcol = 0;\n\tbreak;\n\n    case MARKUP_AREA :\n    case MARKUP_BODY :\n    case MARKUP_DOCTYPE :\n    case MARKUP_ERROR :\n    case MARKUP_FILE :\n    case MARKUP_HEAD :\n    case MARKUP_HTML :\n    case MARKUP_MAP :\n    case MARKUP_META :\n    case MARKUP_TITLE :\n        break;\n\n    case MARKUP_BR :\n    case MARKUP_CENTER :\n    case MARKUP_DD :\n    case MARKUP_DL :\n    case MARKUP_DT :\n    case MARKUP_H1 :\n    case MARKUP_H2 :\n    case MARKUP_H3 :\n    case MARKUP_H4 :\n    case MARKUP_H5 :\n    case MARKUP_H6 :\n    case MARKUP_H7 :\n    case MARKUP_H8 :\n    case MARKUP_H9 :\n    case MARKUP_H10 :\n    case MARKUP_H11 :\n    case MARKUP_H12 :\n    case MARKUP_H13 :\n    case MARKUP_H14 :\n    case MARKUP_H15 :\n    case MARKUP_HR :\n    case MARKUP_LI :\n    case MARKUP_OL :\n    case MARKUP_P :\n    case MARKUP_PRE :\n    case MARKUP_TABLE :\n    case MARKUP_TR :\n    case MARKUP_UL :\n        if (col > 0)\n        {\n          putc('\\n', out);\n          col = 0;\n        }\n\n    default :\n\tif (t->markup == MARKUP_IMG &&\n            (src = htmlGetVariable(t, (uchar *)\"SRC\")) != NULL &&\n            (realsrc = htmlGetVariable(t, (uchar *)\"REALSRC\")) != NULL)\n\t{\n\t \n\n          if (file_method((char *)src) == NULL &&\n              src[0] != '/' && src[0] != '\\\\' &&\n\t      (!isalpha(src[0]) || src[1] != ':'))\n          {\n            image_copy((char *)src, (char *)realsrc, OutputPath);\n            strlcpy((char *)newsrc, file_basename((char *)src), sizeof(newsrc));\n            htmlSetVariable(t, (uchar *)\"SRC\", newsrc);\n          }\n\t}\n\n        if (t->markup != MARKUP_EMBED)\n\t{\n\t  col += fprintf(out, \"<%s\", _htmlMarkups[t->markup]);\n\t  for (i = 0; i < t->nvars; i ++)\n\t  {\n\t    if (strcasecmp((char *)t->vars[i].name, \"BREAK\") == 0 &&\n\t        t->markup == MARKUP_HR)\n\t      continue;\n\n\t    if (strcasecmp((char *)t->vars[i].name, \"REALSRC\") == 0 &&\n\t        t->markup == MARKUP_IMG)\n\t      continue;\n\n            if (strncasecmp((char *)t->vars[i].name, \"_HD_\", 4) == 0)\n\t      continue;\n\n\t    if (col > 72 && !t->preformatted)\n\t    {\n              putc('\\n', out);\n              col = 0;\n\t    }\n\n            if (col > 0)\n            {\n              putc(' ', out);\n              col ++;\n            }\n\n\t    if (t->vars[i].value == NULL)\n              col += fprintf(out, \"%s\", t->vars[i].name);\n\t    else\n\t    {\n\t      col += fprintf(out, \"%s=\\\"\", t->vars[i].name);\n\t      for (ptr = t->vars[i].value; *ptr; ptr ++)\n\t      {\n\t\tentity = iso8859(*ptr);\n\t\tfputs((char *)entity, out);\n\t\tcol += strlen((char *)entity);\n\t      }\n\n\t      putc('\\\"', out);\n\t      col ++;\n\t    }\n\t  }\n\n\t  putc('>', out);\n\t  col ++;\n\n\t  if (col > 72 && !t->preformatted)\n\t  {\n\t    putc('\\n', out);\n\t    col = 0;\n\t  }\n\t}\n\tbreak;\n  }\n\n  return (col);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (output->type) {\n    case kTfLiteFloat32: {\n      return ReverseSequenceHelper<float>(context, node);\n    }\n    case kTfLiteUInt8: {\n      return ReverseSequenceHelper<uint8_t>(context, node);\n    }\n    case kTfLiteInt16: {\n      return ReverseSequenceHelper<int16_t>(context, node);\n    }\n    case kTfLiteInt32: {\n      return ReverseSequenceHelper<int32_t>(context, node);\n    }\n    case kTfLiteInt64: {\n      return ReverseSequenceHelper<int64_t>(context, node);\n    }\n    default: {\n      context->ReportError(context,\n                           \"Type '%s' is not supported by reverse_sequence.\",\n                           TfLiteTypeGetName(output->type));\n      return kTfLiteError;\n    }\n  }\n  return kTfLiteOk;\n}  // namespace\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_bitmap_data(STREAM s)\n{\n\tuint16 left, top, right, bottom, width, height;\n\tuint16 cx, cy, bpp, Bpp, flags, bufsize, size;\n\tuint8 *data, *bmpdata;\n\t\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tstruct stream packet = *s;\n\n\tin_uint16_le(s, left); \n\tin_uint16_le(s, top); \n\tin_uint16_le(s, right); \n\tin_uint16_le(s, bottom); \n\tin_uint16_le(s, width); \n\tin_uint16_le(s, height); \n\tin_uint16_le(s, bpp); \n\tBpp = (bpp + 7) / 8;\n\tin_uint16_le(s, flags); \n\tin_uint16_le(s, bufsize); \n\n\tcx = right - left + 1;\n\tcy = bottom - top + 1;\n\n\t\n\n\tif (Bpp == 0 || width == 0 || height == 0)\n\t{\n        logger(Protocol, Warning, \"%s(), [%d,%d,%d,%d], [%d,%d], bpp=%d, flags=%x\", __func__,\n\t\t\t\tleft, top, right, bottom, width, height, bpp, flags);\n\t\trdp_protocol_error(\"TS_BITMAP_DATA, unsafe size of bitmap data received from server\", &packet);\n\t}\n\n\tif ((RD_UINT32_MAX / Bpp) <= (width * height))\n\t{\n\t\tlogger(Protocol, Warning, \"%s(), [%d,%d,%d,%d], [%d,%d], bpp=%d, flags=%x\", __func__,\n\t\t\t\tleft, top, right, bottom, width, height, bpp, flags);\n\t\trdp_protocol_error(\"TS_BITMAP_DATA, unsafe size of bitmap data received from server\", &packet);\n\t}\n \n\tif (flags == 0)\n\t{\n\t\t\n\t\tint y;\n\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\tfor (y = 0; y < height; y++)\n\t\t{\n\t\t\tin_uint8a(s, &bmpdata[(height - y - 1) * (width * Bpp)], width * Bpp);\n\t\t}\n\t\t\n\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\txfree(bmpdata);\n\t\treturn;\n\t}\n\n\tif (flags & NO_BITMAP_COMPRESSION_HDR)\n\t{\n\t\tsize = bufsize;\n\t}\n\telse\n\t{\n\t\t\n\t\tin_uint8s(s, 2);        \n\t\tin_uint16_le(s, size);  \n\t\tin_uint8s(s, 2);        \n\t\tin_uint8s(s, 2);        \n\t}\n\n\t\n\tif (!s_check_rem(s, size))\n\t{\n\t\trdp_protocol_error(\"process_bitmap_data(), consume of bitmap data from stream would overrun\", &packet);\n\t}\n\tin_uint8p(s, data, size);\n\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n\t{\n\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t}\n\telse\n\t{\n\t\tlogger(Protocol, Warning, \"%s(), failed to decompress bitmap\", __func__);\n\t}\n\n\txfree(bmpdata);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_bitmap_updates(STREAM s)\n{\n\tuint16 num_updates;\n\tuint16 left, top, right, bottom, width, height;\n\tuint16 cx, cy, bpp, Bpp, compress, bufsize, size;\n\tuint8 *data, *bmpdata;\n\tint i;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint16_le(s, num_updates);\n\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tin_uint16_le(s, left);\n\t\tin_uint16_le(s, top);\n\t\tin_uint16_le(s, right);\n\t\tin_uint16_le(s, bottom);\n\t\tin_uint16_le(s, width);\n\t\tin_uint16_le(s, height);\n\t\tin_uint16_le(s, bpp);\n\t\tBpp = (bpp + 7) / 8;\n\t\tin_uint16_le(s, compress);\n\t\tin_uint16_le(s, bufsize);\n\n\t\tcx = right - left + 1;\n\t\tcy = bottom - top + 1;\n\n\t\tlogger(Graphics, Debug,\n\t\t       \"process_bitmap_updates(), [%d,%d,%d,%d], [%d,%d], bpp=%d, compression=%d\",\n\t\t       left, top, right, bottom, width, height, Bpp, compress);\n\n\t\tif (!compress)\n\t\t{\n\t\t\tint y;\n\t\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\t\tfor (y = 0; y < height; y++)\n\t\t\t{\n\t\t\t\tin_uint8a(s, &bmpdata[(height - y - 1) * (width * Bpp)],\n\t\t\t\t\t  width * Bpp);\n\t\t\t}\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\t\txfree(bmpdata);\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (compress & 0x400)\n\t\t{\n\t\t\tsize = bufsize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin_uint8s(s, 2);\t\n\t\t\tin_uint16_le(s, size);\n\t\t\tin_uint8s(s, 4);\t\n\t\t}\n\t\tin_uint8p(s, data, size);\n\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n\t\t{\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_bitmap_updates(), failed to decompress bitmap\");\n\t\t}\n\n\t\txfree(bmpdata);\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150) \n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nMOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) {\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char huff_magic[5];\n    mobi_buffer_getstring(huff_magic, buf, 4);\n    const size_t header_length = mobi_buffer_get32(buf);\n    if (strncmp(huff_magic, HUFF_MAGIC, 4) != 0 || header_length < HUFF_HEADER_LEN) {\n        debug_print(\"HUFF wrong magic: %s\\n\", huff_magic);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t data1_offset = mobi_buffer_get32(buf);\n    const size_t data2_offset = mobi_buffer_get32(buf);\n    \n    mobi_buffer_setpos(buf, data1_offset);\n    if (buf->offset + (256 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data1 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    \n    for (int i = 0; i < 256; i++) {\n        huffcdic->table1[i] = mobi_buffer_get32(buf);\n    }\n    mobi_buffer_setpos(buf, data2_offset);\n    if (buf->offset + (64 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data2 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    \n    huffcdic->mincode_table[0] = 0;\n    huffcdic->maxcode_table[0] = 0xFFFFFFFF;\n    for (int i = 1; i < HUFF_CODETABLE_SIZE; i++) {\n        const uint32_t mincode = mobi_buffer_get32(buf);\n        const uint32_t maxcode = mobi_buffer_get32(buf);\n        huffcdic->mincode_table[i] =  mincode << (32 - i);\n        huffcdic->maxcode_table[i] =  ((maxcode + 1) << (32 - i)) - 1;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nnext_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nfind_ucmd(\n    exarg_T\t*eap,\n    char_u\t*p,\t    int\t\t*full,\t    expand_T\t*xp,\t    int\t\t*complp){\n    int\t\tlen = (int)(p - eap->cmd);\n    int\t\tj, k, matchlen = 0;\n    ucmd_T\t*uc;\n    int\t\tfound = FALSE;\n    int\t\tpossible = FALSE;\n    char_u\t*cp, *np;\t       garray_T\t*gap;\n    int\t\tamb_local = FALSE; \t\t\t\t   \n    \n    gap =\n#ifdef FEAT_CMDWIN\n\tis_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :\n#endif\n\t&curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (j = 0; j < gap->ga_len; ++j)\n\t{\n\t    uc = USER_CMD_GA(gap, j);\n\t    cp = eap->cmd;\n\t    np = uc->uc_name;\n\t    k = 0;\n\t    while (k < len && *np != NUL && *cp++ == *np++)\n\t\tk++;\n\t    if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k])))\n\t    {\n\t\t\t\t\tif (k == len && found && *np != NUL)\n\t\t{\n\t\t    if (gap == &ucmds)\n\t\t\treturn NULL;\n\t\t    amb_local = TRUE;\n\t\t}\n\n\t\tif (!found || (k == len && *np == NUL))\n\t\t{\n\t\t   \t\t   \t\t   \t\t    if (k == len)\n\t\t\tfound = TRUE;\n\t\t    else\n\t\t\tpossible = TRUE;\n\n\t\t    if (gap == &ucmds)\n\t\t\teap->cmdidx = CMD_USER;\n\t\t    else\n\t\t\teap->cmdidx = CMD_USER_BUF;\n\t\t    eap->argt = (long)uc->uc_argt;\n\t\t    eap->useridx = j;\n\t\t    eap->addr_type = uc->uc_addr_type;\n\n\t\t    if (complp != NULL)\n\t\t\t*complp = uc->uc_compl;\n# ifdef FEAT_EVAL\n\t\t    if (xp != NULL)\n\t\t    {\n\t\t\txp->xp_arg = uc->uc_compl_arg;\n\t\t\txp->xp_script_ctx = uc->uc_script_ctx;\n\t\t\txp->xp_script_ctx.sc_lnum += SOURCING_LNUM;\n\t\t    }\n# endif\n\t\t   \t\t   \t\t    matchlen = k;\n\t\t    if (k == len && *np == NUL)\n\t\t    {\n\t\t\tif (full != NULL)\n\t\t\t    *full = TRUE;\n\t\t\tamb_local = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (j < gap->ga_len || gap == &ucmds)\n\t    break;\n\tgap = &ucmds;\n    }\n\n       if (amb_local)\n    {\n\tif (xp != NULL)\n\t    xp->xp_context = EXPAND_UNSUCCESSFUL;\n\treturn NULL;\n    }\n\n          if (found || possible)\n\treturn p + (matchlen - len);\n    return p;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\n\t\t\t\t  int offset, size_t count)\n{\n\tint len = iov_length(from, count) - offset;\n\tint copy = skb_headlen(skb);\n\tint size, offset1 = 0;\n\tint i = 0;\n\n\t\n\twhile (count && (offset >= from->iov_len)) {\n\t\toffset -= from->iov_len;\n\t\t++from;\n\t\t--count;\n\t}\n\n\t\n\twhile (count && (copy > 0)) {\n\t\tsize = min_t(unsigned int, copy, from->iov_len - offset);\n\t\tif (copy_from_user(skb->data + offset1, from->iov_base + offset,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (copy > size) {\n\t\t\t++from;\n\t\t\t--count;\n\t\t\toffset = 0;\n\t\t} else\n\t\t\toffset += size;\n\t\tcopy -= size;\n\t\toffset1 += size;\n\t}\n\n\tif (len == offset1)\n\t\treturn 0;\n\n\twhile (count--) {\n\t\tstruct page *page[MAX_SKB_FRAGS];\n\t\tint num_pages;\n\t\tunsigned long base;\n\t\tunsigned long truesize;\n\n\t\tlen = from->iov_len - offset;\n\t\tif (!len) {\n\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif ((num_pages != size) ||\n\t\t    (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t\tskb->truesize += truesize;\n\t\tatomic_add(truesize, &skb->sk->sk_wmem_alloc);\n\t\twhile (len) {\n\t\t\tint off = base & ~PAGE_MASK;\n\t\t\tint size = min_t(int, len, PAGE_SIZE - off);\n\t\t\t__skb_fill_page_desc(skb, i, page[i], off, size);\n\t\t\tskb_shinfo(skb)->nr_frags++;\n\t\t\t\n\t\t\tbase += size;\n\t\t\tlen -= size;\n\t\t\ti++;\n\t\t}\n\t\toffset = 0;\n\t\t++from;\n\t}\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint main(int argc, char *argv[])\n{\n  char *p, *q, *r;\n\n  Clp_Parser *clp =\n    Clp_NewParser(argc, (const char * const *)argv, sizeof(options) / sizeof(options[0]), options);\n  program_name = Clp_ProgramName(clp);\n\n  \n  while (1) {\n    int opt = Clp_Next(clp);\n    switch (opt) {\n\n     case BLOCK_LEN_OPT:\n      blocklen = clp->val.i;\n      break;\n\n     output_file:\n     case OUTPUT_OPT:\n      if (ofp)\n\tfatal_error(\"output file already specified\");\n      if (strcmp(clp->vstr, \"-\") == 0)\n\tofp = stdout;\n      else if (!(ofp = fopen(clp->vstr, \"w\")))\n\tfatal_error(\"%s: %s\", clp->vstr, strerror(errno));\n      break;\n\n     case PFB_OPT:\n      pfb = 1;\n      break;\n\n     case PFA_OPT:\n      pfb = 0;\n      break;\n\n     case HELP_OPT:\n      usage();\n      exit(0);\n      break;\n\n     case VERSION_OPT:\n      printf(\"t1asm (LCDF t1utils) %s\\n\", VERSION);\n      printf(\"Copyright (C) 1992-2010 I. Lee Hetherington, Eddie Kohler et al.\\n\\\nThis is free software; see the source for copying conditions.\\n\\\nThere is NO warranty, not even for merchantability or fitness for a\\n\\\nparticular purpose.\\n\");\n      exit(0);\n      break;\n\n     case Clp_NotOption:\n      if (ifp && ofp)\n\tfatal_error(\"too many arguments\");\n      else if (ifp)\n\tgoto output_file;\n      if (strcmp(clp->vstr, \"-\") == 0)\n\tifp = stdin;\n      else if (!(ifp = fopen(clp->vstr, \"r\")))\n\tfatal_error(\"%s: %s\", clp->vstr, strerror(errno));\n      break;\n\n     case Clp_Done:\n      goto done;\n\n     case Clp_BadOption:\n      short_usage();\n      exit(1);\n      break;\n\n    }\n  }\n\n done:\n  if (!pfb) {\n    if (blocklen == -1)\n      blocklen = 64;\n    else if (blocklen < 8) {\n      blocklen = 8;\n      error(\"warning: line length raised to %d\", blocklen);\n    } else if (blocklen > 1024) {\n      blocklen = 1024;\n      error(\"warning: line length lowered to %d\", blocklen);\n    }\n  }\n\n  if (!ifp) ifp = stdin;\n  if (!ofp) ofp = stdout;\n\n  if (pfb)\n    init_pfb_writer(&w, blocklen, ofp);\n\n#if defined(_MSDOS) || defined(_WIN32)\n  \n  \n  if (pfb)\n    _setmode(_fileno(ofp), _O_BINARY);\n#endif\n\n  \n\n  while (!feof(ifp) && !ferror(ifp)) {\n    t1utils_getline();\n\n    if (!ever_active) {\n      if (strncmp(line, \"currentfile eexec\", 17) == 0 && isspace(line[17])) {\n\t\n\tfor (p = line + 18; isspace(*p); p++)\n\t  ;\n\teexec_start(p);\n\tcontinue;\n      } else if (strncmp(line, \"/lenIV\", 6) == 0) {\n\tlenIV = atoi(line + 6);\n      } else if ((p = strstr(line, \"string currentfile\"))\n\t\t && strstr(line, \"readstring\")) { \n\t\n\t*p = '\\0';                                  \n\tq = strrchr(line, '/');\n\tif (q) {\n\t  r = cs_start;\n\t  ++q;\n\t  while (!isspace(*q) && *q != '{')\n\t    *r++ = *q++;\n\t  *r = '\\0';\n\t}\n\t*p = 's';                                   \n      }\n    }\n\n    if (!active) {\n      if ((p = strstr(line, \"/Subrs\")) && isdigit(p[7]))\n\tever_active = active = 1;\n      else if ((p = strstr(line, \"/CharStrings\")) && isdigit(p[13]))\n\tever_active = active = 1;\n    }\n    if ((p = strstr(line, \"currentfile closefile\"))) {\n      \n      \n      p += sizeof(\"currentfile closefile\") - 1;\n      for (q = p; isspace(*q) && *q != '\\n'; q++)\n\t;\n      if (q == p && !*q)\n\terror(\"warning: `currentfile closefile' line too long\");\n      else if (q != p) {\n\tif (*q != '\\n')\n\t  error(\"text after `currentfile closefile' ignored\");\n\t*p++ = '\\n';\n\t*p++ = '\\0';\n      }\n      eexec_string(line);\n      break;\n    }\n\n    eexec_string(line);\n\n    \n    if (start_charstring) {\n      if (!cs_start[0])\n\tfatal_error(\"couldn't find charstring start command\");\n      parse_charstring();\n    }\n  }\n\n  \n  if (in_eexec)\n    eexec_end();\n\n  \n  while (!feof(ifp) && !ferror(ifp)) {\n    t1utils_getline();\n    eexec_string(line);\n  }\n\n  if (pfb)\n    pfb_writer_end(&w);\n\n  \n  if (!ever_active)\n    error(\"warning: no charstrings found in input file\");\n  fclose(ifp);\n  fclose(ofp);\n  return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nrdpsnddbg_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tstatic char *rest = NULL;\n\tchar *buf;\n\n\tif (!s_check(s))\n\t{\n\t\trdp_protocol_error(\"rdpsnddbg_process(), stream is in unstable state\", s);\n\t}\n\n\tpkglen = s->end - s->p;\n\t\n\tbuf = (char *) xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\n\tstr_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);\n\n\txfree(buf);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  std::shared_ptr<Grammar> perform_core(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    Data data;\n    any dt = &data;\n    auto r = g[\"Grammar\"].parse(s, n, dt);\n\n    if (!r.ret) {\n      if (log) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      }\n      return nullptr;\n    }\n\n    auto &grammar = *data.grammar;\n\n       for (const auto &x : rules) {\n      auto name = x.first;\n      bool ignore = false;\n      if (!name.empty() && name[0] == '~') {\n        ignore = true;\n        name.erase(0, 1);\n      }\n      if (!name.empty()) {\n        auto &rule = grammar[name];\n        rule <= x.second;\n        rule.name = name;\n        rule.ignoreSemanticValue = ignore;\n      }\n    }\n\n       bool ret = data.duplicates.empty();\n\n    for (const auto &x : data.duplicates) {\n      if (log) {\n        const auto &name = x.first;\n        auto ptr = x.second;\n        auto line = line_info(s, ptr);\n        log(line.first, line.second, \"'\" + name + \"' is already defined.\");\n      }\n    }\n\n       {\n      auto &rule = grammar[data.start];\n      if (rule.ignoreSemanticValue) {\n        if (log) {\n          auto line = line_info(s, rule.s_);\n          log(line.first, line.second,\n              \"Ignore operator cannot be applied to '\" + rule.name + \"'.\");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n       for (auto &x : grammar) {\n      auto &rule = x.second;\n\n      ReferenceChecker vis(*data.grammar, rule.params);\n      rule.accept(vis);\n      for (const auto &y : vis.error_s) {\n        const auto &name = y.first;\n        const auto ptr = y.second;\n        if (log) {\n          auto line = line_info(s, ptr);\n          log(line.first, line.second, vis.error_message[name]);\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n       for (auto &x : grammar) {\n      auto &rule = x.second;\n      LinkReferences vis(*data.grammar, rule.params);\n      rule.accept(vis);\n    }\n\n       ret = true;\n\n    for (auto &x : grammar) {\n      const auto &name = x.first;\n      auto &rule = x.second;\n\n      DetectLeftRecursion vis(name);\n      rule.accept(vis);\n      if (vis.error_s) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second, \"'\" + name + \"' is left recursive.\");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n       auto &start_rule = (*data.grammar)[data.start];\n\n       {\n      DetectInfiniteLoop vis(data.start_pos, data.start);\n      start_rule.accept(vis);\n      if (vis.has_error) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second,\n              \"infinite loop is detected in '\" + vis.error_name + \"'.\");\n        }\n        return nullptr;\n      }\n    }\n\n       if (grammar.count(WHITESPACE_DEFINITION_NAME)) {\n      for (auto &x : grammar) {\n        auto &rule = x.second;\n        auto ope = rule.get_core_operator();\n        if (IsLiteralToken::check(*ope)) { rule <= tok(ope); }\n      }\n\n      start_rule.whitespaceOpe =\n          wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());\n    }\n\n       if (grammar.count(WORD_DEFINITION_NAME)) {\n      start_rule.wordOpe =\n          (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();\n    }\n\n       for (const auto &item : data.instructions) {\n      const auto &name = item.first;\n      const auto &instruction = item.second;\n      auto &rule = grammar[name];\n\n      if (instruction.type == \"precedence\") {\n        const auto &info =\n            any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);\n\n        if (!apply_precedence_instruction(rule, info, s, log)) {\n          return nullptr;\n        }\n      }\n    }\n\n       start = data.start;\n\n    return data.grammar;\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint read_xattrs_from_disk(int fd, struct squashfs_super_block *sBlk, int flag, long long *table_start)\n{\n\t\n\tint res, i, indexes, index_bytes;\n\tunsigned int ids;\n\tlong long bytes;\n\tlong long *index, start, end;\n\tstruct squashfs_xattr_table id_table;\n\n\tTRACE(\"read_xattrs_from_disk\\n\");\n\n\tif(sBlk->xattr_id_table_start == SQUASHFS_INVALID_BLK)\n\t\treturn SQUASHFS_INVALID_BLK;\n\n\t\n\tres = read_fs_bytes(fd, sBlk->xattr_id_table_start, sizeof(id_table),\n\t\t&id_table);\n\tif(res == 0)\n\t\treturn 0;\n\n\tSQUASHFS_INSWAP_XATTR_TABLE(&id_table);\n\n\t\n\tids = id_table.xattr_ids;\n\txattr_table_start = id_table.xattr_table_start;\n\tindex_bytes = SQUASHFS_XATTR_BLOCK_BYTES((long long) ids);\n\tindexes = SQUASHFS_XATTR_BLOCKS((long long) ids);\n\n\t\n\tif(index_bytes != (sBlk->bytes_used - (sBlk->xattr_id_table_start + sizeof(id_table)))) {\n\t\tERROR(\"read_xattrs_from_disk: Bad xattr_ids count in super block\\n\");\n\t\treturn 0;\n\t}\n\n\t\n\tif(table_start != NULL)\n\t\t*table_start = id_table.xattr_table_start;\n\n\t\n\tif(flag)\n\t\treturn id_table.xattr_ids;\n\n\t\n\tindex = malloc(index_bytes);\n\tif(index == NULL)\n\t\tMEM_ERROR();\n\n\tres = read_fs_bytes(fd, sBlk->xattr_id_table_start + sizeof(id_table),\n\t\tindex_bytes, index);\n\tif(res ==0)\n\t\tgoto failed1;\n\n\tSQUASHFS_INSWAP_LONG_LONGS(index, indexes);\n\n\t\n\tbytes = SQUASHFS_XATTR_BYTES((long long) ids);\n\txattr_ids = malloc(bytes);\n\tif(xattr_ids == NULL)\n\t\tMEM_ERROR();\n\n\tfor(i = 0; i < indexes; i++) {\n\t\tint expected = (i + 1) != indexes ? SQUASHFS_METADATA_SIZE :\n\t\t\t\t\tbytes & (SQUASHFS_METADATA_SIZE - 1);\n\t\tint length = read_block(fd, index[i], NULL, expected,\n\t\t\t((unsigned char *) xattr_ids) +\n\t\t\t((long long) i * SQUASHFS_METADATA_SIZE));\n\t\tTRACE(\"Read xattr id table block %d, from 0x%llx, length \"\n\t\t\t\"%d\\n\", i, index[i], length);\n\t\tif(length == 0) {\n\t\t\tERROR(\"Failed to read xattr id table block %d, \"\n\t\t\t\t\"from 0x%llx, length %d\\n\", i, index[i],\n\t\t\t\tlength);\n\t\t\tgoto failed2;\n\t\t}\n\t}\n\n\t\n\tstart = xattr_table_start;\n\tend = index[0];\n\tfor(i = 0; start < end; i++) {\n\t\tint length;\n\t\txattrs = realloc(xattrs, (i + 1) * SQUASHFS_METADATA_SIZE);\n\t\tif(xattrs == NULL)\n\t\t\tMEM_ERROR();\n\n\t\t\n\t\tsave_xattr_block(start, i * SQUASHFS_METADATA_SIZE);\n\n\t\tlength = read_block(fd, start, &start, 0,\n\t\t\t((unsigned char *) xattrs) +\n\t\t\t(i * SQUASHFS_METADATA_SIZE));\n\t\tTRACE(\"Read xattr block %d, length %d\\n\", i, length);\n\t\tif(length == 0) {\n\t\t\tERROR(\"Failed to read xattr block %d\\n\", i);\n\t\t\tgoto failed3;\n\t\t}\n\n\t\t\n\t\tif(start != end && length != SQUASHFS_METADATA_SIZE) {\n\t\t\tERROR(\"Xattr block %d should be %d bytes in length, \"\n\t\t\t\t\"it is %d bytes\\n\", i, SQUASHFS_METADATA_SIZE,\n\t\t\t\tlength);\n\t\t\tgoto failed3;\n\t\t}\n\t}\n\n\t\n\tfor(i = 0; i < ids; i++)\n\t\tSQUASHFS_INSWAP_XATTR_ID(&xattr_ids[i]);\n\n\tfree(index);\n\n\treturn ids;\n\nfailed3:\n\tfree(xattrs);\nfailed2:\n\tfree(xattr_ids);\nfailed1:\n\tfree(index);\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void ptrace_unfreeze_traced(struct task_struct *task)\n{\n\tif (task->state != __TASK_TRACED)\n\t\treturn;\n\n\tWARN_ON(!task->ptrace || task->parent != current);\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (__fatal_signal_pending(task))\n\t\twake_up_state(task, __TASK_TRACED);\n\telse\n\t\ttask->state = TASK_TRACED;\n\tspin_unlock_irq(&task->sighand->siglock);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast2obj_keyword(void* _o)\n{\n    keyword_ty o = (keyword_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(keyword_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->arg);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_arg, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_expr(o->value);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n\tht->nTableSize = zend_hash_check_size(nSize);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int save_dev(blkid_dev dev, FILE *file)\n{\n\tstruct list_head *p;\n\n\tif (!dev || dev->bid_name[0] != '/')\n\t\treturn 0;\n\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Command Injection"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct sock *sock;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\tstruct sk_buff *nc;\n\n\taudit_mq_notify(mqdes, notification);\n\n\tnc = NULL;\n\tsock = NULL;\n\tif (notification != NULL) {\n\t\tif (unlikely(notification->sigev_notify != SIGEV_NONE &&\n\t\t\t     notification->sigev_notify != SIGEV_SIGNAL &&\n\t\t\t     notification->sigev_notify != SIGEV_THREAD))\n\t\t\treturn -EINVAL;\n\t\tif (notification->sigev_notify == SIGEV_SIGNAL &&\n\t\t\t!valid_signal(notification->sigev_signo)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (notification->sigev_notify == SIGEV_THREAD) {\n\t\t\tlong timeo;\n\n\t\t\t\n\t\t\tnc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);\n\t\t\tif (!nc) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (copy_from_user(nc->data,\n\t\t\t\t\tnotification->sigev_value.sival_ptr,\n\t\t\t\t\tNOTIFY_COOKIE_LEN)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t\n\t\t\tskb_put(nc, NOTIFY_COOKIE_LEN);\n\t\t\t\nretry:\n\t\t\tf = fdget(notification->sigev_signo);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsock = netlink_getsockbyfilp(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(sock)) {\n\t\t\t\tret = PTR_ERR(sock);\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n\t\t\tret = netlink_attachskb(sock, nc, &timeo, NULL);\n\t\t\tif (ret == 1) {\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tsock = NULL;\n\t\t\t\tnc = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tf = fdget(mqdes);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\n\tret = 0;\n\tspin_lock(&info->lock);\n\tif (notification == NULL) {\n\t\tif (info->notify_owner == task_tgid(current)) {\n\t\t\tremove_notification(info);\n\t\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t\t}\n\t} else if (info->notify_owner != NULL) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tswitch (notification->sigev_notify) {\n\t\tcase SIGEV_NONE:\n\t\t\tinfo->notify.sigev_notify = SIGEV_NONE;\n\t\t\tbreak;\n\t\tcase SIGEV_THREAD:\n\t\t\tinfo->notify_sock = sock;\n\t\t\tinfo->notify_cookie = nc;\n\t\t\tsock = NULL;\n\t\t\tnc = NULL;\n\t\t\tinfo->notify.sigev_notify = SIGEV_THREAD;\n\t\t\tbreak;\n\t\tcase SIGEV_SIGNAL:\n\t\t\tinfo->notify.sigev_signo = notification->sigev_signo;\n\t\t\tinfo->notify.sigev_value = notification->sigev_value;\n\t\t\tinfo->notify.sigev_notify = SIGEV_SIGNAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->notify_owner = get_pid(task_tgid(current));\n\t\tinfo->notify_user_ns = get_user_ns(current_user_ns());\n\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t}\n\tspin_unlock(&info->lock);\nout_fput:\n\tfdput(f);\nout:\n\tif (sock)\n\t\tnetlink_detachskb(sock, nc);\n\telse if (nc)\n\t\tdev_kfree_skb(nc);\n\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                           TfLiteFullyConnectedParams* params, OpData* data,\n                           const TfLiteTensor* input,\n                           const TfLiteTensor* filter, const TfLiteTensor* bias,\n                           TfLiteTensor* output) {\n  int32_t input_offset = -input->params.zero_point;\n  int32_t filter_offset = -filter->params.zero_point;\n  int32_t output_offset = output->params.zero_point;\n   if (input->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized = GetTemporary(context, node, 0);\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, 1);\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, 2);\n    TfLiteTensor* input_offsets = GetTemporary(context, node, 3);\n    TfLiteTensor* row_sums = GetTemporary(context, node, 4);\n    return EvalHybrid(context, node, params, data, input, filter, bias,\n                      input_quantized, scaling_factors, accum_scratch, row_sums,\n                      input_offsets, output);\n  } else {\n    FullyConnectedParams op_params;\n    op_params.input_offset = input_offset;\n    op_params.weights_offset = filter_offset;\n    op_params.output_offset = output_offset;\n    op_params.output_multiplier = data->output_multiplier;\n    op_params.output_shift = data->output_shift;\n    op_params.quantized_activation_min = data->output_activation_min;\n    op_params.quantized_activation_max = data->output_activation_max;\n    op_params.lhs_cacheable = IsConstantTensor(filter);\n    op_params.rhs_cacheable = IsConstantTensor(input);\n    switch (output->type) {\n      case kTfLiteUInt8:\n        if (kernel_type == kReference) {\n          reference_ops::FullyConnected(\n              op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n              GetTensorShape(filter), GetTensorData<uint8_t>(filter),\n              GetTensorShape(bias), GetTensorData<int32_t>(bias),\n              GetTensorShape(output), GetTensorData<uint8_t>(output));\n        } else {\n          optimized_ops::FullyConnected(\n              op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n              GetTensorShape(filter), GetTensorData<uint8_t>(filter),\n              GetTensorShape(bias), GetTensorData<int32_t>(bias),\n              GetTensorShape(output), GetTensorData<uint8_t>(output),\n              CpuBackendContext::GetFromContext(context));\n        }\n        break;\n      case kTfLiteInt8:\n        FullyConnectedInt8<kernel_type>(\n            data, input, filter, bias, output,\n            CpuBackendContext::GetFromContext(context));\n        break;\n      case kTfLiteInt16:\n        if (input->type == kTfLiteInt16) {\n          FullyConnectedInt16<kernel_type>(data, input, filter, bias, output);\n        } else if (kernel_type == kReference) {\n          reference_ops::FullyConnected(\n              op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n              GetTensorShape(filter), GetTensorData<uint8_t>(filter),\n              GetTensorShape(bias), GetTensorData<int32_t>(bias),\n              GetTensorShape(output), GetTensorData<int16_t>(output));\n        } else {\n          optimized_ops::FullyConnected(\n              op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n              GetTensorShape(filter), GetTensorData<uint8_t>(filter),\n              GetTensorShape(bias), GetTensorData<int32_t>(bias),\n              GetTensorShape(output), GetTensorData<int16_t>(output),\n              CpuBackendContext::GetFromContext(context));\n        }\n        break;\n      default:\n        context->ReportError(context,\n                             \"Quantized FullyConnected expects output data \"\n                             \"type uint8, int8 or int16\");\n        return kTfLiteError;\n    }\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool Archive::Open(const wchar *Name,uint Mode)\n{\n#ifdef USE_QOPEN\n    QOpen.Unload();\n#endif\n\n#ifdef USE_ARCMEM\n  if (Cmd->ArcInMem)\n  {\n    wcsncpyz(FileName,Name,ASIZE(FileName));\n    ArcMem.Load(Cmd->ArcMemData,Cmd->ArcMemSize);\n    Cmd->SetArcInMem(NULL,0);    return true;\n  }\n#endif\n\n  return File::Open(Name,Mode);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  switch (input1->type) {\n    case kTfLiteInt32: {\n      return EvalImpl<int32_t>(context, data->requires_broadcast, input1,\n                               input2, output);\n    }\n    case kTfLiteInt64: {\n      return EvalImpl<int64_t>(context, data->requires_broadcast, input1,\n                               input2, output);\n    }\n    case kTfLiteFloat32: {\n      return EvalImpl<float>(context, data->requires_broadcast, input1, input2,\n                             output);\n    }\n    default: {\n      context->ReportError(context, \"Type '%s' is not supported by floor_mod.\",\n                           TfLiteTypeGetName(input1->type));\n      return kTfLiteError;\n    }\n  }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid trustedSetSEK_backup(int *errStatus, char *errString,\n                          uint8_t *encrypted_sek, uint32_t *enc_len, const char *sek_hex) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_sek);\n    CHECK_STATE(sek_hex);\n\n    uint64_t len;\n    hex2carray(sek_hex, &len, (uint8_t *) AES_key);\n    derive_DH_Key();\n\n    sealHexSEK(errStatus, errString, encrypted_sek, enc_len, (char *)sek_hex);\n\n    if (*errStatus != 0) {\n        LOG_ERROR(\"sealHexSEK failed\");\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n    if (!done) {\n    done = [] {};\n  }\n\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n    OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\n\tRETURN_TRUE;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n    std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc)\n    {\n        alloc = \"\";\n\n        size_t len = 0;\n        nc_inq_attlen(ncid, varId, attrName, &len);\n        \n        if(len < 1)\n        {\n            return alloc;\n        }\n\n        char attr_vals[NC_MAX_NAME + 1];\n        memset(attr_vals, 0, NC_MAX_NAME + 1);\n\n               if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR)\n        {\n            return alloc;\n        }\n\n        alloc = std::string(attr_vals);\n        return alloc;\n    }\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nhorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32* wp = (uint32*) cp0;\n\ttmsize_t wc = cc / 4;\n\n    if((cc%(4*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horAcc32\",\n                     \"%s\", \"cc%(4*stride))!=0\");\n        return 0;\n    }\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] += wp[0]; wp++)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n\treturn 1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus LessEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  bool requires_broadcast = !HaveSameShapes(input1, input2);\n  switch (input1->type) {\n    case kTfLiteFloat32:\n      Comparison<float, reference_ops::LessFn>(input1, input2, output,\n                                               requires_broadcast);\n      break;\n    case kTfLiteInt32:\n      Comparison<int32_t, reference_ops::LessFn>(input1, input2, output,\n                                                 requires_broadcast);\n      break;\n    case kTfLiteInt64:\n      Comparison<int64_t, reference_ops::LessFn>(input1, input2, output,\n                                                 requires_broadcast);\n      break;\n    case kTfLiteUInt8:\n      ComparisonQuantized<uint8_t, reference_ops::LessFn>(\n          input1, input2, output, requires_broadcast);\n      break;\n    case kTfLiteInt8:\n      ComparisonQuantized<int8_t, reference_ops::LessFn>(input1, input2, output,\n                                                         requires_broadcast);\n      break;\n    default:\n      context->ReportError(context,\n                           \"Does not support type %d, requires float|int|uint8\",\n                           input1->type);\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_for_arguments(struct compiling *c, const node *n)\n{\n    \n    int i, j, k, nposargs = 0, nkwonlyargs = 0;\n    int nposdefaults = 0, found_default = 0;\n    asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;\n    arg_ty vararg = NULL, kwarg = NULL;\n    arg_ty arg = NULL;\n    node *ch;\n\n    if (TYPE(n) == parameters) {\n        if (NCH(n) == 2) \n            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);\n        n = CHILD(n, 1);\n    }\n    assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);\n\n    \n    for (i = 0; i < NCH(n); i++) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == STAR) {\n            \n            i++;\n            if (i < NCH(n) && \n                (TYPE(CHILD(n, i)) == tfpdef ||\n                 TYPE(CHILD(n, i)) == vfpdef)) {\n                i++;\n            }\n            break;\n        }\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;\n        if (TYPE(ch) == EQUAL) nposdefaults++;\n    }\n    \n    for ( ; i < NCH(n); ++i) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;\n    }\n    posargs = (nposargs ? _Py_asdl_seq_new(nposargs, c->c_arena) : NULL);\n    if (!posargs && nposargs)\n        return NULL;\n    kwonlyargs = (nkwonlyargs ?\n                   _Py_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwonlyargs && nkwonlyargs)\n        return NULL;\n    posdefaults = (nposdefaults ?\n                    _Py_asdl_seq_new(nposdefaults, c->c_arena) : NULL);\n    if (!posdefaults && nposdefaults)\n        return NULL;\n    \n    kwdefaults = (nkwonlyargs ?\n                   _Py_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwdefaults && nkwonlyargs)\n        return NULL;\n\n    \n    i = 0;\n    j = 0;  \n    k = 0;  \n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case tfpdef:\n            case vfpdef:\n                \n                \n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        return NULL;\n                    assert(posdefaults != NULL);\n                    asdl_seq_SET(posdefaults, j++, expression);\n                    i += 2;\n                    found_default = 1;\n                }\n                else if (found_default) {\n                    ast_error(c, n,\n                              \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                arg = ast_for_arg(c, ch);\n                if (!arg)\n                    return NULL;\n                asdl_seq_SET(posargs, k++, arg);\n                i += 1; \n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case STAR:\n                if (i+1 >= NCH(n) ||\n                    (i+2 == NCH(n) && (TYPE(CHILD(n, i+1)) == COMMA\n                                       || TYPE(CHILD(n, i+1)) == TYPE_COMMENT))) {\n                    ast_error(c, CHILD(n, i),\n                              \"named arguments must follow bare *\");\n                    return NULL;\n                }\n                ch = CHILD(n, i+1);  \n                if (TYPE(ch) == COMMA) {\n                    int res = 0;\n                    i += 2; \n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        ast_error(c, CHILD(n, i),\n                                  \"bare * has associated type comment\");\n                        return NULL;\n                    }\n\n                    res = handle_keywordonly_args(c, n, i,\n                                                  kwonlyargs, kwdefaults);\n                    if (res == -1) return NULL;\n                    i = res; \n                }\n                else {\n                    vararg = ast_for_arg(c, ch);\n                    if (!vararg)\n                        return NULL;\n\n                i += 2; \n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        vararg->type_comment = NEW_TYPE_COMMENT(CHILD(n, i));\n                        if (!vararg->type_comment)\n                            return NULL;\n                        i += 1;\n                    }\n\n                    if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef\n                                    || TYPE(CHILD(n, i)) == vfpdef)) {\n                        int res = 0;\n                        res = handle_keywordonly_args(c, n, i,\n                                                      kwonlyargs, kwdefaults);\n                        if (res == -1) return NULL;\n                        i = res; \n                    }\n                }\n                break;\n            case DOUBLESTAR:\n                ch = CHILD(n, i+1);  \n                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);\n                kwarg = ast_for_arg(c, ch);\n                if (!kwarg)\n                    return NULL;\n                i += 2; \n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                assert(i);\n\n                if (kwarg)\n                    arg = kwarg;\n\n                \n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    return NULL;\n                i += 1;\n                break;\n            default:\n                PyErr_Format(PyExc_SystemError,\n                             \"unexpected node in varargslist: %d @ %d\",\n                             TYPE(ch), i);\n                return NULL;\n        }\n    }\n    return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ndouble GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return 0.0;\n\n\tuint32_t key, insamples;\n\tuint32_t repeat, outsamples;\n\tGPMF_stream find_stream;\n\n\tif (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;\n\n\tkey = GPMF_Key(gs);\n\trepeat = GPMF_Repeat(gs);\n\tif (rate == 0.0)\n\t\trate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);\n\n\tif (rate == 0.0)\n\t{\n\t\t*in = *out = 0.0;\n\t\treturn 0.0;\n\t}\n\n\tGPMF_CopyState(gs, &find_stream);\n\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n\t{\n\t\toutsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n\t\tinsamples = outsamples - repeat;\n\n\t\t*in = ((double)insamples / (double)rate);\n\t\t*out = ((double)outsamples / (double)rate);\n\t}\n\telse\n\t{\n\t\t\t*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n\t\t*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n\t}\n\treturn rate;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += stripsize;\n        }\n\n        return 1;\n} \n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid dm9000EventHandler(NetInterface *interface)\n{\n   error_t error;\n   uint8_t status;\n\n     status = dm9000ReadReg(DM9000_ISR);\n\n     if((status & DM9000_ISR_LNKCHG) != 0)\n   {\n           dm9000WriteReg(DM9000_ISR, DM9000_ISR_LNKCHG);\n           status = dm9000ReadReg(DM9000_NSR);\n\n           if((status & DM9000_NSR_LINKST) != 0)\n      {\n                 if((status & DM9000_NSR_SPEED) != 0)\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_10MBPS;\n         }\n         else\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_100MBPS;\n         }\n\n                 status = dm9000ReadReg(DM9000_NCR);\n\n                 if((status & DM9000_NCR_FDX) != 0)\n         {\n            interface->duplexMode = NIC_FULL_DUPLEX_MODE;\n         }\n         else\n         {\n            interface->duplexMode = NIC_HALF_DUPLEX_MODE;\n         }\n\n                 interface->linkState = TRUE;\n      }\n      else\n      {\n                 interface->linkState = FALSE;\n      }\n\n           nicNotifyLinkChange(interface);\n   }\n\n     if((status & DM9000_ISR_PR) != 0)\n   {\n           dm9000WriteReg(DM9000_ISR, DM9000_ISR_PR);\n\n           do\n      {\n                 error = dm9000ReceivePacket(interface);\n\n              } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n     dm9000WriteReg(DM9000_IMR, DM9000_IMR_PAR | DM9000_IMR_LNKCHGI |\n      DM9000_IMR_PTI | DM9000_IMR_PRI);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE(context, node->inputs->size == kInputNum);\n  TF_LITE_ENSURE(context, node->outputs->size == kOutputNum);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputData);\n  const TfLiteTensor* prev_activation =\n      GetInput(context, node, kInputPrevActivation);\n  const TfLiteTensor* weights = GetInput(context, node, kInputWeights);\n  const TfLiteTensor* bias = GetInput(context, node, kInputBiases);\n  const TfLiteTensor* prev_state = GetInput(context, node, kInputPrevState);\n\n  TF_LITE_ENSURE_EQ(context, input->dims->size, 2);\n  const int num_batches = input->dims->data[0];\n  const int input_depth = input->dims->data[1];\n\n  TF_LITE_ENSURE_EQ(context, prev_activation->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, prev_activation->dims->data[0], num_batches);\n  const int activation_depth = prev_activation->dims->data[1];\n  const int total_depth = input_depth + activation_depth;\n\n  TF_LITE_ENSURE_EQ(context, weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, weights->dims->data[0], 4 * activation_depth);\n  TF_LITE_ENSURE_EQ(context, weights->dims->data[1], total_depth);\n\n  TF_LITE_ENSURE_EQ(context, bias->dims->size, 1);\n  TF_LITE_ENSURE_EQ(context, bias->dims->data[0], 4 * activation_depth);\n\n  TF_LITE_ENSURE_EQ(context, prev_state->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, prev_state->dims->data[0], num_batches);\n  TF_LITE_ENSURE_EQ(context, prev_state->dims->data[1], activation_depth);\n\n  TfLiteTensor* activation_out = GetOutput(context, node, kOutputActivation);\n  TfLiteTensor* state_out = GetOutput(context, node, kOutputState);\n  TfLiteTensor* concat_temp = GetOutput(context, node, kOutputConcatTemp);\n  TfLiteTensor* activation_temp =\n      GetOutput(context, node, kOutputActivationTemp);\n\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(\n                                 context, activation_out,\n                                 TfLiteIntArrayCopy(prev_activation->dims)));\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(context, state_out,\n                                     TfLiteIntArrayCopy(prev_state->dims)));\n\n  TfLiteIntArray* concat_temp_size = TfLiteIntArrayCreate(2);\n  concat_temp_size->data[0] = num_batches;\n  concat_temp_size->data[1] = total_depth;\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(context, concat_temp, concat_temp_size));\n  TfLiteIntArray* activation_temp_size = TfLiteIntArrayCreate(2);\n  activation_temp_size->data[0] = num_batches;\n  activation_temp_size->data[1] = 4 * activation_depth;\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, activation_temp,\n                                                   activation_temp_size));\n\n   for (auto index : {kInputPrevActivation, kInputPrevState}) {\n    TfLiteTensor* tensor = &context->tensors[node->inputs->data[index]];\n    tensor->allocation_type = kTfLiteArenaRwPersistent;\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_bitmap_updates(STREAM s)\n{\n\tint i;\n\tuint16 num_updates;\n\t\n\tin_uint16_le(s, num_updates);   \n\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tprocess_bitmap_data(s);\n\t}\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus EvalHashtable(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE(context, node->user_data != nullptr);\n  const auto* params =\n      reinterpret_cast<const TfLiteHashtableParams*>(node->user_data);\n\n   const int resource_id = std::hash<std::string>{}(params->table_name);\n\n  TfLiteTensor* resource_handle_tensor =\n      GetOutput(context, node, kResourceHandleTensor);\n  auto* resource_handle_data =\n      GetTensorData<std::int32_t>(resource_handle_tensor);\n  resource_handle_data[0] = resource_id;\n\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  resource::CreateHashtableResourceIfNotAvailable(\n      &resources, resource_id, params->key_dtype, params->value_dtype);\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nDECLAREwriteFunc(writeBufferToContigTiles)\n{\n\tuint32 imagew = TIFFScanlineSize(out);\n\tuint32 tilew  = TIFFTileRowSize(out);\n\tint iskew = imagew - tilew;\n\ttsize_t tilesize = TIFFTileSize(out);\n\ttdata_t obuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tl, tw;\n\tuint32 row;\n\n\t(void) spp;\n\n\tobuf = _TIFFmalloc(TIFFTileSize(out));\n\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\t\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tint oskew = tilew - width;\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew);\n\t\t\t} else\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, tilew,\n\t\t\t\t    0, iskew);\n\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\t_TIFFfree(obuf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += nrow * imagew;\n\t}\n\t_TIFFfree(obuf);\n\treturn 1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid imap_quote_string_and_backquotes (char *dest, size_t dlen, const char *src)\n{\n  _imap_quote_string (dest, dlen, src, \"\\\"\\\\`\");\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  ruy::profiler::ScopeLabel label(\"MirrorPad\");\n  const TfLiteTensor* input_tensor = GetInput(context, node, 0);\n  const TfLiteTensor* padding_matrix = GetInput(context, node, 1);\n  auto* params =\n      reinterpret_cast<TfLiteMirrorPaddingParams*>(node->builtin_data);\n\n  if (params == nullptr) {\n    return kTfLiteError;\n  }\n  const int input_dims = NumDimensions(input_tensor);\n\n  TfLiteTensor* output_tensor = GetOutput(context, node, 0);\n  if (IsDynamicTensor(output_tensor)) {\n    auto output_size = GetPaddedOutputShape(input_tensor, padding_matrix);\n    if (output_size == nullptr) {\n      return kTfLiteError;\n    }\n    TF_LITE_ENSURE_STATUS(\n        context->ResizeTensor(context, output_tensor, output_size.release()));\n  }\n\n  std::vector<int> output_dims_num_elements(input_dims, 1);\n  std::vector<int> input_dims_num_elements(input_dims, 1);\n  for (int i = input_dims - 2; i >= 0; i--) {\n    output_dims_num_elements[i] =\n        output_dims_num_elements[i + 1] * output_tensor->dims->data[i + 1];\n    input_dims_num_elements[i] =\n        input_dims_num_elements[i + 1] * input_tensor->dims->data[i + 1];\n  }\n\n  const int offset =\n      params->mode != TfLiteMirrorPaddingMode::kTfLiteMirrorPaddingReflect ? 0\n                                                                           : 1;\n\n  CpuBackendContext* cpu_backend_context =\n      CpuBackendContext::GetFromContext(context);\n  const int thread_count = cpu_backend_context->max_num_threads();\n  TfLiteStatus status = kTfLiteOk;\n  const int output_size = NumElements(output_tensor);\n#define TF_LITE_MIRROR_PAD(type)                                           \\\n  EvalData<type> eval_data;                                                \\\n  eval_data.input_data = GetTensorData<type>(input_tensor);                \\\n  eval_data.input_dims = input_tensor->dims;                               \\\n  eval_data.input_dims = input_tensor->dims;                               \\\n  eval_data.output_dims_num_elements = &output_dims_num_elements;          \\\n  eval_data.input_dims_num_elements = &input_dims_num_elements;            \\\n  eval_data.num_dims = input_dims;                                         \\\n  eval_data.offset = offset;                                               \\\n  eval_data.output_data = GetTensorData<type>(output_tensor);              \\\n  eval_data.padding_matrix = padding_matrix;                               \\\n  std::vector<MirrorPadWorkerTask<type>> tasks;                            \\\n  tasks.reserve(thread_count);                                             \\\n  int start = 0;                                                           \\\n  for (int i = 0; i < thread_count; ++i) {                                 \\\n    int end = start + (output_size - start) / (thread_count - i);          \\\n    tasks.emplace_back(MirrorPadWorkerTask<type>(&eval_data, start, end)); \\\n    start = end;                                                           \\\n  }                                                                        \\\n  cpu_backend_threadpool::Execute(tasks.size(), tasks.data(),              \\\n                                  cpu_backend_context);\n\n  switch (output_tensor->type) {\n    case kTfLiteFloat32: {\n      TF_LITE_MIRROR_PAD(float);\n      break;\n    }\n    case kTfLiteInt32: {\n      TF_LITE_MIRROR_PAD(int32_t);\n      break;\n    }\n    case kTfLiteUInt8: {\n      TF_LITE_MIRROR_PAD(uint8_t);\n      break;\n    }\n    case kTfLiteInt8: {\n      TF_LITE_MIRROR_PAD(int8_t);\n      break;\n    }\n    case kTfLiteInt64: {\n      TF_LITE_MIRROR_PAD(int64_t);\n      break;\n    }\n    default:\n      status = kTfLiteError;\n      break;\n  }\n#undef TF_LITE_MIRROR_PAD\n  return status;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTEST(BasicFlatBufferModel, TestHandleMalformedModel) {\n  const auto model_paths = {\n           \"tensorflow/lite/testdata/add_shared_tensors.bin\",\n  };\n\n  for (const auto& model_path : model_paths) {\n    std::unique_ptr<tflite::FlatBufferModel> model =\n        FlatBufferModel::BuildFromFile(model_path);\n    ASSERT_NE(model, nullptr);\n\n    tflite::ops::builtin::BuiltinOpResolver resolver;\n    InterpreterBuilder builder(*model, resolver);\n    std::unique_ptr<Interpreter> interpreter;\n    ASSERT_EQ(builder(&interpreter), kTfLiteOk);\n    ASSERT_NE(interpreter, nullptr);\n    ASSERT_NE(interpreter->AllocateTensors(), kTfLiteOk);\n  }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t size,\n\t\t\t       int flags)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(iocb);\n\tstruct scm_cookie tmp_scm;\n\tstruct sock *sk = sock->sk;\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sockaddr_un *sunaddr = msg->msg_name;\n\tint copied = 0;\n\tint check_creds = 0;\n\tint target;\n\tint err = 0;\n\tlong timeo;\n\tint skip;\n\n\terr = -EINVAL;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\n\terr = -EOPNOTSUPP;\n\tif (flags&MSG_OOB)\n\t\tgoto out;\n\n\ttarget = sock_rcvlowat(sk, flags&MSG_WAITALL, size);\n\ttimeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);\n\n\tmsg->msg_namelen = 0;\n\n\t\n\n\tif (!siocb->scm) {\n\t\tsiocb->scm = &tmp_scm;\n\t\tmemset(&tmp_scm, 0, sizeof(tmp_scm));\n\t}\n\n\terr = mutex_lock_interruptible(&u->readlock);\n\tif (err) {\n\t\terr = sock_intr_errno(timeo);\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tint chunk;\n\t\tstruct sk_buff *skb, *last;\n\n\t\tunix_state_lock(sk);\n\t\tlast = skb = skb_peek(&sk->sk_receive_queue);\nagain:\n\t\tif (skb == NULL) {\n\t\t\tunix_sk(sk)->recursion_level = 0;\n\t\t\tif (copied >= target)\n\t\t\t\tgoto unlock;\n\n\t\t\t\n\n\t\t\terr = sock_error(sk);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tgoto unlock;\n\n\t\t\tunix_state_unlock(sk);\n\t\t\terr = -EAGAIN;\n\t\t\tif (!timeo)\n\t\t\t\tbreak;\n\t\t\tmutex_unlock(&u->readlock);\n\n\t\t\ttimeo = unix_stream_data_wait(sk, timeo, last);\n\n\t\t\tif (signal_pending(current)\n\t\t\t    ||  mutex_lock_interruptible(&u->readlock)) {\n\t\t\t\terr = sock_intr_errno(timeo);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcontinue;\n unlock:\n\t\t\tunix_state_unlock(sk);\n\t\t\tbreak;\n\t\t}\n\n\t\tskip = sk_peek_offset(sk, flags);\n\t\twhile (skip >= unix_skb_len(skb)) {\n\t\t\tskip -= unix_skb_len(skb);\n\t\t\tlast = skb;\n\t\t\tskb = skb_peek_next(skb, &sk->sk_receive_queue);\n\t\t\tif (!skb)\n\t\t\t\tgoto again;\n\t\t}\n\n\t\tunix_state_unlock(sk);\n\n\t\tif (check_creds) {\n\t\t\t\n\t\t\tif ((UNIXCB(skb).pid  != siocb->scm->pid) ||\n\t\t\t    !uid_eq(UNIXCB(skb).uid, siocb->scm->creds.uid) ||\n\t\t\t    !gid_eq(UNIXCB(skb).gid, siocb->scm->creds.gid))\n\t\t\t\tbreak;\n\t\t} else if (test_bit(SOCK_PASSCRED, &sock->flags)) {\n\t\t\t\n\t\t\tscm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);\n\t\t\tcheck_creds = 1;\n\t\t}\n\n\t\t\n\t\tif (sunaddr) {\n\t\t\tunix_copy_addr(msg, skb->sk);\n\t\t\tsunaddr = NULL;\n\t\t}\n\n\t\tchunk = min_t(unsigned int, unix_skb_len(skb) - skip, size);\n\t\tif (skb_copy_datagram_iovec(skb, UNIXCB(skb).consumed + skip,\n\t\t\t\t\t    msg->msg_iov, chunk)) {\n\t\t\tif (copied == 0)\n\t\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += chunk;\n\t\tsize -= chunk;\n\n\t\t\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tUNIXCB(skb).consumed += chunk;\n\n\t\t\tsk_peek_offset_bwd(sk, chunk);\n\n\t\t\tif (UNIXCB(skb).fp)\n\t\t\t\tunix_detach_fds(siocb->scm, skb);\n\n\t\t\tif (unix_skb_len(skb))\n\t\t\t\tbreak;\n\n\t\t\tskb_unlink(skb, &sk->sk_receive_queue);\n\t\t\tconsume_skb(skb);\n\n\t\t\tif (siocb->scm->fp)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t\n\t\t\tif (UNIXCB(skb).fp)\n\t\t\t\tsiocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);\n\n\t\t\tsk_peek_offset_fwd(sk, chunk);\n\n\t\t\tbreak;\n\t\t}\n\t} while (size);\n\n\tmutex_unlock(&u->readlock);\n\tscm_recv(sock, msg, siocb->scm, flags);\nout:\n\treturn copied ? : err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    \n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_type_init(PyObject *self, PyObject *args, PyObject *kw)\n{\n    _Py_IDENTIFIER(_fields);\n    Py_ssize_t i, numfields = 0;\n    int res = -1;\n    PyObject *key, *value, *fields;\n    fields = _PyObject_GetAttrId((PyObject*)Py_TYPE(self), &PyId__fields);\n    if (!fields)\n        PyErr_Clear();\n    if (fields) {\n        numfields = PySequence_Size(fields);\n        if (numfields == -1)\n            goto cleanup;\n    }\n    res = 0; \n    if (PyTuple_GET_SIZE(args) > 0) {\n        if (numfields != PyTuple_GET_SIZE(args)) {\n            PyErr_Format(PyExc_TypeError, \"%.400s constructor takes %s\"\n                         \"%zd positional argument%s\",\n                         Py_TYPE(self)->tp_name,\n                         numfields == 0 ? \"\" : \"either 0 or \",\n                         numfields, numfields == 1 ? \"\" : \"s\");\n            res = -1;\n            goto cleanup;\n        }\n        for (i = 0; i < PyTuple_GET_SIZE(args); i++) {\n            \n            PyObject *name = PySequence_GetItem(fields, i);\n            if (!name) {\n                res = -1;\n                goto cleanup;\n            }\n            res = PyObject_SetAttr(self, name, PyTuple_GET_ITEM(args, i));\n            Py_DECREF(name);\n            if (res < 0)\n                goto cleanup;\n        }\n    }\n    if (kw) {\n        i = 0;  \n        while (PyDict_Next(kw, &i, &key, &value)) {\n            res = PyObject_SetAttr(self, key, value);\n            if (res < 0)\n                goto cleanup;\n        }\n    }\n  cleanup:\n    Py_XDECREF(fields);\n    return res;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nnetdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *tmp_sdata, *sdata;\n\tstruct cfg80211_chan_def *chandef;\n\tu16 len_rthdr;\n\tint hdrlen;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t      IEEE80211_TX_CTL_INJECTED;\n\n\t\n\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n\t\tgoto fail;\n\n\t\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\n\t\n\tskb_set_mac_header(skb, len_rthdr);\n\t\n\tskb_set_network_header(skb, len_rthdr);\n\tskb_set_transport_header(skb, len_rthdr);\n\n\tif (skb->len < len_rthdr + 2)\n\t\tgoto fail;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (skb->len < len_rthdr + hdrlen)\n\t\tgoto fail;\n\n\t\n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {\n\t\tu8 *payload = (u8 *)hdr + hdrlen;\n\n\t\tif (ether_addr_equal(payload, rfc1042_header))\n\t\t\tskb->protocol = cpu_to_be16((payload[6] << 8) |\n\t\t\t\t\t\t    payload[7]);\n\t}\n\n\trcu_read_lock();\n\n\t\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tlist_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(tmp_sdata))\n\t\t\tcontinue;\n\t\tif (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(tmp_sdata->vif.addr, hdr->addr2)) {\n\t\t\tsdata = tmp_sdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\ttmp_sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tmp_sdata)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(tmp_sdata->vif.chanctx_conf);\n\t}\n\n\tif (chanctx_conf)\n\t\tchandef = &chanctx_conf->def;\n\telse if (!local->use_chanctx)\n\t\tchandef = &local->_oper_chandef;\n\telse\n\t\tgoto fail_rcu;\n\n\t\n\tif (!cfg80211_reg_can_beacon(local->hw.wiphy, chandef,\n\t\t\t\t     sdata->vif.type))\n\t\tgoto fail_rcu;\n\n\tinfo->band = chandef->chan->band;\n\n\t\n\tieee80211_select_queue_80211(sdata, skb, hdr);\n\tskb_set_queue_mapping(skb, ieee80211_ac_from_tid(skb->priority));\n\n\t\n\tskb_pull(skb, len_rthdr);\n\n\tieee80211_xmit(sdata, NULL, skb);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\nfail_rcu:\n\trcu_read_unlock();\nfail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK; \n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset TSRMLS_DC)\n{\n\tsize_t retlen;\n\tchar *ret;\n\tenum entity_charset charset;\n\tconst entity_ht *inverse_map = NULL;\n\tsize_t new_size = TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen);\n\n\tif (all) {\n\t\tcharset = determine_charset(hint_charset TSRMLS_CC);\n\t} else {\n\t\tcharset = cs_8859_1; \n\t}\n\n\t\n\n\tif (oldlen > new_size) {\n\t\t\n\t\tret = estrndup((char*)old, oldlen);\n\t\tretlen = oldlen;\n\t\tgoto empty_source;\n\t}\n\tret = emalloc(new_size);\n\t*ret = '\\0';\n\tretlen = oldlen;\n\tif (retlen == 0) {\n\t\tgoto empty_source;\n\t}\n\n\tinverse_map = unescape_inverse_map(all, flags);\n\n\t\n\ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\n\nempty_source:\n\t*newlen = retlen;\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tstruct sockaddr_ipx *sipx = (struct sockaddr_ipx *)msg->msg_name;\n\tstruct ipxhdr *ipx = NULL;\n\tstruct sk_buff *skb;\n\tint copied, rc;\n\n\tlock_sock(sk);\n\t\n\tif (!ipxs->port) {\n\t\tstruct sockaddr_ipx uaddr;\n\n\t\tuaddr.sipx_port\t\t= 0;\n\t\tuaddr.sipx_network \t= 0;\n\n#ifdef CONFIG_IPX_INTERN\n\t\trc = -ENETDOWN;\n\t\tif (!ipxs->intrfc)\n\t\t\tgoto out; \n\t\tmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node, IPX_NODE_LEN);\n#endif\t\n\n\t\trc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\n\t\t\t      sizeof(struct sockaddr_ipx));\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb)\n\t\tgoto out;\n\n\tipx \t= ipx_hdr(skb);\n\tcopied \t= ntohs(ipx->ipx_pktsize) - sizeof(struct ipxhdr);\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\trc = skb_copy_datagram_iovec(skb, sizeof(struct ipxhdr), msg->msg_iov,\n\t\t\t\t     copied);\n\tif (rc)\n\t\tgoto out_free;\n\tif (skb->tstamp.tv64)\n\t\tsk->sk_stamp = skb->tstamp;\n\n\tif (sipx) {\n\t\tsipx->sipx_family\t= AF_IPX;\n\t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n\t\tmemcpy(sipx->sipx_node, ipx->ipx_source.node, IPX_NODE_LEN);\n\t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n\t\tsipx->sipx_type \t= ipx->ipx_type;\n\t\tsipx->sipx_zero\t\t= 0;\n\t\tmsg->msg_namelen\t= sizeof(*sipx);\n\t}\n\trc = copied;\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  const String& setSize(int64_t len) {\n    assertx(m_str);\n    m_str->setSize(len);\n    return *this;\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id)\n{\n\tGF_List *list = NULL, *alt_list = NULL;\n\tGF_NALUFFParam *sl;\n\tu32 i, count;\n\tu32 crc = gf_crc_32(data, size);\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tif (!ctx->vvc_dci) ctx->vvc_dci = gf_list_new();\n\t\t\tlist = ctx->vvc_dci;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t\tif (!ctx->vvc_aps_pre) ctx->vvc_aps_pre = gf_list_new();\n\t\t\tlist = ctx->vvc_aps_pre;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tswitch (ps_type) {\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\talt_list = ctx->pps_svc;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\tif (!ctx->sps_ext) ctx->sps_ext = gf_list_new();\n\t\t\tlist = ctx->sps_ext;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t}\n\tsl = NULL;\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tsl = gf_list_get(list, i);\n\t\tif (sl->id != ps_id) {\n\t\t\tsl = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t\tif (sl->crc == crc) return;\n\t\tbreak;\n\t}\n\tif (!sl && alt_list) {\n\t\tcount = gf_list_count(alt_list);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsl = gf_list_get(alt_list, i);\n\t\t\tif (sl->id != ps_id) {\n\t\t\t\tsl = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\t\tif (sl->crc == crc) return;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sl) {\n\t\t\tsl->data = gf_realloc(sl->data, size);\n\t\tmemcpy(sl->data, data, size);\n\t\tsl->size = size;\n\t\tsl->crc = crc;\n\t\tctx->ps_modified = GF_TRUE;\n\t\treturn;\n\t}\n\n\tGF_SAFEALLOC(sl, GF_NALUFFParam);\n\tif (!sl) return;\n\tsl->data = gf_malloc(sizeof(char) * size);\n\tif (!sl->data) {\n\t\tgf_free(sl);\n\t\treturn;\n\t}\n\tmemcpy(sl->data, data, size);\n\tsl->size = size;\n\tsl->id = ps_id;\n\tsl->crc = crc;\n\n\tctx->ps_modified = GF_TRUE;\n\tgf_list_add(list, sl);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\njas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2(%p, %zu)\\n\", buf, bufsize));\n\n\tassert((buf && bufsize > 0) || (!buf));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t\n\t\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t\n\tstream->ops_ = &jas_stream_memops;\n\n\t\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t\n\tif (!bufsize) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = JAS_CAST(unsigned char *, buf);\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2 buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\n\tif (bufsize > 0 && buf) {\n\t\t\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tint dir_has_key, cached_with_key;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\n\t\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (d_inode(dir)->i_crypt_info != NULL);\n\tdput(dir);\n\n\t\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteTensor* GetTempRhs(TfLiteContext* context, TfLiteNode* node,\n                         const TfLiteTensor* rhs) {\n  TfLiteTensor* transposed_rhs = GetTemporary(context, node, 1);\n  if (transposed_rhs == nullptr) {\n    return nullptr;\n  }\n\n  if (rhs->type == kTfLiteInt8) {\n       transposed_rhs->params.scale = rhs->params.scale;\n    transposed_rhs->params.zero_point = rhs->params.zero_point;\n  }\n  return transposed_rhs;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int __init ipip_init(void)\n{\n\tint err;\n\n\tprintk(banner);\n\n\tif (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err)\n\t\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\n\n\treturn err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic BOOL ntlm_av_pair_get_next_offset(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pOffset)\n{\n\tsize_t avLen;\n\tif (!pOffset)\n\t\treturn FALSE;\n\n\tif (!ntlm_av_pair_get_len(pAvPair, size, &avLen))\n\t\treturn FALSE;\n\t*pOffset = avLen + sizeof(NTLM_AV_PAIR);\n\treturn TRUE;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid CIRCNetwork::SetEncoding(const CString& s) {\n    m_sEncoding = s;\n    if (GetIRCSock()) {\n        GetIRCSock()->SetEncoding(s);\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int check_owned_directory_mode(const char *path, mode_t expected_mode)\n{\n\tstruct stat stat;\n\tif (lstat(path, &stat))\n\t\treturn -1;\n\n\tif (!S_ISDIR(stat.st_mode))\n\t\treturn -1;\n\n\tif (stat.st_uid != getuid())\n\t\treturn -1;\n\n\tif ((stat.st_mode & 07777) != expected_mode)\n\t\treturn -1;\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint main(int argc, char * argv[])\n{\n    gr_face * face = 0;\n    try\n\t{\n\t\tif (argc != 2)\tthrow std::length_error(\"not enough arguments: need a backing font\");\n\n\t\tdummyFace = face_handle(argv[1]);\n\t\ttestFeatTable<FeatTableTestA>(testDataA, \"A\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataB, \"B\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataBunsorted, \"Bu\\n\");\n\t\ttestFeatTable<FeatTableTestC>(testDataCunsorted, \"C\\n\");\n\t\ttestFeatTable<FeatTableTestD>(testDataDunsorted, \"D\\n\");\n\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\n\t\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n\t\tbool readStatus = testFeatureMap.readFeats(*face);\n\t\ttestAssert(\"fail gracefully on bad table\", !readStatus);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);\n\t\treturn 1;\n\t}\n\n    gr_face_destroy(face);\n    return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n__perf_event_ctx_lock_double(struct perf_event *group_leader,\n\t\t\t     struct perf_event_context *ctx)\n{\n\tstruct perf_event_context *gctx;\n\nagain:\n\trcu_read_lock();\n\tgctx = READ_ONCE(group_leader->ctx);\n\tif (!atomic_inc_not_zero(&gctx->refcount)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\tmutex_lock_double(&gctx->mutex, &ctx->mutex);\n\n\tif (group_leader->ctx != gctx) {\n\t\tmutex_unlock(&ctx->mutex);\n\t\tmutex_unlock(&gctx->mutex);\n\t\tput_ctx(gctx);\n\t\tgoto again;\n\t}\n\n\treturn gctx;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  RectangleRequest &operator=(const struct RectangleRequest &req)\n  { \n       memcpy(this,&req,sizeof(struct RectangleRequest));\n       rr_pNext = NULL;\n       return *this;\n  }\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING] = \"\";\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n\n  if (!nserv || !line)\n    return 0;\n\n  \n  if (sscanf(line, \"%1023s \" ANUM \" \" ANUM \" %c %8191[^\\n]\", group, &last, &first, &mod, desc) < 4)\n  {\n    mutt_debug(4, \"Cannot parse server line: %s\\n\", line);\n    return 0;\n  }\n\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n{\n\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n\tstruct tipc_aead_key *skey = NULL;\n\tu16 key_gen = msg_key_gen(hdr);\n\tu16 size = msg_data_sz(hdr);\n\tu8 *data = msg_data(hdr);\n\n\tspin_lock(&rx->lock);\n\tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n\t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n\t\t       rx->skey, key_gen, rx->key_gen);\n\t\tgoto exit;\n\t}\n\n\t\n\tskey = kmalloc(size, GFP_ATOMIC);\n\tif (unlikely(!skey)) {\n\t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\n\t\n\tskey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n\tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n\t       skey->keylen);\n\n\t\n\tif (unlikely(size != tipc_aead_key_size(skey))) {\n\t\tkfree(skey);\n\t\tskey = NULL;\n\t\tgoto exit;\n\t}\n\n\trx->key_gen = key_gen;\n\trx->skey_mode = msg_key_mode(hdr);\n\trx->skey = skey;\n\trx->nokey = 0;\n\tmb(); \n\nexit:\n\tspin_unlock(&rx->lock);\n\n\t\n\tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n\t\treturn true;\n\n\treturn false;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nget_user_commands(expand_T *xp UNUSED, int idx)\n{\n       buf_T *buf = prevwin_curwin()->w_buffer;\n\n    if (idx < buf->b_ucmds.ga_len)\n\treturn USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    idx -= buf->b_ucmds.ga_len;\n    if (idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    return NULL;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nprocess_secondary_order(STREAM s)\n{\n\t\n\tuint16 length;\n\tuint16 flags;\n\tuint8 type;\n\tuint8 *next_order;\n\tstruct stream packet = *s;\n\n\tin_uint16_le(s, length);\n\tin_uint16_le(s, flags);\t\n\tin_uint8(s, type);\n\n\tif (!s_check_rem(s, length + 7))\n\t{\n\t\trdp_protocol_error(\"process_secondary_order(), next order pointer would overrun stream\", &packet);\n\t}\n\n\tnext_order = s->p + (sint16) length + 7;\n\n\tswitch (type)\n\t{\n\t\tcase RDP_ORDER_RAW_BMPCACHE:\n\t\t\tprocess_raw_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_COLCACHE:\n\t\t\tprocess_colcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE:\n\t\t\tprocess_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_FONTCACHE:\n\t\t\tprocess_fontcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_RAW_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, False);\t\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, True);\t\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BRUSHCACHE:\n\t\t\tprocess_brushcache(s, flags);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_secondary_order(), unhandled secondary order %d\", type);\n\t}\n\n\ts->p = next_order;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n\n    if (!frame)\n        return NULL;\n\n    frame->width  = w;\n    frame->height = h;\n\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int hsub = s->draw.hsub[plane];\n        int vsub = s->draw.vsub[plane];\n        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n\n    return frame;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int cdxl_decode_frame(AVCodecContext *avctx, void *data,\n                             int *got_frame, AVPacket *pkt)\n{\n    CDXLVideoContext *c = avctx->priv_data;\n    AVFrame * const p = data;\n    int ret, w, h, encoding, aligned_width, buf_size = pkt->size;\n    const uint8_t *buf = pkt->data;\n\n    if (buf_size < 32)\n        return AVERROR_INVALIDDATA;\n    encoding        = buf[1] & 7;\n    c->format       = buf[1] & 0xE0;\n    w               = AV_RB16(&buf[14]);\n    h               = AV_RB16(&buf[16]);\n    c->bpp          = buf[19];\n    c->palette_size = AV_RB16(&buf[20]);\n    c->palette      = buf + 32;\n    c->video        = c->palette + c->palette_size;\n    c->video_size   = buf_size - c->palette_size - 32;\n\n    if (c->palette_size > 512)\n        return AVERROR_INVALIDDATA;\n    if (buf_size < c->palette_size + 32)\n        return AVERROR_INVALIDDATA;\n    if (c->bpp < 1)\n        return AVERROR_INVALIDDATA;\n    if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) {\n        avpriv_request_sample(avctx, \"Pixel format 0x%0x\", c->format);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n        return ret;\n\n    if (c->format == CHUNKY)\n        aligned_width = avctx->width;\n    else\n        aligned_width = FFALIGN(c->avctx->width, 16);\n    c->padded_bits  = aligned_width - c->avctx->width;\n    if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8)\n        return AVERROR_INVALIDDATA;\n    if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) {\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {\n        if (c->palette_size != (1 << (c->bpp - 1)))\n            return AVERROR_INVALIDDATA;\n        avctx->pix_fmt = AV_PIX_FMT_BGR24;\n    } else if (!encoding && c->bpp == 24 && c->format == CHUNKY &&\n               !c->palette_size) {\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n    } else {\n        avpriv_request_sample(avctx, \"Encoding %d, bpp %d and format 0x%x\",\n                              encoding, c->bpp, c->format);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    if (encoding) {\n        av_fast_padded_malloc(&c->new_video, &c->new_video_size,\n                              h * w + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!c->new_video)\n            return AVERROR(ENOMEM);\n        if (c->bpp == 8)\n            cdxl_decode_ham8(c, p);\n        else\n            cdxl_decode_ham6(c, p);\n    } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n        cdxl_decode_rgb(c, p);\n    } else {\n        cdxl_decode_raw(c, p);\n    }\n    *got_frame = 1;\n\n    return buf_size;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS(s);\n\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && (*s != '\\\"') && (ptmp != (tmp + sizeof(tmp) - 1)))\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; \n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS(s);\n      ptmp = tmp;\n      while (isdigit((unsigned char) *s) && (ptmp != (tmp + sizeof(tmp) - 1)))\n        *ptmp++ = *s++;\n      *ptmp = '\\0';\n      if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      \n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      \n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n\n  return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nMonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\n\tklass = method->klass;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\n\t\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\t\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\n\tif (!mono_verifier_is_method_valid_generic_instantiation (inflated))\n\t\tmono_raise_exception (mono_get_exception_argument (\"typeArguments\", \"Invalid generic arguments\"));\n\t\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nfile_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs[i]; i++)\n    {\n\tMAPI_Attr* a = attrs[i];\n\n\tif (a->num_values)\n\t{\n\n\t    switch (a->name)\n\t    {\n\t    case MAPI_ATTACH_LONG_FILENAME:\n\t\tassert(a->type == szMAPI_STRING);\n\t\tif (file->name) XFREE(file->name);\n\t\tfile->name = strdup( (char*)a->values[0].data.buf );\n\t\tbreak;\n\n\t    case MAPI_ATTACH_DATA_OBJ:\n\t\tassert((a->type == szMAPI_BINARY) || (a->type == szMAPI_OBJECT));\n\t\tfile->len = a->values[0].len;\n\t\tif (file->data) XFREE (file->data);\n\t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n\t\tmemmove (file->data, a->values[0].data.buf, file->len);\n\t\tbreak;\n\n             case MAPI_ATTACH_MIME_TAG:\n\t\tassert(a->type == szMAPI_STRING);\n\t\tif (file->mime_type) XFREE (file->mime_type);\n\t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n\t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n\t\tbreak;\n\n                case MAPI_ATTACH_CONTENT_ID:\n                    assert(a->type == szMAPI_STRING);\n                    if (file->content_id) XFREE(file->content_id);\n                    file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n                    memmove (file->content_id, a->values[0].data.buf, a->values[0].len);\n                    break;\n\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nparse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    int *err, gchar **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n\tchar\tline[TOSHIBA_LINE_LENGTH];\n\tint\tnum_items_scanned;\n\tguint\tpkt_len;\n\tint\tpktnum, hr, min, sec, csec;\n\tchar\tchannel[10], direction[10];\n\tint\ti, hex_lines;\n\tguint8\t*pd;\n\n\t\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\n\n\tif (num_items_scanned != 7) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\n\t\treturn FALSE;\n\t}\n\n\t\n\tdo {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t\n\t\tline[16] = '\\0';\n\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n\tif (num_items_scanned != 1) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n\t\treturn FALSE;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n\t\t\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\tphdr->ts.secs = hr * 3600 + min * 60 + sec;\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->caplen = pkt_len;\n\tphdr->len = pkt_len;\n\n\tswitch (channel[0]) {\n\t\tcase 'B':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = (guint8)\n\t\t\t    strtol(&channel[1], NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\n\t\t\t\t\tstruct vsock_sock *vsk,\n\t\t\t\t\tstruct msghdr *msg, size_t len,\n\t\t\t\t\tint flags)\n{\n\tint err;\n\tint noblock;\n\tstruct vmci_datagram *dg;\n\tsize_t payload_len;\n\tstruct sk_buff *skb;\n\n\tnoblock = flags & MSG_DONTWAIT;\n\n\tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg->msg_namelen = 0;\n\n\t\n\terr = 0;\n\tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\n\tif (err)\n\t\treturn err;\n\n\tif (!skb)\n\t\treturn -EAGAIN;\n\n\tdg = (struct vmci_datagram *)skb->data;\n\tif (!dg)\n\t\t\n\t\tgoto out;\n\n\tpayload_len = dg->payload_size;\n\t\n\tif (payload_len != skb->len - sizeof(*dg)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (payload_len > len) {\n\t\tpayload_len = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t\n\terr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\n\t\tpayload_len);\n\tif (err)\n\t\tgoto out;\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_vm *vm_addr;\n\n\t\t\n\t\tvm_addr = (struct sockaddr_vm *)msg->msg_name;\n\t\tvsock_addr_init(vm_addr, dg->src.context, dg->src.resource);\n\t\tmsg->msg_namelen = sizeof(*vm_addr);\n\t}\n\terr = payload_len;\n\nout:\n\tskb_free_datagram(&vsk->sk, skb);\n\treturn err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n\tModResult OnUserPreTagMessage(User* user, const MessageTarget& target, CTCTags::TagMessageDetails& details) CXX11_OVERRIDE\n\t{\n\t\tif (target.type == MessageTarget::TYPE_CHANNEL)\n\t\t\treturn BuildChannelExempts(user, target.Get<Channel>(), SilenceEntry::SF_TAGMSG_CHANNEL, details.exemptions);\n\n\t\tif (target.type == MessageTarget::TYPE_USER && !CanReceiveMessage(user, target.Get<User>(), SilenceEntry::SF_TAGMSG_USER))\n\t\t{\n\t\t\tdetails.echo_original = true;\n\t\t\treturn MOD_RES_DENY;\n\t\t}\n\n\t\treturn MOD_RES_PASSTHRU;\n\t}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint bmp_validate(jas_stream_t *in)\n{\n\tint n;\n\tint i;\n\tuchar buf[2];\n\n\tassert(JAS_STREAM_MAXPUTBACK >= 2);\n\n\t\n\tif ((n = jas_stream_read(in, (char *) buf, 2)) < 0) {\n\t\treturn -1;\n\t}\n\t\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tif (n < 2) {\n\t\treturn -1;\n\t}\n\t\n\tif (buf[0] == (BMP_MAGIC & 0xff) && buf[1] == (BMP_MAGIC >> 8)) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline int crypto_rng_generate(struct crypto_rng *tfm,\n\t\t\t\t      const u8 *src, unsigned int slen,\n\t\t\t\t      u8 *dst, unsigned int dlen)\n{\n\treturn tfm->generate(tfm, src, slen, dst, dlen);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nR_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaClassesAttribute *icattr;\n\tRBinJavaAttrInfo *attr = NULL;\n\tRBinJavaCPTypeObj *obj;\n\tut32 i = 0;\n\tut64 offset = 0, curpos;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (buf_offset + offset + 8 > sz) {\n\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\treturn NULL;\n\t}\n\tif (attr == NULL) {\n\t\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n\tattr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n\tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (buf_offset + offset + 8 > sz) {\n\t\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ticattr = R_NEW0 (RBinJavaClassesAttribute);\n\t\tif (!icattr) {\n\t\t\tbreak;\n\t\t}\n\t\ticattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags);\n\t\ticattr->file_offset = curpos;\n\t\ticattr->size = 8;\n\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx);\n\t\tif (!obj) {\n\t\t\teprintf (\"BINCPLIS IS HULL %d\\n\", icattr->inner_name_idx);\n\t\t}\n\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\tif (!icattr->name) {\n\t\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx);\n\t\t\tif (!obj) {\n\t\t\t\teprintf (\"BINCPLIST IS NULL %d\\n\", icattr->inner_class_info_idx);\n\t\t\t}\n\t\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\t\tif (!icattr->name) {\n\t\t\t\ticattr->name = r_str_dup (NULL, \"NULL\");\n\t\t\t\teprintf (\"r_bin_java_inner_classes_attr: Unable to find the name for %d index.\\n\", icattr->inner_name_idx);\n\t\t\t\tfree (icattr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tIFDBG eprintf (\"r_bin_java_inner_classes_attr: Inner class name %d is %s.\\n\", icattr->inner_name_idx, icattr->name);\n\t\tr_list_append (attr->info.inner_classes_attr.classes, (void *) icattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nget_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n\t\t\t\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\t\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nSPL_METHOD(SplFileInfo, getLinkTarget)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint ret;\n\tchar buff[MAXPATHLEN];\n\tzend_error_handling error_handling;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n#if defined(PHP_WIN32) || HAVE_SYMLINK\n\tif (intern->file_name == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty filename\");\n\t\tRETURN_FALSE;\n\t} else if (!IS_ABSOLUTE_PATH(intern->file_name, intern->file_name_len)) {\n\t\tchar expanded_path[MAXPATHLEN];\n\t\tif (!expand_filepath_with_mode(intern->file_name, expanded_path, NULL, 0, CWD_EXPAND  TSRMLS_CC)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No such file or directory\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tret = php_sys_readlink(expanded_path, buff, MAXPATHLEN - 1);\n\t} else {\n\t\tret = php_sys_readlink(intern->file_name, buff,  MAXPATHLEN-1);\n\t}\n#else\n\tret = -1; \n#endif\n\n\tif (ret == -1) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Unable to read link %s, error: %s\", intern->file_name, strerror(errno));\n\t\tRETVAL_FALSE;\n\t} else {\n\t\t\n\t\tbuff[ret] = '\\0';\n\n\t\tRETVAL_STRINGL(buff, ret, 1);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tsctp_event_timeout_t timeout_type)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint error = 0;\n\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\n\t\t\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\t\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\t\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nf_histadd(typval_T *argvars UNUSED, typval_T *rettv)\n{\n#ifdef FEAT_CMDHIST\n    int\t\thistype;\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n#endif\n\n    rettv->vval.v_number = FALSE;\n    if (check_restricted() || check_secure())\n\treturn;\n#ifdef FEAT_CMDHIST\n    str = tv_get_string_chk(&argvars[0]);\t\n    histype = str != NULL ? get_histtype(str) : -1;\n    if (histype >= 0)\n    {\n\tstr = tv_get_string_buf(&argvars[1], buf);\n\tif (*str != NUL)\n\t{\n\t    init_history();\n\t    add_to_history(histype, str, FALSE, NUL);\n\t    rettv->vval.v_number = TRUE;\n\t    return;\n\t}\n    }\n#endif\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "OS Command Injection"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid Context::onDelete() {\n  if (in_vm_context_created_ && wasm_->onDelete_) {\n    wasm_->onDelete_(this, id_);\n  }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\t\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nlabel (const uint8_t * src, size_t srclen, uint8_t * dst, size_t * dstlen,\n       int flags)\n{\n  size_t plen;\n  uint32_t *p;\n  int rc;\n  size_t tmpl;\n\n  if (_idn2_ascii_p (src, srclen))\n    {\n      if (flags & IDN2_ALABEL_ROUNDTRIP)\n\t\n\treturn IDN2_INVALID_FLAGS;\n\n      if (srclen > IDN2_LABEL_MAX_LENGTH)\n\treturn IDN2_TOO_BIG_LABEL;\n      if (srclen > *dstlen)\n\treturn IDN2_TOO_BIG_DOMAIN;\n\n      memcpy (dst, src, srclen);\n      *dstlen = srclen;\n      return IDN2_OK;\n    }\n\n  rc = _idn2_u8_to_u32_nfc (src, srclen, &p, &plen, flags & IDN2_NFC_INPUT);\n  if (rc != IDN2_OK)\n    return rc;\n\n  if (!(flags & IDN2_TRANSITIONAL))\n    {\n      rc = _idn2_label_test(\n\tTEST_NFC |\n\tTEST_2HYPHEN |\n\tTEST_LEADING_COMBINING |\n\tTEST_DISALLOWED |\n\tTEST_CONTEXTJ_RULE |\n\tTEST_CONTEXTO_WITH_RULE |\n\tTEST_UNASSIGNED | TEST_BIDI |\n\t((flags & IDN2_NONTRANSITIONAL) ? TEST_NONTRANSITIONAL : 0) |\n\t((flags & IDN2_USE_STD3_ASCII_RULES) ? 0 : TEST_ALLOW_STD3_DISALLOWED),\n\tp, plen);\n\n      if (rc != IDN2_OK)\n\t{\n\t  free(p);\n\t  return rc;\n\t}\n    }\n\n  dst[0] = 'x';\n  dst[1] = 'n';\n  dst[2] = '-';\n  dst[3] = '-';\n\n  tmpl = *dstlen - 4;\n  rc = _idn2_punycode_encode (plen, p, &tmpl, (char *) dst + 4);\n  free (p);\n  if (rc != IDN2_OK)\n    return rc;\n\n  *dstlen = 4 + tmpl;\n\n  return IDN2_OK;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nCAMLprim value caml_alloc_dummy_float (value size)\n{\n  mlsize_t wosize = Long_val(size) * Double_wosize;\n\n  if (wosize == 0) return Atom(0);\n  return caml_alloc (wosize, 0);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nheader_put_le_short (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n} \n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART) {\n        data->num_of_part++;\n    }\n\n    return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsixel_allocator_malloc(\n    sixel_allocator_t    *allocator,  \n    size_t               n)           \n{\n    \n    assert(allocator);\n    assert(allocator->fn_malloc);\n\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_malloc: called with n == 0\");\n        return NULL;\n    }\n\n    if (n > SIXEL_ALLOCATE_BYTES_MAX) {\n        return NULL;\n    }\n\n    return allocator->fn_malloc(n);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)\n{\n\tstruct platform_device *pdev = cqspi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct cqspi_flash_pdata *f_pdata;\n\tstruct spi_nor *nor;\n\tstruct mtd_info *mtd;\n\tunsigned int cs;\n\tint i, ret;\n\n\t\n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tif (of_property_read_u32(np, \"reg\", &cs)) {\n\t\t\tdev_err(dev, \"Couldn't determine chip select.\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (cs >= CQSPI_MAX_CHIPSELECT) {\n\t\t\tdev_err(dev, \"Chip select %d out of range.\\n\", cs);\n\t\t\tgoto err;\n\t\t}\n\n\t\tf_pdata = &cqspi->f_pdata[cs];\n\t\tf_pdata->cqspi = cqspi;\n\t\tf_pdata->cs = cs;\n\n\t\tret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tnor = &f_pdata->nor;\n\t\tmtd = &nor->mtd;\n\n\t\tmtd->priv = nor;\n\n\t\tnor->dev = dev;\n\t\tspi_nor_set_flash_node(nor, np);\n\t\tnor->priv = f_pdata;\n\n\t\tnor->read_reg = cqspi_read_reg;\n\t\tnor->write_reg = cqspi_write_reg;\n\t\tnor->read = cqspi_read;\n\t\tnor->write = cqspi_write;\n\t\tnor->erase = cqspi_erase;\n\t\tnor->prepare = cqspi_prep;\n\t\tnor->unprepare = cqspi_unprep;\n\n\t\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\",\n\t\t\t\t\t   dev_name(dev), cs);\n\t\tif (!mtd->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = mtd_device_register(mtd, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tf_pdata->registered = true;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\n\t\tif (cqspi->f_pdata[i].registered)\n\t\t\tmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n        int          GetS32BE (int nPos, bool *pbSuccess)\n        {\n           \n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            if ( nRes & 0x80000000 )\n                nRes |= ~0xffffffff;\n\n            return nRes;\n        }\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid Server::handleCommand_InventoryAction(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tstd::string datastring(pkt->getString(0), pkt->getSize());\n\tverbosestream << \"TOSERVER_INVENTORY_ACTION: data=\" << datastring\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\tInventoryAction *a = InventoryAction::deSerialize(is);\n\tif (!a) {\n\t\tinfostream << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t\n\n\t\n\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player = false;\n\t\tif (ma->from_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->from_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tfrom_inv_is_current_player = true;\n\t\t}\n\t\t\n\t\tbool to_inv_is_current_player = false;\n\t\tif (ma->to_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->to_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tto_inv_is_current_player = true;\n\t\t}\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t\n\t\tif (ma->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because src is \" << ma->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t\n\t\tif (ma->to_list == \"craftpreview\" || ma->to_list == \"craftresult\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because dst is \" << ma->to_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t\t\tif (!checkPriv(player->getName(), \"interact\") &&\n\t\t\t\t(!from_inv_is_current_player ||\n\t\t\t\t!to_inv_is_current_player)) {\n\t\t\tinfostream << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\telse if (a->getType() == IAction::Drop) {\n\t\tIDropAction *da = (IDropAction*)a;\n\n\t\tda->from_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(da->from_inv);\n\n\t\t\n\t\tif (da->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because src is \" << da->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t\tif (playersao->isDead()) {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\telse if (a->getType() == IAction::Craft) {\n\t\tICraftAction *ca = (ICraftAction*)a;\n\n\t\tca->craft_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ca->craft_inv);\n\n\t\t\t\n\t\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tinfostream << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\n\ta->apply(m_inventory_mgr.get(), playersao, this);\n\tdelete a;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int bson_validate_string( bson *b, const unsigned char *string,\n                                 const size_t length, const char check_utf8, const char check_dot,\n                                 const char check_dollar ) {\n\n    size_t position = 0;\n    int sequence_length = 1;\n\n    if( check_dollar && string[0] == '$' ) {\n        if( !bson_string_is_db_ref( string, length ) )\n            b->err |= BSON_FIELD_INIT_DOLLAR;\n    }\n\n    while ( position < length ) {\n        if ( check_dot && *( string + position ) == '.' ) {\n            b->err |= BSON_FIELD_HAS_DOT;\n        }\n\n        if ( check_utf8 ) {\n            sequence_length = trailingBytesForUTF8[*( string + position )] + 1;\n            if ( ( position + sequence_length ) > length ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n            if ( !isLegalUTF8( string + position, sequence_length ) ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n        }\n        position += sequence_length;\n    }\n\n    return BSON_OK;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nerror_t ksz9131Init(NetInterface *interface)\n{\n     TRACE_INFO(\"Initializing KSZ9131...\\r\\n\");\n\n     if(interface->phyAddr >= 32)\n   {\n           interface->phyAddr = KSZ9131_PHY_ADDR;\n   }\n\n     if(interface->smiDriver != NULL)\n   {\n      interface->smiDriver->init();\n   }\n\n     if(interface->extIntDriver != NULL)\n   {\n      interface->extIntDriver->init();\n   }\n\n     ksz9131WritePhyReg(interface, KSZ9131_BMCR, KSZ9131_BMCR_RESET);\n\n     while(ksz9131ReadPhyReg(interface, KSZ9131_BMCR) & KSZ9131_BMCR_RESET)\n   {\n   }\n\n     ksz9131DumpPhyReg(interface);\n\n     ksz9131WritePhyReg(interface, KSZ9131_ICSR, KSZ9131_ICSR_LINK_DOWN_IE |\n      KSZ9131_ICSR_LINK_UP_IE);\n\n     interface->phyEvent = TRUE;\n     osSetEvent(&netEvent);\n\n     return NO_ERROR;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,\n\tnetdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct ipv6hdr *ipv6h;\n\tconst struct net_offload *ops;\n\tint proto;\n\tstruct frag_hdr *fptr;\n\tunsigned int unfrag_ip6hlen;\n\tunsigned int payload_len;\n\tu8 *prevhdr;\n\tint offset = 0;\n\tbool encap, udpfrag;\n\tint nhoff;\n\tbool gso_partial;\n\n\tskb_reset_network_header(skb);\n\tnhoff = skb_network_header(skb) - skb_mac_header(skb);\n\tif (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))\n\t\tgoto out;\n\n\tencap = SKB_GSO_CB(skb)->encap_level > 0;\n\tif (encap)\n\t\tfeatures &= skb->dev->hw_enc_features;\n\tSKB_GSO_CB(skb)->encap_level += sizeof(*ipv6h);\n\n\tipv6h = ipv6_hdr(skb);\n\t__skb_pull(skb, sizeof(*ipv6h));\n\tsegs = ERR_PTR(-EPROTONOSUPPORT);\n\n\tproto = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);\n\n\tif (skb->encapsulation &&\n\t    skb_shinfo(skb)->gso_type & (SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6))\n\t\tudpfrag = proto == IPPROTO_UDP && encap;\n\telse\n\t\tudpfrag = proto == IPPROTO_UDP && !skb->encapsulation;\n\n\tops = rcu_dereference(inet6_offloads[proto]);\n\tif (likely(ops && ops->callbacks.gso_segment)) {\n\t\tskb_reset_transport_header(skb);\n\t\tsegs = ops->callbacks.gso_segment(skb, features);\n\t}\n\n\tif (IS_ERR_OR_NULL(segs))\n\t\tgoto out;\n\n\tgso_partial = !!(skb_shinfo(segs)->gso_type & SKB_GSO_PARTIAL);\n\n\tfor (skb = segs; skb; skb = skb->next) {\n\t\tipv6h = (struct ipv6hdr *)(skb_mac_header(skb) + nhoff);\n\t\tif (gso_partial)\n\t\t\tpayload_len = skb_shinfo(skb)->gso_size +\n\t\t\t\t      SKB_GSO_CB(skb)->data_offset +\n\t\t\t\t      skb->head - (unsigned char *)(ipv6h + 1);\n\t\telse\n\t\t\tpayload_len = skb->len - nhoff - sizeof(*ipv6h);\n\t\tipv6h->payload_len = htons(payload_len);\n\t\tskb->network_header = (u8 *)ipv6h - skb->head;\n\n\t\tif (udpfrag) {\n\t\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\t\tif (unfrag_ip6hlen < 0)\n\t\t\t\treturn ERR_PTR(unfrag_ip6hlen);\n\t\t\tfptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);\n\t\t\tfptr->frag_off = htons(offset);\n\t\t\tif (skb->next)\n\t\t\t\tfptr->frag_off |= htons(IP6_MF);\n\t\t\toffset += (ntohs(ipv6h->payload_len) -\n\t\t\t\t   sizeof(struct frag_hdr));\n\t\t}\n\t\tif (encap)\n\t\t\tskb_reset_inner_headers(skb);\n\t}\n\nout:\n\treturn segs;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq)\n{\n\tunsigned row;\n\tunsigned col;\n\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\n\trow = EVTCHN_ROW(evtchn);\n\tcol = EVTCHN_COL(evtchn);\n\n\tif (evtchn_to_irq[row] == NULL) {\n\t\t\n\t\tif (irq == -1)\n\t\t\treturn 0;\n\n\t\tevtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n\n\tWRITE_ONCE(evtchn_to_irq[row][col], irq);\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ninline int64_t StringData::size() const { return m_len; }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nMONGO_EXPORT int bson_append_regex( bson *b, const char *name, const char *pattern, const char *opts ) {\n    const size_t plen = strlen( pattern )+1;\n    const size_t olen = strlen( opts )+1;\n    if ( bson_append_estart( b, BSON_REGEX, name, plen + olen ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_check_string( b, pattern, plen - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append( b , pattern , plen );\n    bson_append( b , opts , olen );\n    return BSON_OK;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tint bytes = 0, dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tSQUASHFS_INSWAP_DIR_HEADER(&dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tres = read_directory_data(dire, &start, &offset, sizeof(*dire));\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tSQUASHFS_INSWAP_DIR_ENTRY(dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast2obj_comprehension(void* _o)\n{\n    comprehension_ty o = (comprehension_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(comprehension_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_expr(o->target);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_expr(o->iter);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_iter, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_list(o->ifs, ast2obj_expr);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_ifs, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_int(o->is_async);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_is_async, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n}\n\nvoid print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)\n{\n\tu32 i, count;\n\n\tcount =  gf_isom_get_udta_count(file, track_number);\n\tif (!count) return;\n\n\tif (has_itags) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 type;\n\t\t\tbin128 uuid;\n\t\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\t\tif (type == GF_ISOM_BOX_TYPE_META) {\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!count) return;\n\t}\n\n\tfprintf(stderr, \"%d UDTA types: \", count);\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (udta_size && gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tu32 idx;\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t\");\n\t\t\t\tfor (idx=0; idx<udta_size; idx++) {\n\t\t\t\t\tif (!udta[idx]) break;\n\t\t\t\t\tfprintf(stderr, \"%c\", udta[idx]);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void cjson_get_object_item_case_sensitive_should_not_crash_with_array(void) {\n    cJSON *array = NULL;\n    cJSON *found = NULL;\n    array = cJSON_Parse(\"[1]\");\n\n    found = cJSON_GetObjectItemCaseSensitive(array, \"name\");\n    TEST_ASSERT_NULL(found);\n\n    cJSON_Delete(array);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  type = get4();  get4();  get4();\n  wide = get4();\n  high = get4();\n  if (type == 2) {\n    fread (meta_data, 1, meta_length, ifp);\n    for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  } else if (type == 4) {\n    free (meta_data);\n    meta_data = (char *) malloc (meta_length = wide*high*3/2);\n    merror (meta_data, \"foveon_load_camf()\");\n    foveon_huff (huff);\n    get4();\n    getbits(-1);\n    for (j=row=0; row < high; row++) {\n      for (col=0; col < wide; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse         hpred[col & 1] += diff;\n\tif (col & 1) {\n\t  meta_data[j++] = hpred[0] >> 4;\n\t  meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;\n\t  meta_data[j++] = hpred[1];\n        }\n      }\n    }\n  } else\n    fprintf (stderr,_(\"%s has unknown CAMF type %d.\\n\"), ifname, type);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int xar_get_toc_data_values(xmlTextReaderPtr reader, size_t *length, size_t *offset, size_t *size, int *encoding,\n                                   unsigned char ** a_cksum, int * a_hash, unsigned char ** e_cksum, int * e_hash)\n{\n    const xmlChar *name;\n    int indata = 0, inea = 0;\n    int rc, gotoffset=0, gotlength=0, gotsize=0;\n\n    *a_cksum = NULL;\n    *a_hash = XAR_CKSUM_NONE;\n    *e_cksum = NULL;\n    *e_hash = XAR_CKSUM_NONE;\n    *encoding = CL_TYPE_ANY;\n\n    rc = xmlTextReaderRead(reader);\n    while (rc == 1) {\n        name = xmlTextReaderConstLocalName(reader);\n        if (indata || inea) {\n            \n            if (xmlStrEqual(name, (const xmlChar *)\"offset\") && \n                xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, offset))\n                    gotoffset=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"length\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, length))\n                    gotlength=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"size\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, size))\n                    gotsize=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"archived-checksum\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                cli_dbgmsg(\"cli_scanxar: <archived-checksum>:\\n\");\n                xar_get_checksum_values(reader, a_cksum, a_hash);\n                \n            } else if ((xmlStrEqual(name, (const xmlChar *)\"extracted-checksum\") ||\n                        xmlStrEqual(name, (const xmlChar *)\"unarchived-checksum\")) &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                cli_dbgmsg(\"cli_scanxar: <extracted-checksum>:\\n\");\n                xar_get_checksum_values(reader, e_cksum, e_hash);\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"encoding\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)\"style\");\n                if (style == NULL) {\n                    cli_dbgmsg(\"cli_scaxar: xmlTextReaderGetAttribute no style attribute \"\n                               \"for encoding element\\n\");\n                    *encoding = CL_TYPE_ANY;\n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-gzip\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-gzip.\\n\");\n                    *encoding = CL_TYPE_GZ; \n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/octet-stream\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/octet-stream.\\n\");\n                    *encoding = CL_TYPE_ANY; \n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-bzip2\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-bzip2.\\n\");\n                    *encoding = CL_TYPE_BZ;\n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-lzma\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-lzma.\\n\");\n                    *encoding = CL_TYPE_7Z;\n                 } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-xz\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-xz.\\n\");\n                    *encoding = CL_TYPE_XZ;\n                } else {\n                    cli_dbgmsg(\"cli_scaxar: unknown style value=%s for encoding element\\n\", style);\n                    *encoding = CL_TYPE_ANY;\n                }\n                if (style != NULL)\n                    xmlFree(style);\n\n           } else if (indata && xmlStrEqual(name, (const xmlChar *)\"data\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {\n                break;\n\n            } else if (inea && xmlStrEqual(name, (const xmlChar *)\"ea\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {\n                break;\n            }\n            \n        } else {\n            if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (xmlStrEqual(name, (const xmlChar *)\"data\")) {\n                    cli_dbgmsg(\"cli_scanxar: xmlTextReaderRead read <data>\\n\");\n                    indata = 1;\n                } else if (xmlStrEqual(name, (const xmlChar *)\"ea\")) {\n                    cli_dbgmsg(\"cli_scanxar: xmlTextReaderRead read <ea>\\n\");\n                    inea = 1;\n                }\n            } else if ((xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) &&\n                       xmlStrEqual(name, (const xmlChar *)\"xar\")) {\n                cli_dbgmsg(\"cli_scanxar: finished parsing xar TOC.\\n\");   \n                break;\n            }\n        }\n        rc = xmlTextReaderRead(reader);\n    }\n    \n    if (gotoffset && gotlength && gotsize) {\n        rc = CL_SUCCESS;\n    }\n    else if (0 == gotoffset + gotlength + gotsize)\n        rc = CL_BREAK;\n    else\n        rc = CL_EFORMAT;\n\n    return rc;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nerror_t xmc4400EthInit(NetInterface *interface)\n{\n   error_t error;\n\n     TRACE_INFO(\"Initializing XMC4400 Ethernet MAC...\\r\\n\");\n\n     nicDriverInterface = interface;\n\n     SCU_PARITY->PETE = 0;\n     PPB->CCR &= ~PPB_CCR_UNALIGN_TRP_Msk;\n\n     SCU_CLK->CLKSET = SCU_CLK_CLKSET_ETH0CEN_Msk;\n\n     xmc4400EthInitGpio(interface);\n\n     SCU_RESET->PRSET2 = SCU_RESET_PRSET2_ETH0RS_Msk;\n   SCU_RESET->PRCLR2 = SCU_RESET_PRCLR2_ETH0RS_Msk;\n\n     ETH0->BUS_MODE |= ETH_BUS_MODE_SWR_Msk;\n     while((ETH0->BUS_MODE & ETH_BUS_MODE_SWR_Msk) != 0)\n   {\n   }\n\n     ETH0->GMII_ADDRESS = ETH_GMII_ADDRESS_CR_DIV62;\n\n     if(interface->phyDriver != NULL)\n   {\n           error = interface->phyDriver->init(interface);\n   }\n   else if(interface->switchDriver != NULL)\n   {\n           error = interface->switchDriver->init(interface);\n   }\n   else\n   {\n           error = ERROR_FAILURE;\n   }\n\n     if(error)\n   {\n      return error;\n   }\n\n     ETH0->MAC_CONFIGURATION = ETH_MAC_CONFIGURATION_RESERVED15_Msk |\n      ETH_MAC_CONFIGURATION_DO_Msk;\n\n     ETH0->MAC_ADDRESS0_LOW = interface->macAddr.w[0] | (interface->macAddr.w[1] << 16);\n   ETH0->MAC_ADDRESS0_HIGH = interface->macAddr.w[2];\n\n     ETH0->MAC_ADDRESS1_LOW = 0;\n   ETH0->MAC_ADDRESS1_HIGH = 0;\n   ETH0->MAC_ADDRESS2_LOW = 0;\n   ETH0->MAC_ADDRESS2_HIGH = 0;\n   ETH0->MAC_ADDRESS3_LOW = 0;\n   ETH0->MAC_ADDRESS3_HIGH = 0;\n\n     ETH0->HASH_TABLE_LOW = 0;\n   ETH0->HASH_TABLE_HIGH = 0;\n\n     ETH0->MAC_FRAME_FILTER = ETH_MAC_FRAME_FILTER_HPF_Msk | ETH_MAC_FRAME_FILTER_HMC_Msk;\n     ETH0->FLOW_CONTROL = 0;\n     ETH0->OPERATION_MODE = ETH_OPERATION_MODE_RSF_Msk | ETH_OPERATION_MODE_TSF_Msk;\n\n     ETH0->BUS_MODE = ETH_BUS_MODE_AAL_Msk | ETH_BUS_MODE_USP_Msk |\n      ETH_BUS_MODE_RPBL_1 | ETH_BUS_MODE_PR_1_1 | ETH_BUS_MODE_PBL_1;\n\n     xmc4400EthInitDmaDesc(interface);\n\n       ETH0->MMC_TRANSMIT_INTERRUPT_MASK = 0xFFFFFFFF;\n   ETH0->MMC_RECEIVE_INTERRUPT_MASK = 0xFFFFFFFF;\n   ETH0->MMC_IPC_RECEIVE_INTERRUPT_MASK = 0xFFFFFFFF;\n\n     ETH0->INTERRUPT_MASK = ETH_INTERRUPT_MASK_TSIM_Msk | ETH_INTERRUPT_MASK_PMTIM_Msk;\n\n     ETH0->INTERRUPT_ENABLE = ETH_INTERRUPT_ENABLE_NIE_Msk |\n      ETH_INTERRUPT_ENABLE_RIE_Msk | ETH_INTERRUPT_ENABLE_TIE_Msk;\n\n     NVIC_SetPriorityGrouping(XMC4400_ETH_IRQ_PRIORITY_GROUPING);\n\n     NVIC_SetPriority(ETH0_0_IRQn, NVIC_EncodePriority(XMC4400_ETH_IRQ_PRIORITY_GROUPING,\n      XMC4400_ETH_IRQ_GROUP_PRIORITY, XMC4400_ETH_IRQ_SUB_PRIORITY));\n\n     ETH0->MAC_CONFIGURATION |= ETH_MAC_CONFIGURATION_TE_Msk | ETH_MAC_CONFIGURATION_RE_Msk;\n     ETH0->OPERATION_MODE |= ETH_OPERATION_MODE_ST_Msk | ETH_OPERATION_MODE_SR_Msk;\n\n     osSetEvent(&interface->nicTxEvent);\n\n     return NO_ERROR;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long env_start, env_end;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tret = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\n\t\tthis_len = env_end - (env_start + src);\n\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\n\t\tretval = access_remote_vm(mm, (env_start + src),\n\t\t\tpage, this_len, 0);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\n\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nSPL_METHOD(SplFileObject, seek)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong line_pos;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &line_pos) == FAILURE) {\n\t\treturn;\n\t}\n\tif (line_pos < 0) {\n\t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't seek file %s to negative line %ld\", intern->file_name, line_pos);\n\t\tRETURN_FALSE;\n\t}\n\n\tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n\n\twhile(intern->u.file.current_line_num < line_pos) {\n\t\tif (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {\n\t\t\tbreak;\n\t\t}\n\t}\n} \n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n_PyBytes_DecodeEscape(const char *s,\n                      Py_ssize_t len,\n                      const char *errors,\n                      Py_ssize_t unicode,\n                      const char *recode_encoding,\n                      const char **first_invalid_escape)\n{\n    *first_invalid_escape = NULL;\n    return PyBytes_DecodeEscape(s, len, errors, unicode, recode_encoding);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPyParser_AddToken(parser_state *ps, int type, char *str,\n                  int lineno, int col_offset,\n                  int end_lineno, int end_col_offset,\n                  int *expected_ret)\n{\n    int ilabel;\n    int err;\n\n    D(printf(\"Token %s/'%s' ... \", _PyParser_TokenNames[type], str));\n\n    \n    ilabel = classify(ps, type, str);\n    if (ilabel < 0)\n        return E_SYNTAX;\n\n    \n    for (;;) {\n        \n        dfa *d = ps->p_stack.s_top->s_dfa;\n        state *s = &d->d_state[ps->p_stack.s_top->s_state];\n\n        D(printf(\" DFA '%s', state %d:\",\n            d->d_name, ps->p_stack.s_top->s_state));\n\n        \n        if (s->s_lower <= ilabel && ilabel < s->s_upper) {\n            int x = s->s_accel[ilabel - s->s_lower];\n            if (x != -1) {\n                if (x & (1<<7)) {\n                    \n                    int nt = (x >> 8) + NT_OFFSET;\n                    int arrow = x & ((1<<7)-1);\n                    dfa *d1 = PyGrammar_FindDFA(\n                        ps->p_grammar, nt);\n                    if ((err = push(&ps->p_stack, nt, d1,\n                        arrow, lineno, col_offset,\n                        end_lineno, end_col_offset)) > 0) {\n                        D(printf(\" MemError: push\\n\"));\n                        return err;\n                    }\n                    D(printf(\" Push ...\\n\"));\n                    continue;\n                }\n\n                \n                if ((err = shift(&ps->p_stack, type, str,\n                                x, lineno, col_offset,\n                                end_lineno, end_col_offset)) > 0) {\n                    D(printf(\" MemError: shift.\\n\"));\n                    return err;\n                }\n                D(printf(\" Shift.\\n\"));\n                \n                while (s = &d->d_state\n                                [ps->p_stack.s_top->s_state],\n                    s->s_accept && s->s_narcs == 1) {\n                    D(printf(\"  DFA '%s', state %d: \"\n                             \"Direct pop.\\n\",\n                             d->d_name,\n                             ps->p_stack.s_top->s_state));\n#ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD\n#if 0\n                    if (d->d_name[0] == 'i' &&\n                        strcmp(d->d_name,\n                           \"import_stmt\") == 0)\n                        future_hack(ps);\n#endif\n#endif\n                    s_pop(&ps->p_stack);\n                    if (s_empty(&ps->p_stack)) {\n                        D(printf(\"  ACCEPT.\\n\"));\n                        return E_DONE;\n                    }\n                    d = ps->p_stack.s_top->s_dfa;\n                }\n                return E_OK;\n            }\n        }\n\n        if (s->s_accept) {\n#ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD\n#if 0\n            if (d->d_name[0] == 'i' &&\n                strcmp(d->d_name, \"import_stmt\") == 0)\n                future_hack(ps);\n#endif\n#endif\n            \n            s_pop(&ps->p_stack);\n            D(printf(\" Pop ...\\n\"));\n            if (s_empty(&ps->p_stack)) {\n                D(printf(\" Error: bottom of stack.\\n\"));\n                return E_SYNTAX;\n            }\n            continue;\n        }\n\n        \n        D(printf(\" Error.\\n\"));\n        if (expected_ret) {\n            if (s->s_lower == s->s_upper - 1) {\n                \n                *expected_ret = ps->p_grammar->\n                    g_ll.ll_label[s->s_lower].lb_type;\n            }\n            else\n                *expected_ret = -1;\n        }\n        return E_SYNTAX;\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nnf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\n\t\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\n\t\tnewdst = 0;\n\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev && indev->ifa_list) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\n\t\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\n\t\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\t\n\t\t\tstruct userfaultfd_wake_range range;\n\t\t\trange.start = start;\n\t\t\trange.len = vma_end - start;\n\t\t\twake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);\n\t\t}\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTEST_F(QuantizedConv2DTest, OddPaddingBatch) {\n  const int stride = 2;\n  TF_ASSERT_OK(NodeDefBuilder(\"quantized_conv_op\", \"QuantizedConv2D\")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"out_type\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"strides\", {1, stride, stride, 1})\n                   .Attr(\"padding\", \"SAME\")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n\n  const int depth = 1;\n  const int image_width = 4;\n  const int image_height = 4;\n  const int image_batch_count = 3;\n  AddInputFromArray<quint8>(\n      TensorShape({image_batch_count, image_height, image_width, depth}),\n      {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n       1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n       1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16});\n  const int filter_size = 3;\n  const int filter_count = 1;\n  AddInputFromArray<quint8>(\n      TensorShape({filter_size, filter_size, depth, filter_count}),\n      {1, 2, 3, 4, 5, 6, 7, 8, 9});\n  AddInputFromArray<float>(TensorShape({}), {0});\n  AddInputFromArray<float>(TensorShape({}), {255.0f});\n  AddInputFromArray<float>(TensorShape({}), {0});\n  AddInputFromArray<float>(TensorShape({}), {255.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  const int expected_width = image_width / stride;\n  const int expected_height = (image_height * filter_count) / stride;\n  Tensor expected(DT_QINT32, TensorShape({image_batch_count, expected_height,\n                                          expected_width, filter_count}));\n  test::FillValues<qint32>(&expected, {348, 252, 274, 175,                                        348, 252, 274, 175,                                        348, 252, 274, 175});\n  test::ExpectTensorEqual<qint32>(expected, *GetOutput(0));\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tsize_t j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tfile->namelen = MIN(sizeof file->name, len);\n\t\t\tmemcpy(file->name, d, file->namelen);\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic unsigned char *read_chunk(struct mschm_decompressor_p *self,\n\t\t\t\t struct mschmd_header *chm,\n\t\t\t\t struct mspack_file *fh,\n\t\t\t\t unsigned int chunk_num)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *buf;\n\n    \n    if (chunk_num > chm->num_chunks) return NULL;\n    \n    \n    if (!chm->chunk_cache) {\n\tsize_t size = sizeof(unsigned char *) * chm->num_chunks;\n\tif (!(chm->chunk_cache = (unsigned char **) sys->alloc(sys, size))) {\n\t    self->error = MSPACK_ERR_NOMEMORY;\n\t    return NULL;\n\t}\n\tmemset(chm->chunk_cache, 0, size);\n    }\n\n    \n    if (chm->chunk_cache[chunk_num]) return chm->chunk_cache[chunk_num];\n\n    \n    if (!(buf = (unsigned char *) sys->alloc(sys, chm->chunk_size))) {\n\tself->error = MSPACK_ERR_NOMEMORY;\n\treturn NULL;\n    }\n\n    \n    if (sys->seek(fh, (off_t) (chm->dir_offset + (chunk_num * chm->chunk_size)),\n\t\t      MSPACK_SYS_SEEK_START))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n    if (sys->read(fh, buf, (int)chm->chunk_size) != (int)chm->chunk_size) {\n\tself->error = MSPACK_ERR_READ;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    \n    if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) &&\n\t  ((buf[3] == 0x4C) || (buf[3] == 0x49))))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    \n    return chm->chunk_cache[chunk_num] = buf;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void ComputeAsync(OpKernelContext* context, DoneCallback done) override {\n       const Tensor& grads = context->input(0);\n       const Tensor& boxes = context->input(1);\n       const Tensor& box_index = context->input(2);\n       const Tensor& image_size = context->input(3);\n\n       OP_REQUIRES_ASYNC(context, grads.dims() == 4,\n                      errors::InvalidArgument(\"grads image must be 4-D\",\n                                              grads.shape().DebugString()),\n                      done);\n    const int crop_height = grads.dim_size(1);\n    const int crop_width = grads.dim_size(2);\n    OP_REQUIRES_ASYNC(\n        context, crop_height > 0 && crop_width > 0,\n        errors::InvalidArgument(\"grads dimensions must be positive\"), done);\n    int num_boxes = 0;\n    OP_REQUIRES_OK_ASYNC(\n        context, ParseAndCheckBoxSizes(boxes, box_index, &num_boxes), done);\n    OP_REQUIRES_ASYNC(\n        context, grads.dim_size(0) == num_boxes,\n        errors::InvalidArgument(\"boxes and grads have incompatible shape\"),\n        done);\n\n    OP_REQUIRES_ASYNC(context, image_size.dims() == 1,\n                      errors::InvalidArgument(\"image_size must be 1-D\",\n                                              image_size.shape().DebugString()),\n                      done);\n    OP_REQUIRES_ASYNC(context, image_size.dim_size(0) == 4,\n                      errors::InvalidArgument(\"image_size must have 4 elements\",\n                                              image_size.shape().DebugString()),\n                      done);\n    auto image_size_vec = image_size.vec<int32>();\n    const int batch_size = internal::SubtleMustCopy(image_size_vec(0));\n    const int image_height = internal::SubtleMustCopy(image_size_vec(1));\n    const int image_width = internal::SubtleMustCopy(image_size_vec(2));\n    const int depth = internal::SubtleMustCopy(image_size_vec(3));\n    OP_REQUIRES_ASYNC(\n        context, image_height > 0 && image_width > 0,\n        errors::InvalidArgument(\"image dimensions must be positive\"), done);\n    OP_REQUIRES_ASYNC(\n        context, grads.dim_size(3) == depth,\n        errors::InvalidArgument(\"image_size and grads are incompatible\"), done);\n\n    if (std::is_same<Device, GPUDevice>::value) {\n      OP_REQUIRES_ASYNC(\n          context, !OpDeterminismRequired(),\n          errors::Unimplemented(\n              \"Deterministic GPU implementation of CropAndResizeBackpropImage\"\n              \" not available.\"),\n          done);\n    }\n\n    TensorShape shape;\n    OP_REQUIRES_OK_ASYNC(context, shape.AddDimWithStatus(batch_size), done);\n    OP_REQUIRES_OK_ASYNC(context, shape.AddDimWithStatus(image_height), done);\n    OP_REQUIRES_OK_ASYNC(context, shape.AddDimWithStatus(image_width), done);\n    OP_REQUIRES_OK_ASYNC(context, shape.AddDimWithStatus(depth), done);\n       Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(context, context->allocate_output(0, shape, &output),\n                         done);\n\n    auto compute_callback = [this, context, output]() {\n      const Tensor& grads = context->input(0);\n      const Tensor& boxes = context->input(1);\n      const Tensor& box_index = context->input(2);\n      const bool status = functor::CropAndResizeBackpropImage<Device, T>()(\n          context, grads.tensor<float, 4>(), boxes.tensor<float, 2>(),\n          box_index.tensor<int32, 1>(), output->tensor<T, 4>(), method_);\n\n      if (!status) {\n        context->SetStatus(errors::Internal(\n            \"Failed to launch CropAndResizeBackpropImage kernel.\"));\n      }\n    };\n\n    RunIfBoxIndexIsValid<Device>(context, box_index.tensor<int32, 1>(),\n                                 batch_size, std::move(compute_callback),\n                                 std::move(done));\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ngrub_ext2_iterate_dir (grub_fshelp_node_t dir,\n\t\t       int (*hook) (const char *filename,\n\t\t\t\t    enum grub_fshelp_filetype filetype,\n\t\t\t\t    grub_fshelp_node_t node,\n\t\t\t\t    void *closure),\n\t\t       void *closure)\n{\n  unsigned int fpos = 0;\n  struct grub_fshelp_node *diro = (struct grub_fshelp_node *) dir;\n\n  if (! diro->inode_read)\n    {\n      grub_ext2_read_inode (diro->data, diro->ino, &diro->inode);\n      if (grub_errno)\n\treturn 0;\n    }\n\n  \n  if (hook)\n  while (fpos < grub_le_to_cpu32 (diro->inode.size))\n    {\n      struct ext2_dirent dirent;\n\n      grub_ext2_read_file (diro, NULL, NULL, 0, fpos, sizeof (dirent),\n\t\t\t   (char *) &dirent);\n      if (grub_errno)\n\treturn 0;\n\n      if (dirent.direntlen == 0)\n        return 0;\n\n      if (dirent.namelen != 0)\n\t{\n\t  char * filename = grub_malloc (dirent.namelen + 1);\n\t  struct grub_fshelp_node *fdiro;\n\t  enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN;\n\nif (!filename) {\nbreak;\n}\n\t  grub_ext2_read_file (diro, 0, 0, 0,\n\t\t\t       fpos + sizeof (struct ext2_dirent),\n\t\t\t       dirent.namelen, filename);\n\t  if (grub_errno) {\n            free (filename);\n\t    return 0;\n\t  }\n\n\t  fdiro = grub_malloc (sizeof (struct grub_fshelp_node));\n\t  if (! fdiro) {\n            free (filename);\n\t    return 0;\n          }\n\n\t  fdiro->data = diro->data;\n\t  fdiro->ino = grub_le_to_cpu32 (dirent.inode);\n\n\t  filename[dirent.namelen] = '\\0';\n\n\t  if (dirent.filetype != FILETYPE_UNKNOWN)\n\t    {\n\t      fdiro->inode_read = 0;\n\n\t      if (dirent.filetype == FILETYPE_DIRECTORY)\n\t\ttype = GRUB_FSHELP_DIR;\n\t      else if (dirent.filetype == FILETYPE_SYMLINK)\n\t\ttype = GRUB_FSHELP_SYMLINK;\n\t      else if (dirent.filetype == FILETYPE_REG)\n\t\ttype = GRUB_FSHELP_REG;\n\t    }\n\t  else\n\t    {\n\t      \n\t      grub_ext2_read_inode (diro->data,\n                                    grub_le_to_cpu32 (dirent.inode),\n\t\t\t\t    &fdiro->inode);\n\t      if (grub_errno) {\n                  free (filename);\n\t\t  grub_free (fdiro);\n\t\t  return 0;\n\t\t}\n\n\t      fdiro->inode_read = 1;\n\n\t      if ((grub_le_to_cpu16 (fdiro->inode.mode)\n\t\t   & FILETYPE_INO_MASK) == FILETYPE_INO_DIRECTORY)\n\t\ttype = GRUB_FSHELP_DIR;\n\t      else if ((grub_le_to_cpu16 (fdiro->inode.mode)\n\t\t\t& FILETYPE_INO_MASK) == FILETYPE_INO_SYMLINK)\n\t\ttype = GRUB_FSHELP_SYMLINK;\n\t      else if ((grub_le_to_cpu16 (fdiro->inode.mode)\n\t\t\t& FILETYPE_INO_MASK) == FILETYPE_INO_REG)\n\t\ttype = GRUB_FSHELP_REG;\n\t    }\n\n\t  if (hook (filename, type, fdiro, closure)) {\n            free (filename);\n\t    return 1;\n          }\n          free (filename);\n\t}\n\n      fpos += grub_le_to_cpu16 (dirent.direntlen);\n    }\n\n  return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  output->type = input->type;\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);\n  return context->ResizeTensor(context, output, output_size);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ndo_ssh2_kex(void)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_SERVER };\n\tstruct kex *kex;\n\tint r;\n\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(\n\t    options.kex_algorithms);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\n\tif (options.compression == COMP_NONE) {\n\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = \"none\";\n\t} else if (options.compression == COMP_DELAYED) {\n\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] =\n\t\t    \"none,zlib@openssh.com\";\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tpacket_set_rekey_limits(options.rekey_limit,\n\t\t    (time_t)options.rekey_interval);\n\n\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = compat_pkalg_proposal(\n\t    list_hostkey_types());\n\n\t\n\tif ((r = kex_setup(active_state, myproposal)) != 0)\n\t\tfatal(\"kex_setup: %s\", ssh_err(r));\n\tkex = active_state->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tkex->server = 1;\n\tkex->client_version_string=client_version_string;\n\tkex->server_version_string=server_version_string;\n\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\tkex->host_key_index=&get_hostkey_index;\n\tkex->sign = sshd_hostkey_sign;\n\n\tdispatch_run(DISPATCH_BLOCK, &kex->done, active_state);\n\n\tsession_id2 = kex->session_id;\n\tsession_id2_len = kex->session_id_len;\n\n#ifdef DEBUG_KEXDH\n\t\n\tpacket_start(SSH2_MSG_IGNORE);\n\tpacket_put_cstring(\"markus\");\n\tpacket_send();\n\tpacket_write_wait();\n#endif\n\tdebug(\"KEX done\");\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline void openOptimized(sqlite3*& db) {\n  sqlite3_open(\":memory:\", &db);\n\n  std::string settings;\n  for (const auto& setting : kMemoryDBSettings) {\n    settings += \"PRAGMA \" + setting.first + \"=\" + setting.second + \"; \";\n  }\n  sqlite3_exec(db, settings.c_str(), nullptr, nullptr, nullptr);\n\n   registerMathExtensions(db);\n#if !defined(FREEBSD)\n  registerStringExtensions(db);\n#endif\n#if !defined(SKIP_CARVER)\n  registerOperationExtensions(db);\n#endif\n  registerFilesystemExtensions(db);\n  registerHashingExtensions(db);\n  registerEncodingExtensions(db);\n\n  auto rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n  if (rc != SQLITE_OK) {\n    LOG(ERROR) << \"Failed to set sqlite authorizer: \" << sqlite3_errmsg(db);\n    requestShutdown(rc);\n  }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n\n  if (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8) {\n    auto input1_offset = -input1->params.zero_point;\n    auto input2_offset = -input2->params.zero_point;\n    const int kLeftShift = 8;\n\n    int32_t input1_multiplier;\n    int input1_shift;\n    QuantizeMultiplierSmallerThanOneExp(\n        static_cast<double>(input1->params.scale), &input1_multiplier,\n        &input1_shift);\n    int32_t input2_multiplier;\n    int input2_shift;\n    QuantizeMultiplierSmallerThanOneExp(\n        static_cast<double>(input2->params.scale), &input2_multiplier,\n        &input2_shift);\n\n    data->params.left_shift = kLeftShift;\n    data->params.input1_offset = input1_offset;\n    data->params.input1_multiplier = input1_multiplier;\n    data->params.input1_shift = input1_shift;\n    data->params.input2_offset = input2_offset;\n    data->params.input2_multiplier = input2_multiplier;\n    data->params.input2_shift = input2_shift;\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->outputs->size, node->outputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus GetIntermediatesSafe(const TfLiteContext* context,\n                                  const TfLiteNode* node, int index,\n                                  TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n                                 context, index, node->intermediates->size,\n                                 node->intermediates->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(&data, 1, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, buf, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\tkfree(buf);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int cmd_handle_untagged(struct ImapData *idata)\n{\n  unsigned int count = 0;\n  char *s = imap_next_word(idata->buf);\n  char *pn = imap_next_word(s);\n\n  if ((idata->state >= IMAP_SELECTED) && isdigit((unsigned char) *s))\n  {\n    pn = s;\n    s = imap_next_word(s);\n\n    \n    if (mutt_str_strncasecmp(\"EXISTS\", s, 6) == 0)\n    {\n      mutt_debug(2, \"Handling EXISTS\\n\");\n\n      \n      if (mutt_str_atoui(pn, &count) < 0)\n      {\n        mutt_debug(1, \"Malformed EXISTS: '%s'\\n\", pn);\n      }\n\n      if (!(idata->reopen & IMAP_EXPUNGE_PENDING) && count < idata->max_msn)\n      {\n        \n        mutt_debug(1, \"Message count is out of sync\\n\");\n        return 0;\n      }\n      \n      else if (count == idata->max_msn)\n        mutt_debug(3, \"superfluous EXISTS message.\\n\");\n      else\n      {\n        if (!(idata->reopen & IMAP_EXPUNGE_PENDING))\n        {\n          mutt_debug(2, \"New mail in %s - %d messages total.\\n\", idata->mailbox, count);\n          idata->reopen |= IMAP_NEWMAIL_PENDING;\n        }\n        idata->new_mail_count = count;\n      }\n    }\n    \n    else if (mutt_str_strncasecmp(\"EXPUNGE\", s, 7) == 0)\n      cmd_parse_expunge(idata, pn);\n    else if (mutt_str_strncasecmp(\"FETCH\", s, 5) == 0)\n      cmd_parse_fetch(idata, pn);\n  }\n  else if (mutt_str_strncasecmp(\"CAPABILITY\", s, 10) == 0)\n    cmd_parse_capability(idata, s);\n  else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", s, 14) == 0)\n    cmd_parse_capability(idata, pn);\n  else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", pn, 14) == 0)\n    cmd_parse_capability(idata, imap_next_word(pn));\n  else if (mutt_str_strncasecmp(\"LIST\", s, 4) == 0)\n    cmd_parse_list(idata, s);\n  else if (mutt_str_strncasecmp(\"LSUB\", s, 4) == 0)\n    cmd_parse_lsub(idata, s);\n  else if (mutt_str_strncasecmp(\"MYRIGHTS\", s, 8) == 0)\n    cmd_parse_myrights(idata, s);\n  else if (mutt_str_strncasecmp(\"SEARCH\", s, 6) == 0)\n    cmd_parse_search(idata, s);\n  else if (mutt_str_strncasecmp(\"STATUS\", s, 6) == 0)\n    cmd_parse_status(idata, s);\n  else if (mutt_str_strncasecmp(\"ENABLED\", s, 7) == 0)\n    cmd_parse_enabled(idata, s);\n  else if (mutt_str_strncasecmp(\"BYE\", s, 3) == 0)\n  {\n    mutt_debug(2, \"Handling BYE\\n\");\n\n    \n    if (idata->status == IMAP_BYE)\n      return 0;\n\n    \n    s += 3;\n    SKIPWS(s);\n    mutt_error(\"%s\", s);\n    cmd_handle_fatal(idata);\n\n    return -1;\n  }\n  else if (ImapServernoise && (mutt_str_strncasecmp(\"NO\", s, 2) == 0))\n  {\n    mutt_debug(2, \"Handling untagged NO\\n\");\n\n    \n    mutt_error(\"%s\", s + 2);\n  }\n\n  return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nGetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t\n\tr = -1;\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n\n        \n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n\n            \n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n\n            \n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n\n                \n                if (!iterator->terminatingWildcardChild->triggered) {\n                    \n                    if (numTriggeredTopics == 64) {\n                        drain();\n                    }\n\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n\n            \n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                \n                return;\n            }\n\n            iterator = it->second;\n        }\n\n        \n        iterator->messages[messageId] = message;\n\n        \n        if (!iterator->triggered) {\n            \n            if (numTriggeredTopics == 64) {\n                drain();\n            }\n\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nAP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n       unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n\n       m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmcs_parse_domain_params(STREAM s)\n{\n\tuint32 length;\n\tstruct stream packet = *s;\n\n\tber_parse_header(s, MCS_TAG_DOMAIN_PARAMS, &length);\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\trdp_protocol_error(\"mcs_parse_domain_params(), consume domain params from stream would overrun\", &packet);\n\t}\n\n\tin_uint8s(s, length);\n\n\treturn s_check(s);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline void txopt_put(struct ipv6_txoptions *opt)\n{\n\tif (opt && atomic_dec_and_test(&opt->refcnt))\n\t\tkfree_rcu(opt, rcu);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n                  version, stream_size)\n    z_streamp strm;\n    int  level;\n    int  method;\n    int  windowBits;\n    int  memLevel;\n    int  strategy;\n    const char *version;\n    int stream_size;\n{\n    deflate_state *s;\n    int wrap = 1;\n    static const char my_version[] = ZLIB_VERSION;\n\n    if (version == Z_NULL || version[0] != my_version[0] ||\n        stream_size != sizeof(z_stream)) {\n        return Z_VERSION_ERROR;\n    }\n    if (strm == Z_NULL) return Z_STREAM_ERROR;\n\n    strm->msg = Z_NULL;\n    if (strm->zalloc == (alloc_func)0) {\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n        strm->zalloc = zcalloc;\n        strm->opaque = (voidpf)0;\n#endif\n    }\n    if (strm->zfree == (free_func)0)\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n        strm->zfree = zcfree;\n#endif\n\n#ifdef FASTEST\n    if (level != 0) level = 1;\n#else\n    if (level == Z_DEFAULT_COMPRESSION) level = 6;\n#endif\n\n    if (windowBits < 0) { \n        wrap = 0;\n        windowBits = -windowBits;\n    }\n#ifdef GZIP\n    else if (windowBits > 15) {\n        wrap = 2;       \n        windowBits -= 16;\n    }\n#endif\n    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||\n        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n        strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {\n        return Z_STREAM_ERROR;\n    }\n    if (windowBits == 8) windowBits = 9;  \n    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));\n    if (s == Z_NULL) return Z_MEM_ERROR;\n    strm->state = (struct internal_state FAR *)s;\n    s->strm = strm;\n    s->status = INIT_STATE;     \n\n    s->wrap = wrap;\n    s->gzhead = Z_NULL;\n    s->w_bits = (uInt)windowBits;\n    s->w_size = 1 << s->w_bits;\n    s->w_mask = s->w_size - 1;\n\n    s->hash_bits = (uInt)memLevel + 7;\n    s->hash_size = 1 << s->hash_bits;\n    s->hash_mask = s->hash_size - 1;\n    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);\n\n    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));\n    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));\n    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));\n\n    s->high_water = 0;      \n\n    s->lit_bufsize = 1 << (memLevel + 6); \n\n    \n\n    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);\n    s->pending_buf_size = (ulg)s->lit_bufsize * 4;\n\n    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||\n        s->pending_buf == Z_NULL) {\n        s->status = FINISH_STATE;\n        strm->msg = ERR_MSG(Z_MEM_ERROR);\n        deflateEnd (strm);\n        return Z_MEM_ERROR;\n    }\n    s->sym_buf = s->pending_buf + s->lit_bufsize;\n    s->sym_end = (s->lit_bufsize - 1) * 3;\n    \n\n    s->level = level;\n    s->strategy = strategy;\n    s->method = (Byte)method;\n\n    return deflateReset(strm);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast2obj_alias(void* _o)\n{\n    alias_ty o = (alias_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(alias_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->name);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_identifier(o->asname);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_asname, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsec_decrypt(uint8 * data, int length)\n{\n\tif (length <= 0)\n\t\treturn;\n\n\tif (g_sec_decrypt_use_count == 4096)\n\t{\n\t\tsec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);\n\t\trdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);\n\t\tg_sec_decrypt_use_count = 0;\n\t}\n\n\trdssl_rc4_crypt(&g_rc4_decrypt_key, data, data, length);\n\tg_sec_decrypt_use_count++;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nset_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,\n                ALG_ID *algIds)\n{\n  char *startCur = ciphers;\n  int algCount = 0;\n  while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {\n    long alg = strtol(startCur, 0, 0);\n    if(!alg)\n      alg = get_alg_id_by_name(startCur);\n    if(alg)\n      algIds[algCount++] = alg;\n    else if(!strncmp(startCur, \"USE_STRONG_CRYPTO\",\n                     sizeof(\"USE_STRONG_CRYPTO\") - 1) ||\n            !strncmp(startCur, \"SCH_USE_STRONG_CRYPTO\",\n                     sizeof(\"SCH_USE_STRONG_CRYPTO\") - 1))\n      schannel_cred->dwFlags |= SCH_USE_STRONG_CRYPTO;\n    else\n      return CURLE_SSL_CIPHER;\n    startCur = strchr(startCur, ':');\n    if(startCur)\n      startCur++;\n  }\n  schannel_cred->palgSupportedAlgs = algIds;\n  schannel_cred->cSupportedAlgs = algCount;\n  return CURLE_OK;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid HTML_put_string(HTStructured * me, const char *s)\n{\n    HTChunk *target = NULL;\n\n#ifdef USE_PRETTYSRC\n    char *translated_string = NULL;\n#endif\n\n    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))\n\treturn;\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tStrAllocCopy(translated_string, s);\n\tTRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);\n\ts = (const char *) translated_string;\n    }\n#endif\n\n    switch (me->sp[0].tag_number) {\n\n    case HTML_COMMENT:\n\tbreak;\t\t\t\n\n    case HTML_TITLE:\n\ttarget = &me->title;\n\tbreak;\n\n    case HTML_STYLE:\n\ttarget = &me->style_block;\n\tbreak;\n\n    case HTML_SCRIPT:\n\ttarget = &me->script;\n\tbreak;\n\n    case HTML_PRE:\t\t\n    case HTML_LISTING:\t\t\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n\t\n\tHText_appendText(me->text, s);\n\tbreak;\n\n    case HTML_OBJECT:\n\ttarget = &me->object;\n\tbreak;\n\n    case HTML_TEXTAREA:\n\ttarget = &me->textarea;\n\tbreak;\n\n    case HTML_SELECT:\n    case HTML_OPTION:\n\ttarget = &me->option;\n\tbreak;\n\n    case HTML_MATH:\n\ttarget = &me->math;\n\tbreak;\n\n    default:\t\t\t\n\tif (!me->sp->style->freeFormat) {\n\t    \n#ifdef USE_PRETTYSRC\n\t    if (psrc_view) {\n\t\t\n\t\tfor (; *s; ++s)\n\t\t    HTML_put_character(me, *s);\n\t    } else\n#endif\n\t\tHText_appendText(me->text, s);\n\t    break;\n\t} else {\n\t    const char *p = s;\n\t    char c;\n\n\t    if (me->style_change) {\n\t\tfor (; *p && ((*p == '\\n') || (*p == '\\r') ||\n\t\t\t      (*p == ' ') || (*p == '\\t')); p++) ;\t\n\t\tif (!*p)\n\t\t    break;\n\t\tUPDATE_STYLE;\n\t    }\n\t    for (; *p; p++) {\n\t\tif (*p == 13 && p[1] != 10) {\n\t\t    \n\t\t    c = '\\n';\n\t\t} else {\n\t\t    c = *p;\n\t\t}\n\t\tif (me->style_change) {\n\t\t    if ((c == '\\n') || (c == ' ') || (c == '\\t'))\n\t\t\tcontinue;\t\n\t\t    UPDATE_STYLE;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t    if (!FIX_JAPANESE_SPACES) {\n\t\t\tif (me->in_word) {\n\t\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\t\tHText_appendCharacter(me->text, ' ');\n\t\t\t    me->in_word = NO;\n\t\t\t}\n\t\t    }\n\n\t\t} else if (c == ' ' || c == '\\t') {\n\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\tHText_appendCharacter(me->text, ' ');\n\n\t\t} else if (c == '\\r') {\n\t\t    \n\t\t} else {\n\t\t    HText_appendCharacter(me->text, c);\n\t\t    me->in_word = YES;\n\t\t}\n\n\t\t\n\t\tif (c == '\\n' || c == '\\t') {\n\t\t    \n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else if (c == '\\r' &&\n\t\t\t   HText_getLastChar(me->text) == ' ') {\n\t\t    \n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else {\n\t\t    HText_setLastChar(me->text, c);\n\t\t}\n\n\t    }\t\t\t\n\t}\n    }\t\t\t\t\n\n    if (target != NULL) {\n\tif (target->data == s) {\n\t    CTRACE((tfp, \"BUG: appending chunk to itself: `%.*s'\\n\",\n\t\t    target->size, target->data));\n\t} else {\n\t    HTChunkPuts(target, s);\n\t}\n    }\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tpsrc_convert_string = FALSE;\n\tFREE(translated_string);\n    }\n#endif\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTEST_CASE_METHOD(TestFixture, \"DKG AES gen test\", \"[dkg-aes-gen]\") {\n    vector <uint8_t> encryptedDKGSecret(BUF_LEN, 0);\n    vector<char> errMsg(BUF_LEN, 0);\n\n    int errStatus = 0;\n    uint32_t encLen = 0;\n\n    PRINT_SRC_LINE\n    auto status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encryptedDKGSecret.data(), &encLen, 32);\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    vector<char> secret(BUF_LEN, 0);\n    vector<char> errMsg1(BUF_LEN, 0);\n\n    status = trustedDecryptDkgSecretAES(eid, &errStatus, errMsg1.data(), encryptedDKGSecret.data(),\n                                        encLen, (uint8_t *) secret.data());\n\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nf_py3eval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (p_pyx == 0)\n\tp_pyx = 3;\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_py3eval(str, rettv);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int put_chars(u32 vtermno, const char *buf, int count)\n{\n\tstruct port *port;\n\tstruct scatterlist sg[1];\n\n\tif (unlikely(early_put_chars))\n\t\treturn early_put_chars(vtermno, buf, count);\n\n\tport = find_port_by_vtermno(vtermno);\n\tif (!port)\n\t\treturn -EPIPE;\n\n\tsg_init_one(sg, buf, count);\n\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void _out_result(conn_t out, nad_t nad) {\n    int attr;\n    jid_t from, to;\n    char *rkey;\n    int rkeylen;\n\n    attr = nad_find_attr(nad, 0, -1, \"from\", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid from on db result packet\");\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \"to\", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid to on db result packet\");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n    rkeylen = strlen(rkey);\n\n    \n    if(nad_find_attr(nad, 0, -1, \"type\", \"valid\") >= 0) {\n        log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s\", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", out->s->compressed ? \", ZLIB compression enabled\" : \"\");\n\n        xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    \n\n        log_debug(ZONE, \"%s valid, flushing queue\", rkey);\n\n        \n        out_flush_route_queue(out->s2s, rkey, rkeylen);\n\n        free(rkey);\n\n        jid_free(from);\n        jid_free(to);\n\n        nad_free(nad);\n\n        return;\n    }\n\n    \n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now invalid\", out->fd->fd, out->ip, out->port, rkey);\n\n    \n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] closing connection\", out->fd->fd, out->ip, out->port);\n\n    \n    sx_error(out->s, stream_err_INVALID_ID, \"dialback negotiation failed\");\n\n    \n    sx_close(out->s);\n\n    \n    out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n\n    free(rkey);\n\n    jid_free(from);\n    jid_free(to);\n\n    nad_free(nad);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\n\tio_data->kiocb->private = NULL;\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\npthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)\n{\n\tif ((mutex->lock = malloc(sizeof(CRITICAL_SECTION))) == NULL)\n\t\texit(ENOMEM);\n\tInitializeCriticalSection(mutex->lock);\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint pgx_validate(jas_stream_t *in)\n{\n\tjas_uchar buf[PGX_MAGICLEN];\n\tuint_fast32_t magic;\n\tint i;\n\tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= PGX_MAGICLEN);\n\n\t\n\tif ((n = jas_stream_read(in, buf, PGX_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\t\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t\n\tif (n < PGX_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\t\n\tmagic = (buf[0] << 8) | buf[1];\n\n\t\n\tif (magic != PGX_MAGIC) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid gdImageFill(gdImagePtr im, int x, int y, int nc)\n{\n\tint l, x1, x2, dy;\n\tint oc;   \n\tint wx2,wy2;\n\n\tint alphablending_bak;\n\n\t\n\t\n\tstruct seg *stack = NULL;\n\tstruct seg *sp;\n\n\tif (!im->trueColor && nc > (im->colorsTotal -1)) {\n\t\treturn;\n\t}\n\n\talphablending_bak = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (nc==gdTiled){\n\t\t_gdImageFillTiled(im,x,y,nc);\n\t\tim->alphaBlendingFlag = alphablending_bak;\n\t\treturn;\n\t}\n\n\twx2=im->sx;wy2=im->sy;\n\toc = gdImageGetPixel(im, x, y);\n\tif (oc==nc || x<0 || x>wx2 || y<0 || y>wy2) {\n\t\tim->alphaBlendingFlag = alphablending_bak;\n\t\treturn;\n\t}\n\n\t\n\tif (im->sx < 4) {\n\t\tint ix = x, iy = y, c;\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tc = gdImageGetPixel(im, ix, iy);\n\t\t\t\tif (c != oc) {\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(im, ix, iy, nc);\n\t\t\t} while(ix++ < (im->sx -1));\n\t\t\tix = x;\n\t\t} while(iy++ < (im->sy -1));\n\t\tgoto done;\n\t}\n\n\tstack = (struct seg *)safe_emalloc(sizeof(struct seg), ((int)(im->sy*im->sx)/4), 1);\n\tsp = stack;\n\n\t\n\tFILL_PUSH(y,x,x,1);\n\t\n \tFILL_PUSH(y+1, x, x, -1);\n\twhile (sp>stack) {\n\t\tFILL_POP(y, x1, x2, dy);\n\n\t\tfor (x=x1; x>=0 && gdImageGetPixel(im,x, y)==oc; x--) {\n\t\t\tgdImageSetPixel(im,x, y, nc);\n\t\t}\n\t\tif (x>=x1) {\n\t\t\tgoto skip;\n\t\t}\n\t\tl = x+1;\n\n                \n\t\tif (l<x1) {\n\t\t\tFILL_PUSH(y, l, x1-1, -dy);\n\t\t}\n\t\tx = x1+1;\n\t\tdo {\n\t\t\tfor (; x<=wx2 && gdImageGetPixel(im,x, y)==oc; x++) {\n\t\t\t\tgdImageSetPixel(im, x, y, nc);\n\t\t\t}\n\t\t\tFILL_PUSH(y, l, x-1, dy);\n\t\t\t\n\t\t\tif (x>x2+1) {\n\t\t\t\tFILL_PUSH(y, x2+1, x-1, -dy);\n\t\t\t}\nskip:\t\t\tfor (x++; x<=x2 && (gdImageGetPixel(im, x, y)!=oc); x++);\n\n\t\t\tl = x;\n\t\t} while (x<=x2);\n\t}\n\n\tefree(stack);\n\ndone:\n\tim->alphaBlendingFlag = alphablending_bak;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nobj2ast_mod(PyObject* obj, mod_ty* out, PyArena* arena)\n{\n    int isinstance;\n\n    PyObject *tmp = NULL;\n\n    if (obj == Py_None) {\n        *out = NULL;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Module_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* body;\n\n        if (_PyObject_LookupAttrId(obj, &PyId_body, &tmp) < 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"required field \\\"body\\\" missing from Module\");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, \"Module field \\\"body\\\" must be a list, not a %.200s\", tmp->ob_type->tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Py_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i < len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, \"Module field \\\"body\\\" changed size during iteration\");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = Module(body, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Interactive_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* body;\n\n        if (_PyObject_LookupAttrId(obj, &PyId_body, &tmp) < 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"required field \\\"body\\\" missing from Interactive\");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, \"Interactive field \\\"body\\\" must be a list, not a %.200s\", tmp->ob_type->tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Py_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i < len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, \"Interactive field \\\"body\\\" changed size during iteration\");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = Interactive(body, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Expression_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty body;\n\n        if (_PyObject_LookupAttrId(obj, &PyId_body, &tmp) < 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"required field \\\"body\\\" missing from Expression\");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &body, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = Expression(body, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Suite_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* body;\n\n        if (_PyObject_LookupAttrId(obj, &PyId_body, &tmp) < 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"required field \\\"body\\\" missing from Suite\");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, \"Suite field \\\"body\\\" must be a list, not a %.200s\", tmp->ob_type->tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Py_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i < len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, \"Suite field \\\"body\\\" changed size during iteration\");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = Suite(body, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n\n    PyErr_Format(PyExc_TypeError, \"expected some sort of mod, but got %R\", obj);\n    failed:\n    Py_XDECREF(tmp);\n    return 1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nGPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size){\n\tif (ms)\n\t{\n\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\n\t\tif (nestsize == 0 && ms->nest_level == 0)\n\t\t\tnestsize = ms->buffer_size_longs;\n\n\t\tif (size + 2 <= nestsize) return GPMF_OK;\n\t}\n\treturn GPMF_ERROR_BAD_STRUCTURE;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus UseDynamicOutputTensors(TfLiteContext* context, TfLiteNode* node) {\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    SetTensorToDynamic(GetOutput(context, node, i));\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t       unsigned long err)\n{\n    int level = 0;\n    int len = 0;\n    ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    level++;\n\n    \n    if (err == SSL_ERROR_SSL) {\n\terr = ERR_get_error();\n\tERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    }\n\n    if (ssock)\n\tssock->last_err = err;\n    return GET_STATUS_FROM_SSL_ERR(err);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,\n\t\tint closing, int tx_ring)\n{\n\tstruct pgv *pg_vec = NULL;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tint was_running, order = 0;\n\tstruct packet_ring_buffer *rb;\n\tstruct sk_buff_head *rb_queue;\n\t__be16 num;\n\tint err = -EINVAL;\n\t\n\tstruct tpacket_req *req = &req_u->req;\n\n\tlock_sock(sk);\n\t\n\tif (!closing && tx_ring && (po->tp_version > TPACKET_V2)) {\n\t\tnet_warn_ratelimited(\"Tx-ring is not supported.\\n\");\n\t\tgoto out;\n\t}\n\n\trb = tx_ring ? &po->tx_ring : &po->rx_ring;\n\trb_queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue;\n\n\terr = -EBUSY;\n\tif (!closing) {\n\t\tif (atomic_read(&po->mapped))\n\t\t\tgoto out;\n\t\tif (packet_read_pending(rb))\n\t\t\tgoto out;\n\t}\n\n\tif (req->tp_block_nr) {\n\t\t\n\t\terr = -EBUSY;\n\t\tif (unlikely(rb->pg_vec))\n\t\t\tgoto out;\n\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V1:\n\t\t\tpo->tp_hdrlen = TPACKET_HDRLEN;\n\t\t\tbreak;\n\t\tcase TPACKET_V2:\n\t\t\tpo->tp_hdrlen = TPACKET2_HDRLEN;\n\t\t\tbreak;\n\t\tcase TPACKET_V3:\n\t\t\tpo->tp_hdrlen = TPACKET3_HDRLEN;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (unlikely((int)req->tp_block_size <= 0))\n\t\t\tgoto out;\n\t\tif (unlikely(!PAGE_ALIGNED(req->tp_block_size)))\n\t\t\tgoto out;\n\t\tif (po->tp_version >= TPACKET_V3 &&\n\t\t    (int)(req->tp_block_size -\n\t\t\t  BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) <= 0)\n\t\t\tgoto out;\n\t\tif (unlikely(req->tp_frame_size < po->tp_hdrlen +\n\t\t\t\t\tpo->tp_reserve))\n\t\t\tgoto out;\n\t\tif (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1)))\n\t\t\tgoto out;\n\n\t\trb->frames_per_block = req->tp_block_size / req->tp_frame_size;\n\t\tif (unlikely(rb->frames_per_block == 0))\n\t\t\tgoto out;\n\t\tif (unlikely((rb->frames_per_block * req->tp_block_nr) !=\n\t\t\t\t\treq->tp_frame_nr))\n\t\t\tgoto out;\n\n\t\terr = -ENOMEM;\n\t\torder = get_order(req->tp_block_size);\n\t\tpg_vec = alloc_pg_vec(req, order);\n\t\tif (unlikely(!pg_vec))\n\t\t\tgoto out;\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V3:\n\t\t\n\t\t\tif (!tx_ring)\n\t\t\t\tinit_prb_bdqc(po, rb, pg_vec, req_u);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\telse {\n\t\terr = -EINVAL;\n\t\tif (unlikely(req->tp_frame_nr))\n\t\t\tgoto out;\n\t}\n\n\n\t\n\tspin_lock(&po->bind_lock);\n\twas_running = po->running;\n\tnum = po->num;\n\tif (was_running) {\n\t\tpo->num = 0;\n\t\t__unregister_prot_hook(sk, false);\n\t}\n\tspin_unlock(&po->bind_lock);\n\n\tsynchronize_net();\n\n\terr = -EBUSY;\n\tmutex_lock(&po->pg_vec_lock);\n\tif (closing || atomic_read(&po->mapped) == 0) {\n\t\terr = 0;\n\t\tspin_lock_bh(&rb_queue->lock);\n\t\tswap(rb->pg_vec, pg_vec);\n\t\trb->frame_max = (req->tp_frame_nr - 1);\n\t\trb->head = 0;\n\t\trb->frame_size = req->tp_frame_size;\n\t\tspin_unlock_bh(&rb_queue->lock);\n\n\t\tswap(rb->pg_vec_order, order);\n\t\tswap(rb->pg_vec_len, req->tp_block_nr);\n\n\t\trb->pg_vec_pages = req->tp_block_size/PAGE_SIZE;\n\t\tpo->prot_hook.func = (po->rx_ring.pg_vec) ?\n\t\t\t\t\t\ttpacket_rcv : packet_rcv;\n\t\tskb_queue_purge(rb_queue);\n\t\tif (atomic_read(&po->mapped))\n\t\t\tpr_err(\"packet_mmap: vma is busy: %d\\n\",\n\t\t\t       atomic_read(&po->mapped));\n\t}\n\tmutex_unlock(&po->pg_vec_lock);\n\n\tspin_lock(&po->bind_lock);\n\tif (was_running) {\n\t\tpo->num = num;\n\t\tregister_prot_hook(sk);\n\t}\n\tspin_unlock(&po->bind_lock);\n\tif (closing && (po->tp_version > TPACKET_V2)) {\n\t\t\n\t\tif (!tx_ring)\n\t\t\tprb_shutdown_retire_blk_timer(po, rb_queue);\n\t}\n\n\tif (pg_vec)\n\t\tfree_pg_vec(pg_vec, order, req->tp_block_nr);\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nhorizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)\n{\n    int32 r1, g1, b1, a1, r2, g2, b2, a2, mask;\n    float fltsize = Fltsize;\n\n#define  CLAMP(v) ( (v<(float)0.)   ? 0\t\t\t\t\\\n\t\t  : (v<(float)2.)   ? FromLT2[(int)(v*fltsize)]\t\\\n\t\t  : (v>(float)24.2) ? 2047\t\t\t\\\n\t\t  : LogK1*log(v*LogK2) + 0.5 )\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    a2 = wp[3] = (uint16) CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = (int32) CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n        REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp++; ip++)\n        n -= stride;\n        while (n > 0) {\n            REPEAT(stride,\n                wp[0] = (uint16)(((int32)CLAMP(ip[0])-(int32)CLAMP(ip[-stride])) & mask);\n                wp++; ip++)\n            n -= stride;\n        }\n\t}\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno)\n{\n  void *uidl = NULL;\n  char buf[LONG_STRING];\n  char path[PATH_MAX];\n  struct Progress progressbar;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct PopCache *cache = NULL;\n  struct Header *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  \n  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n  if (msg->fp)\n    return 0;\n\n  \n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    if (cache->index == h->index)\n    {\n      \n      msg->fp = fopen(cache->path, \"r\");\n      if (msg->fp)\n        return 0;\n\n      mutt_perror(cache->path);\n      return -1;\n    }\n    else\n    {\n      \n      unlink(cache->path);\n      FREE(&cache->path);\n    }\n  }\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    \n    if (h->refno < 0)\n    {\n      mutt_error(\n          _(\"The message index is incorrect. Try reopening the mailbox.\"));\n      return -1;\n    }\n\n    mutt_progress_init(&progressbar, _(\"Fetching message...\"), MUTT_PROGRESS_SIZE,\n                       NetInc, h->content->length + h->content->offset - 1);\n\n    \n    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n    if (!msg->fp)\n    {\n      \n      bcache = 0;\n      mutt_mktemp(path, sizeof(path));\n      msg->fp = mutt_file_fopen(path, \"w+\");\n      if (!msg->fp)\n      {\n        mutt_perror(path);\n        return -1;\n      }\n    }\n\n    snprintf(buf, sizeof(buf), \"RETR %d\\r\\n\", h->refno);\n\n    const int ret = pop_fetch_data(pop_data, buf, &progressbar, fetch_message, msg->fp);\n    if (ret == 0)\n      break;\n\n    mutt_file_fclose(&msg->fp);\n\n    \n    if (!bcache)\n      unlink(path);\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n\n    if (ret == -3)\n    {\n      mutt_error(_(\"Can't write message to temporary file!\"));\n      return -1;\n    }\n  }\n\n  \n  if (bcache)\n    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n  else\n  {\n    cache->index = h->index;\n    cache->path = mutt_str_strdup(path);\n  }\n  rewind(msg->fp);\n  uidl = h->data;\n\n  \n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_delete(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_remove(ctx, h);\n  mutt_env_free(&h->env);\n  h->env = mutt_rfc822_read_header(msg->fp, h, 0, 0);\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_insert(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_add(ctx, h);\n\n  h->data = uidl;\n  h->lines = 0;\n  fgets(buf, sizeof(buf), msg->fp);\n  while (!feof(msg->fp))\n  {\n    ctx->hdrs[msgno]->lines++;\n    fgets(buf, sizeof(buf), msg->fp);\n  }\n\n  h->content->length = ftello(msg->fp) - h->content->offset;\n\n  \n  if (!WithCrypto)\n    h->security = crypt_query(h->content);\n\n  mutt_clear_error();\n  rewind(msg->fp);\n\n  return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteSkipGramParams*>(node->builtin_data);\n\n   std::vector<StringRef> words;\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  tflite::StringRef strref = tflite::GetString(input, 0);\n  int prev_idx = 0;\n  for (int i = 1; i < strref.len; i++) {\n    if (isspace(*(strref.str + i))) {\n      if (i > prev_idx && !isspace(*(strref.str + prev_idx))) {\n        words.push_back({strref.str + prev_idx, i - prev_idx});\n      }\n      prev_idx = i + 1;\n    }\n  }\n  if (strref.len > prev_idx) {\n    words.push_back({strref.str + prev_idx, strref.len - prev_idx});\n  }\n\n   tflite::DynamicBuffer buf;\n  if (words.size() < params->ngram_size) {\n    buf.WriteToTensorAsVector(GetOutput(context, node, 0));\n    return kTfLiteOk;\n  }\n\n    std::vector<int> stack(params->ngram_size, 0);\n   int stack_idx = 1;\n  int num_words = words.size();\n\n  while (stack_idx >= 0) {\n    if (ShouldStepInRecursion(params, stack, stack_idx, num_words)) {\n                     stack[stack_idx]++;\n      stack_idx++;\n      if (stack_idx < params->ngram_size) {\n        stack[stack_idx] = stack[stack_idx - 1];\n      }\n    } else {\n      if (ShouldIncludeCurrentNgram(params, stack_idx)) {\n                      std::vector<StringRef> gram(stack_idx);\n        for (int i = 0; i < stack_idx; i++) {\n          gram[i] = words[stack[i]];\n        }\n        buf.AddJoinedString(gram, ' ');\n      }\n                     stack_idx--;\n    }\n  }\n\n  buf.WriteToTensorAsVector(GetOutput(context, node, 0));\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid RemoteFsDevice::mount()\n{\n    if (details.isLocalFile()) {\n        return;\n    }\n    if (isConnected() || proc) {\n        return;\n    }\n\n    if (messageSent) {\n        return;\n    }\n    if (constSambaAvahiProtocol==details.url.scheme()) {\n        Details det=details;\n        AvahiService *srv=Avahi::self()->getService(det.serviceName);\n        if (!srv || srv->getHost().isEmpty() || 0==srv->getPort()) {\n            emit error(tr(\"Failed to resolve connection details for %1\").arg(details.name));\n            return;\n        }\n        if (constPromptPassword==det.url.password()) {\n            bool ok=false;\n            QString passwd=InputDialog::getPassword(QString(), &ok, QApplication::activeWindow());\n            if (!ok) {\n                return;\n            }\n            det.url.setPassword(passwd);\n        }\n        det.url.setScheme(constSambaProtocol);\n        det.url.setHost(srv->getHost());\n        det.url.setPort(srv->getPort());\n        mounter()->mount(det.url.toString(), mountPoint(details, true), getuid(), getgid(), getpid());\n        setStatusMessage(tr(\"Connecting...\"));\n        messageSent=true;\n        return;\n    }\n    if (constSambaProtocol==details.url.scheme()) {\n        Details det=details;\n        if (constPromptPassword==det.url.password()) {\n            bool ok=false;\n            QString passwd=InputDialog::getPassword(QString(), &ok, QApplication::activeWindow());\n            if (!ok) {\n                return;\n            }\n            det.url.setPassword(passwd);\n        }\n        mounter()->mount(det.url.toString(), mountPoint(details, true), getuid(), getgid(), getpid());\n        setStatusMessage(tr(\"Connecting...\"));\n        messageSent=true;\n        return;\n    }\n\n    QString cmd;\n    QStringList args;\n    QString askPass;\n    if (!details.isLocalFile() && !details.isEmpty()) {\n               bool needAskPass=!details.extraOptions.contains(\"IdentityFile=\");\n\n        if (needAskPass) {\n            QStringList askPassList;\n            if (Utils::KDE==Utils::currentDe()) {\n                askPassList << QLatin1String(\"ksshaskpass\") << QLatin1String(\"ssh-askpass\") << QLatin1String(\"ssh-askpass-gnome\");\n            } else {\n                askPassList << QLatin1String(\"ssh-askpass-gnome\") << QLatin1String(\"ssh-askpass\") << QLatin1String(\"ksshaskpass\");\n            }\n\n            for (const QString &ap: askPassList) {\n                askPass=Utils::findExe(ap);\n                if (!askPass.isEmpty()) {\n                    break;\n                }\n            }\n\n            if (askPass.isEmpty()) {\n                emit error(tr(\"No suitable ssh-askpass application installed! This is required for entering passwords.\"));\n                return;\n            }\n        }\n        QString sshfs=Utils::findExe(\"sshfs\");\n        if (sshfs.isEmpty()) {\n            emit error(tr(\"\\\"sshfs\\\" is not installed!\"));\n            return;\n        }\n        cmd=Utils::findExe(\"setsid\");\n        if (!cmd.isEmpty()) {\n            QString mp=mountPoint(details, true);\n            if (mp.isEmpty()) {\n                emit error(\"Failed to determine mount point\");            }\n            if (!QDir(mp).entryList(QDir::NoDot|QDir::NoDotDot|QDir::AllEntries|QDir::Hidden).isEmpty()) {\n                emit error(tr(\"Mount point (\\\"%1\\\") is not empty!\").arg(mp));\n                return;\n            }\n\n            args << sshfs << details.url.userName()+QChar('@')+details.url.host()+QChar(':')+details.url.path()<< QLatin1String(\"-p\")\n                 << QString::number(details.url.port()) << mountPoint(details, true)\n                 << QLatin1String(\"-o\") << QLatin1String(\"ServerAliveInterval=15\");\n                       if (!details.extraOptions.isEmpty()) {\n                args << details.extraOptions.split(' ', QString::SkipEmptyParts);\n            }\n        } else {\n            emit error(tr(\"\\\"sshfs\\\" is not installed!\").replace(\"sshfs\", \"setsid\"));        }\n    }\n\n    if (!cmd.isEmpty()) {\n        setStatusMessage(tr(\"Connecting...\"));\n        proc=new QProcess(this);\n        proc->setProperty(\"mount\", true);\n\n        if (!askPass.isEmpty()) {\n            QProcessEnvironment env = QProcessEnvironment::systemEnvironment();\n            env.insert(\"SSH_ASKPASS\", askPass);\n            proc->setProcessEnvironment(env);\n        }\n        connect(proc, SIGNAL(finished(int)), SLOT(procFinished(int)));\n        proc->start(cmd, args, QIODevice::ReadOnly);\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE(context, node->inputs->size == kInputNum);\n  TF_LITE_ENSURE(context, node->outputs->size == kOutputNum);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputData);\n  const TfLiteTensor* prev_activation =\n      GetInput(context, node, kInputPrevActivation);\n  const TfLiteTensor* weights = GetInput(context, node, kInputWeights);\n  const TfLiteTensor* bias = GetInput(context, node, kInputBiases);\n  const TfLiteTensor* prev_state = GetInput(context, node, kInputPrevState);\n\n  TF_LITE_ENSURE_EQ(context, input->dims->size, 2);\n  const int num_batches = input->dims->data[0];\n  const int input_depth = input->dims->data[1];\n\n  TF_LITE_ENSURE_EQ(context, prev_activation->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, prev_activation->dims->data[0], num_batches);\n  const int activation_depth = prev_activation->dims->data[1];\n  const int total_depth = input_depth + activation_depth;\n\n  TF_LITE_ENSURE_EQ(context, weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, weights->dims->data[0], 4 * activation_depth);\n  TF_LITE_ENSURE_EQ(context, weights->dims->data[1], total_depth);\n\n  TF_LITE_ENSURE_EQ(context, bias->dims->size, 1);\n  TF_LITE_ENSURE_EQ(context, bias->dims->data[0], 4 * activation_depth);\n\n  TF_LITE_ENSURE_EQ(context, prev_state->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, prev_state->dims->data[0], num_batches);\n  TF_LITE_ENSURE_EQ(context, prev_state->dims->data[1], activation_depth);\n\n  TfLiteTensor* activation_out = GetOutput(context, node, kOutputActivation);\n  TfLiteTensor* state_out = GetOutput(context, node, kOutputState);\n  TfLiteTensor* concat_temp = GetOutput(context, node, kOutputConcatTemp);\n  TfLiteTensor* activation_temp =\n      GetOutput(context, node, kOutputActivationTemp);\n\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(\n                                 context, activation_out,\n                                 TfLiteIntArrayCopy(prev_activation->dims)));\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(context, state_out,\n                                     TfLiteIntArrayCopy(prev_state->dims)));\n\n  TfLiteIntArray* concat_temp_size = TfLiteIntArrayCreate(2);\n  concat_temp_size->data[0] = num_batches;\n  concat_temp_size->data[1] = total_depth;\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(context, concat_temp, concat_temp_size));\n  TfLiteIntArray* activation_temp_size = TfLiteIntArrayCreate(2);\n  activation_temp_size->data[0] = num_batches;\n  activation_temp_size->data[1] = 4 * activation_depth;\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, activation_temp,\n                                                   activation_temp_size));\n\n   for (auto index : {kInputPrevActivation, kInputPrevState}) {\n    TfLiteTensor* tensor = &context->tensors[node->inputs->data[index]];\n    tensor->allocation_type = kTfLiteArenaRwPersistent;\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  if (index >= 0 && index < node->outputs->size) {\n    const int tensor_index = node->outputs->data[index];\n    if (tensor_index != kTfLiteOptionalTensor) {\n      if (context->tensors != nullptr) {\n        return &context->tensors[tensor_index];\n      } else {\n        return context->GetTensor(context, tensor_index);\n      }\n    }\n  }\n  return nullptr;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nGF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void process_tree(struct rev_info *revs,\n\t\t\t struct tree *tree,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *base,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &tree->object;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tenum interesting match = revs->diffopt.pathspec.nr == 0 ?\n\t\tall_entries_interesting: entry_not_interesting;\n\tint baselen = base->len;\n\n\tif (!revs->tree_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad tree object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tif (parse_tree_gently(tree, revs->ignore_missing_links) < 0) {\n\t\tif (revs->ignore_missing_links)\n\t\t\treturn;\n\t\tdie(\"bad tree object %s\", oid_to_hex(&obj->oid));\n\t}\n\n\tobj->flags |= SEEN;\n\tshow(obj, base, name, cb_data);\n\n\tstrbuf_addstr(base, name);\n\tif (base->len)\n\t\tstrbuf_addch(base, '/');\n\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (match != all_entries_interesting) {\n\t\t\tmatch = tree_entry_interesting(&entry, base, 0,\n\t\t\t\t\t\t       &revs->diffopt.pathspec);\n\t\t\tif (match == all_entries_not_interesting)\n\t\t\t\tbreak;\n\t\t\tif (match == entry_not_interesting)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (S_ISDIR(entry.mode))\n\t\t\tprocess_tree(revs,\n\t\t\t\t     lookup_tree(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t\telse if (S_ISGITLINK(entry.mode))\n\t\t\tprocess_gitlink(revs, entry.sha1,\n\t\t\t\t\tshow, base, entry.path,\n\t\t\t\t\tcb_data);\n\t\telse\n\t\t\tprocess_blob(revs,\n\t\t\t\t     lookup_blob(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t}\n\tstrbuf_setlen(base, baselen);\n\tfree_tree_buffer(tree);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int x509_crt_verify_child(\n                mbedtls_x509_crt *child, mbedtls_x509_crt *parent,\n                mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,\n                const mbedtls_x509_crt_profile *profile,\n                int path_cnt, int self_cnt, uint32_t *flags,\n                int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                void *p_vrfy )\n{\n    int ret;\n    uint32_t parent_flags = 0;\n    unsigned char hash[MBEDTLS_MD_MAX_SIZE];\n    mbedtls_x509_crt *grandparent;\n    const mbedtls_md_info_t *md_info;\n\n    \n    if( ( path_cnt != 0 ) && x509_name_cmp( &child->issuer, &child->subject ) == 0 )\n        self_cnt++;\n\n    \n    if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )\n    {\n        \n        return( MBEDTLS_ERR_X509_FATAL_ERROR );\n    }\n\n    if( mbedtls_x509_time_is_past( &child->valid_to ) )\n        *flags |= MBEDTLS_X509_BADCERT_EXPIRED;\n\n    if( mbedtls_x509_time_is_future( &child->valid_from ) )\n        *flags |= MBEDTLS_X509_BADCERT_FUTURE;\n\n    if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_MD;\n\n    if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    md_info = mbedtls_md_info_from_type( child->sig_md );\n    if( md_info == NULL )\n    {\n        \n        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n    }\n    else\n    {\n        mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash );\n\n        if( x509_profile_check_key( profile, child->sig_pk, &parent->pk ) != 0 )\n            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n        if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,\n                           child->sig_md, hash, mbedtls_md_get_size( md_info ),\n                           child->sig.p, child->sig.len ) != 0 )\n        {\n            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n        }\n    }\n\n#if defined(MBEDTLS_X509_CRL_PARSE_C)\n    \n    *flags |= x509_crt_verifycrl(child, parent, ca_crl, profile );\n#endif\n\n    \n    for( grandparent = trust_ca;\n         grandparent != NULL;\n         grandparent = grandparent->next )\n    {\n        if( x509_crt_check_parent( parent, grandparent,\n                                   0, path_cnt == 0 ) == 0 )\n            break;\n    }\n\n    if( grandparent != NULL )\n    {\n        ret = x509_crt_verify_top( parent, grandparent, ca_crl, profile,\n                                path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            return( ret );\n    }\n    else\n    {\n        \n        for( grandparent = parent->next;\n             grandparent != NULL;\n             grandparent = grandparent->next )\n        {\n            \n            if( grandparent->max_pathlen > 0 &&\n                grandparent->max_pathlen < 2 + path_cnt - self_cnt )\n            {\n                continue;\n            }\n\n            if( x509_crt_check_parent( parent, grandparent,\n                                       0, path_cnt == 0 ) == 0 )\n                break;\n        }\n\n        \n        if( grandparent != NULL )\n        {\n            ret = x509_crt_verify_child( parent, grandparent, trust_ca, ca_crl,\n                                         profile, path_cnt + 1, self_cnt, &parent_flags,\n                                         f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n        {\n            ret = x509_crt_verify_top( parent, trust_ca, ca_crl, profile,\n                                       path_cnt + 1, self_cnt, &parent_flags,\n                                       f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n    }\n\n    \n    if( NULL != f_vrfy )\n        if( ( ret = f_vrfy( p_vrfy, child, path_cnt, flags ) ) != 0 )\n            return( ret );\n\n    *flags |= parent_flags;\n\n    return( 0 );\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nheader_gets (SF_PRIVATE *psf, char *ptr, int bufsize)\n{\tint\t\tk ;\n\n\tfor (k = 0 ; k < bufsize - 1 ; k++)\n\t{\tif (psf->headindex < psf->headend)\n\t\t{\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex ++ ;\n\t\t\t}\n\t\telse\n\t\t{\tpsf->headend += psf_fread (psf->header + psf->headend, 1, 1, psf) ;\n\t\t\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\t} ;\n\n\t\tif (ptr [k] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\n\tptr [k] = 0 ;\n\n\treturn k ;\n} \n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)\n{\n    int x;\n    int chunk;\n    UINT8* out;\n    UINT8* ptr;\n\n    ptr = buf;\n\n    chunk = 3 * state->xsize;\n\n    for (;;) {\n\n\t\n\tif (bytes < chunk)\n\t    return ptr - buf;\n\n\t\n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 4;\n\t}\n\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\n\tif (++state->y >= state->ysize)\n\t    return -1; \n\n\t\n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x+state->xsize];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 4;\n\t}\n\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\n\tif (++state->y >= state->ysize)\n\t    return -1;\n\n\tptr += chunk;\n\tbytes -= chunk;\n\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_rpsi(\n\t\t\t\t\t    pjmedia_rtcp_session *session, \n\t\t\t\t\t    void *buf,\n\t\t\t\t\t    pj_size_t *length,\n\t\t\t\t\t    const pjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_fb_common *hdr;\n    pj_uint8_t *p;\n    unsigned bitlen, padlen, len;\n\n    PJ_ASSERT_RETURN(session && buf && length && rpsi, PJ_EINVAL);\n\n    bitlen = (unsigned)rpsi->rpsi_bit_len + 16;\n    padlen = (32 - (bitlen % 32)) % 32;\n    len = (3 + (bitlen+padlen)/32) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    \n    hdr = (pjmedia_rtcp_fb_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));\n    hdr->rtcp_common.pt = RTCP_PSFB;\n    hdr->rtcp_common.count = 3; \n    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    \n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    \n    *p++ = (pj_uint8_t)padlen;\n    \n    *p++ = rpsi->pt & 0x7F;\n    \n    pj_memcpy(p, rpsi->rpsi.ptr, rpsi->rpsi_bit_len/8);\n    p += rpsi->rpsi_bit_len/8;\n    if (rpsi->rpsi_bit_len % 8) {\n\t*p++ = *(rpsi->rpsi.ptr + rpsi->rpsi_bit_len/8);\n    }\n    \n    if (padlen >= 8)\n\tpj_bzero(p, padlen/8);\n\n    \n    *length = len;\n\n    return PJ_SUCCESS;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsec_decrypt(uint8 * data, int length)\n{\n\tif (length <= 0)\n\t\treturn;\n\n\tif (g_sec_decrypt_use_count == 4096)\n\t{\n\t\tsec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);\n\t\trdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);\n\t\tg_sec_decrypt_use_count = 0;\n\t}\n\n\trdssl_rc4_crypt(&g_rc4_decrypt_key, data, data, length);\n\tg_sec_decrypt_use_count++;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\t\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\n\t\n\tset_current_state(TASK_TRACED);\n\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\t\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t} else {\n\t\t\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\n\t\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t\n\trecalc_sigpending_tsk(current);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int sclp_ctl_ioctl_sccb(void __user *user_area)\n{\n\tstruct sclp_ctl_sccb ctl_sccb;\n\tstruct sccb_header *sccb;\n\tint rc;\n\n\tif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\n\t\treturn -EFAULT;\n\tif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\n\t\treturn -EOPNOTSUPP;\n\tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tif (sccb->length > PAGE_SIZE || sccb->length < 8)\n\t\treturn -EINVAL;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb->length)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\trc = sclp_sync_request(ctl_sccb.cmdw, sccb);\n\tif (rc)\n\t\tgoto out_free;\n\tif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\n\t\trc = -EFAULT;\nout_free:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void __lo_release(struct loop_device *lo)\n{\n\tint err;\n\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\t\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\t\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void Compute(OpKernelContext* context) override {\n    const Tensor& splits = context->input(0);\n    const Tensor& values = context->input(1);\n    const Tensor& weights = context->input(2);\n    bool use_weights = weights.NumElements() > 0;\n    bool is_1d = false;\n\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == values.shape(),\n          errors::InvalidArgument(\n              \"Weights and values must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; values shape: \", values.shape().DebugString()));\n    }\n\n    const auto splits_values = splits.flat<int64>();\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    int num_batches = splits.NumElements() - 1;\n    int num_values = values.NumElements();\n\n    OP_REQUIRES(\n        context, num_batches > 0,\n        errors::InvalidArgument(\n            \"Must provide at least 2 elements for the splits argument\"));\n    OP_REQUIRES(context, splits_values(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits_values(0)));\n    OP_REQUIRES(context, splits_values(num_batches) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits_values(num_batches), \" instead of \", num_values));\n\n    auto per_batch_counts = BatchedMap<W>(num_batches);\n    T max_value = 0;\n    int batch_idx = 0;\n\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits_values(batch_idx)) {\n        batch_idx++;\n      }\n      const auto& value = values_values(idx);\n      if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch_idx - 1][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch_idx - 1][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch_idx - 1][value]++;\n        }\n        if (value > max_value) {\n          max_value = value;\n        }\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n\tvoid On005Numeric(std::map<std::string, std::string>& tokens) CXX11_OVERRIDE\n\t{\n\t\ttokens[\"ESILENCE\"] = \"CcdiNnPpsTtx\";\n\t\ttokens[\"SILENCE\"] = ConvToStr(cmd.maxsilence);\n\t}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n    CharArray(size_t len) {\n      buf = new char[len]();\n    }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Rfft2dHelper(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const float* input_data = GetTensorData<float>(input);\n  const TfLiteTensor* fft_length;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kFftLengthTensor, &fft_length));\n  const int32_t* fft_length_data = GetTensorData<int32_t>(fft_length);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  complex<float>* output_data = GetTensorData<complex<float>>(output);\n\n  int fft_height, fft_width;\n  fft_height = fft_length_data[0];\n  fft_width = fft_length_data[1];\n\n    const RuntimeShape input_shape = GetTensorShape(input);\n  const int input_dims_count = input_shape.DimensionsCount();\n  const auto* input_dims_data = input_shape.DimsData();\n  int num_slices = 1;\n  for (int i = 0; i < input_dims_count - 2; ++i) {\n    num_slices *= input_dims_data[i];\n  }\n\n  int input_height = input_dims_data[input_dims_count - 2];\n  int input_width = input_dims_data[input_dims_count - 1];\n  int input_slice_size = input_height * input_width;\n  int output_slice_size = fft_height * (fft_width / 2 + 1);\n\n   double** fft_input_output = new double*[fft_height];\n  for (int i = 0; i < fft_height; ++i) {\n    fft_input_output[i] = new double[fft_width + 2];\n  }\n\n   TfLiteTensor* fft_integer_working_area;\n  TF_LITE_ENSURE_OK(\n      context, GetTemporarySafe(context, node, kFftIntegerWorkingAreaTensor,\n                                &fft_integer_working_area));\n  int* fft_integer_working_area_data =\n      GetTensorData<int>(fft_integer_working_area);\n\n   TfLiteTensor* fft_double_working_area;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, kFftDoubleWorkingAreaTensor,\n                                     &fft_double_working_area));\n   double* fft_double_working_area_data = reinterpret_cast<double*>(\n      GetTensorData<int64_t>(fft_double_working_area));\n\n   for (int i = 0; i < num_slices; ++i) {\n    PrepareInputBuffer(input_data, input_height, input_width, fft_height,\n                       fft_width, fft_input_output);\n    memset(fft_integer_working_area_data, 0, fft_integer_working_area->bytes);\n    memset(fft_double_working_area_data, 0, fft_double_working_area->bytes);\n    Rfft2dImpl(fft_height, fft_width, fft_input_output,\n               fft_integer_working_area_data, fft_double_working_area_data);\n    PrepareOutputBuffer(output_data, fft_height, fft_width, fft_input_output);\n    input_data += input_slice_size;\n    output_data += output_slice_size;\n  }\n\n   for (int i = 0; i < fft_height; ++i) {\n    delete[] fft_input_output[i];\n  }\n  delete[] fft_input_output;\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct sock *other = NULL;\n\tint err, size;\n\tstruct sk_buff *skb;\n\tint sent = 0;\n\tstruct scm_cookie tmp_scm;\n\tbool fds_sent = false;\n\tint max_level;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\twait_for_unix_gc();\n\terr = scm_send(sock, msg, siocb->scm, false);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out_err;\n\n\tif (msg->msg_namelen) {\n\t\terr = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;\n\t\tgoto out_err;\n\t} else {\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer(sk);\n\t\tif (!other)\n\t\t\tgoto out_err;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto pipe_err;\n\n\twhile (sent < len) {\n\t\t\n\n\t\tsize = len-sent;\n\n\t\t\n\t\tif (size > ((sk->sk_sndbuf >> 1) - 64))\n\t\t\tsize = (sk->sk_sndbuf >> 1) - 64;\n\n\t\tif (size > SKB_MAX_ALLOC)\n\t\t\tsize = SKB_MAX_ALLOC;\n\n\t\t\n\n\t\tskb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT,\n\t\t\t\t\t  &err);\n\n\t\tif (skb == NULL)\n\t\t\tgoto out_err;\n\n\t\t\n\t\tsize = min_t(int, size, skb_tailroom(skb));\n\n\n\t\t\n\t\terr = unix_scm_to_skb(siocb->scm, skb, !fds_sent);\n\t\tif (err < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\t\tmax_level = err + 1;\n\t\tfds_sent = true;\n\n\t\terr = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);\n\t\tif (err) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tunix_state_lock(other);\n\n\t\tif (sock_flag(other, SOCK_DEAD) ||\n\t\t    (other->sk_shutdown & RCV_SHUTDOWN))\n\t\t\tgoto pipe_err_free;\n\n\t\tmaybe_add_creds(skb, sock, other);\n\t\tskb_queue_tail(&other->sk_receive_queue, skb);\n\t\tif (max_level > unix_sk(other)->recursion_level)\n\t\t\tunix_sk(other)->recursion_level = max_level;\n\t\tunix_state_unlock(other);\n\t\tother->sk_data_ready(other, size);\n\t\tsent += size;\n\t}\n\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\n\treturn sent;\n\npipe_err_free:\n\tunix_state_unlock(other);\n\tkfree_skb(skb);\npipe_err:\n\tif (sent == 0 && !(msg->msg_flags&MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE, current, 0);\n\terr = -EPIPE;\nout_err:\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\treturn sent ? : err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)\n{\n\tu32 i, j;\n\ts32 vps_id;\n\tVVC_VPS *vps;\n\tBool vps_default_ptl_dpb_hrd_max_tid_flag=0;\n\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) return -1;\n\tif (!vps_id) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] VPS ID 0 is forbidden\\n\"));\n\t\treturn -1;\n\t}\n\tvps = &vvc->vps[vps_id];\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers\");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;\n\n\tif ((vps->max_layers>1) && (vps->max_sub_layers>1))\n\t\tvps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, \"vps_default_ptl_dpb_hrd_max_tid_flag\");\n\n\tif (vps->max_layers>1)\n\t\tvps->all_layers_independent = gf_bs_read_int_log(bs, 1, \"all_layers_independent\");\n\n\tfor (i=0; i<vps->max_layers; i++) {\n\t\tu32 layer_id = gf_bs_read_int_log_idx(bs, 6, \"layer_id\", i);\n\t\tif (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id;\n\t\tif (i && !vps->all_layers_independent) {\n\t\t\tBool layer_indep = gf_bs_read_int_log_idx(bs, 1, \"layer_independent\", i);\n\t\t\tif (!layer_indep) {\n\t\t\t\tBool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_max_tid_ref_present_flag\", i);\n\t\t\t\tfor (j=0; j<i; j++) {\n\t\t\t\t\tBool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, \"vps_direct_ref_layer_flag\", i, j);\n\t\t\t\t\tif (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"vps_max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvps->num_ptl = 1;\n\tif (vps->max_layers > 1) {\n\t\tif (vps->all_layers_independent) {\n\t\t\tvps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, \"each_layer_is_ols\");\n\t\t}\n\t\tif (!vps->each_layer_is_ols) {\n\t\t\tu32 vps_ols_mode_idc = 2;\n\t\t\tif (!vps->all_layers_independent) {\n\t\t\t\tvps_ols_mode_idc = gf_bs_read_int_log(bs, 2, \"vps_ols_mode_idc\");\n\t\t\t}\n\t\t\tif (vps_ols_mode_idc==2) {\n\t\t\t\tu8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, \"vps_num_output_layer_sets_minus2\");\n\t\t\t\tfor (i=0; i<vps_num_output_layer_sets; i++) {\n\t\t\t\t\tfor (j=0; j<vps->max_layers; j++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 1, \"vps_ols_output_layer_flag\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, \"num_ptl_minus1\");\n\t}\n\tvps->ptl[0].pt_present = 1;\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tif (i)\n\t\t\tvps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, \"pt_present\", i);\n\t\tif (!vps_default_ptl_dpb_hrd_max_tid_flag)\n\t\t\tvps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, \"ptl_max_tid\", i);\n\t\telse\n\t\t\tvps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1;;\n\t}\n\tgf_bs_align(bs);\n\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tvvc_profile_tier_level(bs, &vps->ptl[i], i);\n\t}\n\n\treturn vps_id;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC mask;\n  BITCODE_UMC value;\n\n  value = val;\n  mask = 0x0000007f;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstruct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tstruct name_snapshot old_name;\n\n\ttrap = lock_rename(new_dir, old_dir);\n\t\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\t\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\t\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\n\ttake_dentry_name_snapshot(&old_name, old_dentry);\n\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\trelease_dentry_name_snapshot(&old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name.name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\trelease_dentry_name_snapshot(&old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint MSADPCM::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n{\n\tms_adpcm_state decoderState[2];\n\tms_adpcm_state *state[2];\n\n\tint channelCount = m_track->f.channelCount;\n\n\tint outputLength = m_framesPerPacket * sizeof (int16_t) * channelCount;\n\n\tstate[0] = &decoderState[0];\n\tif (channelCount == 2)\n\t\tstate[1] = &decoderState[1];\n\telse\n\t\tstate[1] = &decoderState[0];\n\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->predictorIndex = *encoded++;\n\t\tassert(state[i]->predictorIndex < m_numCoefficients);\n\t}\n\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample2;\n\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample1;\n\n\t\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code;\n\t\tint16_t newSample;\n\n\t\tcode = *encoded >> 4;\n\t\tnewSample = decodeSample(*state[0], code, coefficient[0]);\n\t\t*decoded++ = newSample;\n\n\t\tcode = *encoded & 0x0f;\n\t\tnewSample = decodeSample(*state[1], code, coefficient[1]);\n\t\t*decoded++ = newSample;\n\n\t\tencoded++;\n\t\tsamplesRemaining -= 2;\n\t}\n\n\treturn outputLength;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nkrb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    \n    krb5_clear_error_message(context);\n\n    \n    if (pol_dn == NULL)\n        return EINVAL;\n\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n\n    LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n\n    ent=ldap_first_entry(ld, result);\n    if (ent != NULL) {\n        if ((st = populate_policy(context, ld, ent, pol_name, *policy)) != 0)\n            goto cleanup;\n    }\n\ncleanup:\n    ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nrdpsnd_process_training(STREAM in)\n{\n\tuint16 tick;\n\tuint16 packsize;\n\tSTREAM out;\n\tstruct stream packet = *in;\n\n\tif (!s_check_rem(in, 4))\n\t{\n\t\trdp_protocol_error(\"rdpsnd_process_training(), consume of training data from stream would overrun\", &packet);\n\t}\n\n\tin_uint16_le(in, tick);\n\tin_uint16_le(in, packsize);\n\n\tlogger(Sound, Debug, \"rdpsnd_process_training(), tick=0x%04x\", (unsigned) tick);\n\n\tout = rdpsnd_init_packet(SNDC_TRAINING, 4);\n\tout_uint16_le(out, tick);\n\tout_uint16_le(out, packsize);\n\ts_mark_end(out);\n\trdpsnd_send(out);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_for_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    \n    return ast_for_funcdef_impl(c, n, decorator_seq,\n                                false );\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n{\n\tstruct au1100fb_device *fbdev;\n\n\tfbdev = to_au1100fb_device(fbi);\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= (6 << 9);\n\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nStatus TransposeShapeFn(InferenceContext* c) {\n  ShapeHandle input = c->input(0);\n  ShapeHandle perm_shape = c->input(1);\n  const Tensor* perm = c->input_tensor(1);\n  DimensionHandle perm_elems = c->NumElements(perm_shape);\n     if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {\n    c->set_output(0, c->UnknownShape());\n    return Status::OK();\n  }\n\n   int64_t rank;\n  if (c->RankKnown(input)) {\n    rank = c->Rank(input);\n  } else if (c->ValueKnown(perm_elems)) {\n    rank = c->Value(perm_elems);\n  } else {\n    rank = perm->NumElements();\n  }\n  if (!c->RankKnown(input) && rank < 2) {\n             c->set_output(0, input);\n    return Status::OK();\n  }\n\n  std::vector<DimensionHandle> dims;\n  dims.resize(rank);\n  TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));\n   TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));\n  TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));\n\n     if (perm != nullptr) {\n    std::vector<int64_t> data;\n    if (perm->dtype() == DT_INT32) {\n      data = AsInt64<int32>(perm, rank);\n    } else {\n      data = AsInt64<int64_t>(perm, rank);\n    }\n\n    for (int32_t i = 0; i < rank; ++i) {\n      int64_t in_idx = data[i];\n      if (in_idx >= rank || in_idx <= -rank) {\n        return errors::InvalidArgument(\"perm dim \", in_idx,\n                                       \" is out of range of input rank \", rank);\n      }\n      dims[i] = c->Dim(input, in_idx);\n    }\n  } else {\n    for (int i = 0; i < rank; ++i) {\n      dims[i] = c->UnknownDim();\n    }\n  }\n\n  c->set_output(0, c->MakeShape(dims));\n  return Status::OK();\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  \n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \"alignment %d is not a power of 2\", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \"invalid format option '%c'\", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tstruct sockaddr_ipx *sipx = (struct sockaddr_ipx *)msg->msg_name;\n\tstruct ipxhdr *ipx = NULL;\n\tstruct sk_buff *skb;\n\tint copied, rc;\n\n\tlock_sock(sk);\n\t\n\tif (!ipxs->port) {\n\t\tstruct sockaddr_ipx uaddr;\n\n\t\tuaddr.sipx_port\t\t= 0;\n\t\tuaddr.sipx_network \t= 0;\n\n#ifdef CONFIG_IPX_INTERN\n\t\trc = -ENETDOWN;\n\t\tif (!ipxs->intrfc)\n\t\t\tgoto out; \n\t\tmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node, IPX_NODE_LEN);\n#endif\t\n\n\t\trc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\n\t\t\t      sizeof(struct sockaddr_ipx));\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb)\n\t\tgoto out;\n\n\tipx \t= ipx_hdr(skb);\n\tcopied \t= ntohs(ipx->ipx_pktsize) - sizeof(struct ipxhdr);\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\trc = skb_copy_datagram_iovec(skb, sizeof(struct ipxhdr), msg->msg_iov,\n\t\t\t\t     copied);\n\tif (rc)\n\t\tgoto out_free;\n\tif (skb->tstamp.tv64)\n\t\tsk->sk_stamp = skb->tstamp;\n\n\tif (sipx) {\n\t\tsipx->sipx_family\t= AF_IPX;\n\t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n\t\tmemcpy(sipx->sipx_node, ipx->ipx_source.node, IPX_NODE_LEN);\n\t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n\t\tsipx->sipx_type \t= ipx->ipx_type;\n\t\tsipx->sipx_zero\t\t= 0;\n\t\tmsg->msg_namelen\t= sizeof(*sipx);\n\t}\n\trc = copied;\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  ~MarkPopErrorOnReturn() { ERR_pop_to_mark(); }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,\n\t\t    struct cmsghdr *cmsg)\n{\n\tstruct page *page = NULL;\n\tstruct rds_atomic_args *args;\n\tint ret = 0;\n\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args))\n\t || rm->atomic.op_active)\n\t\treturn -EINVAL;\n\n\targs = CMSG_DATA(cmsg);\n\n\t\n\tswitch (cmsg->cmsg_type) {\n\tcase RDS_CMSG_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = 0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->m_fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask;\n\t\tbreak;\n\tcase RDS_CMSG_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = ~0;\n\t\trm->atomic.op_m_cswp.swap_mask = ~0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->m_cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->m_cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask;\n\t\trm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask;\n\t\tbreak;\n\tdefault:\n\t\tBUG(); \n\t}\n\n\trm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);\n\trm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT);\n\trm->atomic.op_active = 1;\n\trm->atomic.op_recverr = rs->rs_recverr;\n\trm->atomic.op_sg = rds_message_alloc_sgs(rm, 1);\n\tif (!rm->atomic.op_sg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t\n\tif (args->local_addr & 0x7) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tret = rds_pin_pages(args->local_addr, 1, &page, 1);\n\tif (ret != 1)\n\t\tgoto err;\n\tret = 0;\n\n\tsg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr));\n\n\tif (rm->atomic.op_notify || rm->atomic.op_recverr) {\n\t\t\n\t\trm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL);\n\t\tif (!rm->atomic.op_notifier) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\trm->atomic.op_notifier->n_user_token = args->user_token;\n\t\trm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS;\n\t}\n\n\trm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie);\n\trm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie);\n\n\treturn ret;\nerr:\n\tif (page)\n\t\tput_page(page);\n\trm->atomic.op_active = 0;\n\tkfree(rm->atomic.op_notifier);\n\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int btrfs_finish_sprout(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = fs_info->chunk_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct btrfs_device *device;\n\tstruct btrfs_key key;\n\tu8 fs_uuid[BTRFS_FSID_SIZE];\n\tu8 dev_uuid[BTRFS_UUID_SIZE];\n\tu64 devid;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tleaf = path->nodes[0];\nnext_slot:\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_DEV_ITEMS_OBJECTID ||\n\t\t    key.type != BTRFS_DEV_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tdev_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_dev_item);\n\t\tdevid = btrfs_device_id(leaf, dev_item);\n\t\tread_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tread_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),\n\t\t\t\t   BTRFS_FSID_SIZE);\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   fs_uuid, true);\n\t\tBUG_ON(!device); \n\n\t\tif (device->fs_devices->seeding) {\n\t\t\tbtrfs_set_device_generation(leaf, dev_item,\n\t\t\t\t\t\t    device->generation);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\n\t\tpath->slots[0]++;\n\t\tgoto next_slot;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nStatus PySeqToTensor(PyObject* obj, DataType dtype, Tensor* ret) {\n  ConverterState state;\n  TF_RETURN_IF_ERROR(InferShapeAndType(obj, &state));\n  DataType requested_dtype = DT_INVALID;\n  if (dtype != DT_INVALID) {\n    requested_dtype = dtype;\n  }\n      switch (requested_dtype) {\n    case DT_FLOAT:\n      if (FloatConverter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_DOUBLE:\n      if (DoubleConverter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_HALF:\n      RETURN_STRING_AS_STATUS(NumpyHalfConverter::Convert(obj, &state, ret));\n\n    case DT_INT64:\n      if (Int64Converter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_INT32:\n      if (Int32Converter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_UINT64:\n      if (UInt64Converter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_COMPLEX128:\n      if (Complex128Converter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_STRING:\n      if (StringConverter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_BOOL:\n      if (BoolConverter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    default:\n      break;\n  }\n  switch (state.inferred_dtype) {\n    case DT_FLOAT:\n           if (requested_dtype == DT_INVALID) {\n                      RETURN_STRING_AS_STATUS(FloatConverter::Convert(obj, &state, ret));\n      } else {\n                                    RETURN_STRING_AS_STATUS(DoubleConverter::Convert(obj, &state, ret));\n      }\n\n    case DT_DOUBLE:\n      RETURN_STRING_AS_STATUS(DoubleConverter::Convert(obj, &state, ret));\n\n    case DT_HALF:\n      RETURN_STRING_AS_STATUS(NumpyHalfConverter::Convert(obj, &state, ret));\n\n    case DT_INT64:\n      if (requested_dtype == DT_INVALID) {\n        const char* error = Int32Converter::Convert(obj, &state, ret);\n        if (error == ErrorFoundInt64) {\n          error = Int64Converter::Convert(obj, &state, ret);\n        }\n        if (error == ErrorFoundFloat) {\n          error = FloatConverter::Convert(obj, &state, ret);\n        }\n                      RETURN_STRING_AS_STATUS(error);\n      } else {\n        const char* error = Int64Converter::Convert(obj, &state, ret);\n        if (error == ErrorFoundFloat) {\n          error = DoubleConverter::Convert(obj, &state, ret);\n        }\n        RETURN_STRING_AS_STATUS(error);\n      }\n\n    case DT_STRING:\n      RETURN_STRING_AS_STATUS(StringConverter::Convert(obj, &state, ret));\n\n    case DT_COMPLEX128:\n      RETURN_STRING_AS_STATUS(Complex128Converter::Convert(obj, &state, ret));\n\n    case DT_BOOL:\n      RETURN_STRING_AS_STATUS(BoolConverter::Convert(obj, &state, ret));\n\n    case DT_INVALID:       *ret = Tensor(requested_dtype == DT_INVALID ? DT_FLOAT : requested_dtype,\n                    state.inferred_shape);\n      return Status::OK();\n\n    default:\n      return errors::Unimplemented(\"Missing Python -> Tensor conversion for \",\n                                   DataTypeString(state.inferred_dtype));\n  }\n\n  return Status::OK();\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ngrub_disk_read (grub_disk_t disk, grub_disk_addr_t sector,\n\t\tgrub_off_t offset, grub_size_t size, void *buf)\n{\n  char *tmp_buf;\n  unsigned real_offset;\n\n  \n  if (grub_disk_adjust_range (disk, &sector, &offset, size) != GRUB_ERR_NONE)\n    {\n      grub_error_push ();\n      grub_dprintf (\"disk\", \"Read out of range: sector 0x%llx (%s).\\n\",\n\t\t    (unsigned long long) sector, grub_errmsg);\n      grub_error_pop ();\n      return grub_errno;\n    }\n\n  real_offset = offset;\n\n  \n  tmp_buf = grub_malloc (GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS);\n  if (! tmp_buf)\n    return grub_errno;\n\n  \n  while (size)\n    {\n      char *data;\n      grub_disk_addr_t start_sector;\n      grub_size_t len;\n      grub_size_t pos;\n\n      \n      start_sector = sector & ~(GRUB_DISK_CACHE_SIZE - 1);\n      pos = (sector - start_sector) << GRUB_DISK_SECTOR_BITS;\n      len = ((GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS)\n\t     - pos - real_offset);\n      if (len > size)\n\tlen = size;\n\n      \n      data = grub_disk_cache_fetch (disk->dev->id, disk->id, start_sector);\n      if (data)\n\t{\n\t  \n\t  if (buf) {\n\t    if (pos + real_offset + len >= size) {\n                           grub_errno = GRUB_ERR_BAD_FS;\n              return grub_errno;\n\t    }\n\t    grub_memcpy (buf, data + pos + real_offset, len);\n          }\n\t  grub_disk_cache_unlock (disk->dev->id, disk->id, start_sector);\n\t}\n      else\n\t{\n\t  \n\t  if (start_sector + GRUB_DISK_CACHE_SIZE > disk->total_sectors\n\t      || (disk->dev->read) (disk, start_sector,\n\t\t\t\t    GRUB_DISK_CACHE_SIZE, tmp_buf)\n\t      != GRUB_ERR_NONE)\n\t    {\n\t      \n\t      unsigned num;\n\t      char *p;\n\n\t      grub_errno = GRUB_ERR_NONE;\n\n\t      num = ((size + real_offset + GRUB_DISK_SECTOR_SIZE - 1)\n\t\t     >> GRUB_DISK_SECTOR_BITS);\n\n\t      p = grub_realloc (tmp_buf, num << GRUB_DISK_SECTOR_BITS);\n\t      if (!p)\n\t\tgoto finish;\n\n\t      tmp_buf = p;\n\n\t      if ((disk->dev->read) (disk, sector, num, tmp_buf))\n\t\t{\n\t\t  grub_error_push ();\n\t\t  grub_dprintf (\"disk\", \"%s read failed\\n\", disk->name);\n\t\t  grub_error_pop ();\n\t\t  goto finish;\n\t\t}\n\n\t      if (buf)\n\t\tgrub_memcpy (buf, tmp_buf + real_offset, size);\n\n\t      \n\t      if (disk->read_hook)\n\t\twhile (size)\n\t\t  {\n\t\t    grub_size_t to_read;\n\n\t\t    to_read = size;\n\t\t    if (real_offset + to_read > GRUB_DISK_SECTOR_SIZE)\n\t\t      to_read = GRUB_DISK_SECTOR_SIZE - real_offset;\n\t\t    (disk->read_hook) (sector, real_offset,\n\t\t\t\t       to_read, disk->closure);\n\t\t    if (grub_errno != GRUB_ERR_NONE)\n\t\t      goto finish;\n\n\t\t    sector++;\n\t\t    size -= to_read;\n\t\t    real_offset = 0;\n\t\t  }\n\n\t      \n\t      goto finish;\n\t    }\n\n\t  \n\t  if (buf)\n\t    grub_memcpy (buf, tmp_buf + pos + real_offset, len);\n\t  grub_disk_cache_store (disk->dev->id, disk->id,\n\t\t\t\t start_sector, tmp_buf);\n\t}\n\n      \n      if (disk->read_hook)\n\t{\n\t  grub_disk_addr_t s = sector;\n\t  grub_size_t l = len;\n\n\t  while (l)\n\t    {\n\t      (disk->read_hook) (s, real_offset,\n\t\t\t\t ((l > GRUB_DISK_SECTOR_SIZE)\n\t\t\t\t  ? GRUB_DISK_SECTOR_SIZE\n\t\t\t\t  : l), disk->closure);\n\n\t      if (l < GRUB_DISK_SECTOR_SIZE - real_offset)\n\t\tbreak;\n\n\t      s++;\n\t      l -= GRUB_DISK_SECTOR_SIZE - real_offset;\n\t      real_offset = 0;\n\t    }\n\t}\n\n      sector = start_sector + GRUB_DISK_CACHE_SIZE;\n      if (buf)\n\tbuf = (char *) buf + len;\n      size -= len;\n      real_offset = 0;\n    }\n\n finish:\n\n  grub_free (tmp_buf);\n\n  return grub_errno;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ndo_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tunsigned char arg[128];\n\tint ret = 0;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (*len < get_arglen[GET_CMDID(cmd)]) {\n\t\tpr_err(\"get_ctl: len %u < %u\\n\",\n\t\t       *len, get_arglen[GET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, get_arglen[GET_CMDID(cmd)]) != 0)\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nchar *QuotedString::extractFrom(char *input, char **endPtr) {\n  char *startPtr = input + 1;   char *readPtr = startPtr;\n  char *writePtr = startPtr;\n  char c;\n\n  char firstChar = *input;\n  char stopChar = firstChar; \n  if (!isQuote(firstChar)) goto ERROR_OPENING_QUOTE_MISSING;\n\n  for (;;) {\n    c = *readPtr++;\n\n    if (c == '\\0') goto ERROR_CLOSING_QUOTE_MISSING;\n\n    if (c == stopChar) goto SUCCESS;\n\n    if (c == '\\\\') {\n           c = unescapeChar(*readPtr++);\n      if (c == '\\0') goto ERROR_ESCAPE_SEQUENCE_INTERRUPTED;\n    }\n\n    *writePtr++ = c;\n  }\n\nSUCCESS:\n   *writePtr = '\\0';\n\n   *endPtr = readPtr;\n\n   return startPtr;\n\nERROR_OPENING_QUOTE_MISSING:\nERROR_CLOSING_QUOTE_MISSING:\nERROR_ESCAPE_SEQUENCE_INTERRUPTED:\n  return NULL;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nber_parse_header(STREAM s, int tagval, int *length)\n{\n\tint tag, len;\n\n\tif (tagval > 0xff)\n\t{\n\t\tin_uint16_be(s, tag);\n\t}\n\telse\n\t{\n\t\tin_uint8(s, tag);\n\t}\n\n\tif (tag != tagval)\n\t{\n\t\tlogger(Core, Error, \"ber_parse_header(), expected tag %d, got %d\", tagval, tag);\n\t\treturn False;\n\t}\n\n\tin_uint8(s, len);\n\n\tif (len & 0x80)\n\t{\n\t\tlen &= ~0x80;\n\t\t*length = 0;\n\t\twhile (len--)\n\t\t\tnext_be(s, *length);\n\t}\n\telse\n\t\t*length = len;\n\n\treturn s_check(s);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nGF_Err gf_sm_load_init(GF_SceneLoader *load)\n{\n\tGF_Err e = GF_NOT_SUPPORTED;\n\tchar *ext, szExt[50];\n\t\n\tif (!load || (!load->ctx && !load->scene_graph)\n#ifndef GPAC_DISABLE_ISOM\n\t        || (!load->fileName && !load->isom && !(load->flags & GF_SM_LOAD_FOR_PLAYBACK) )\n#endif\n\t   ) return GF_BAD_PARAM;\n\n\tif (!load->type) {\n#ifndef GPAC_DISABLE_ISOM\n\t\tif (load->isom) {\n\t\t\tload->type = GF_SM_LOAD_MP4;\n\t\t} else\n#endif\n\t\t{\n\t\t\text = (char *)strrchr(load->fileName, '.');\n\t\t\tif (!ext) return GF_NOT_SUPPORTED;\n\t\t\tif (!stricmp(ext, \".gz\")) {\n\t\t\t\tchar *anext;\n\t\t\t\text[0] = 0;\n\t\t\t\tanext = (char *)strrchr(load->fileName, '.');\n\t\t\t\text[0] = '.';\n\t\t\t\text = anext;\n\t\t\t}\n\t\t\tif (strlen(ext) < 2 || strlen(ext) > sizeof(szExt)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scene Manager] invalid extension in file name %s\\n\", load->fileName));\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t}\n\t\t\tstrcpy(szExt, &ext[1]);\n\t\t\tstrlwr(szExt);\n\t\t\tif (strstr(szExt, \"bt\")) load->type = GF_SM_LOAD_BT;\n\t\t\telse if (strstr(szExt, \"wrl\")) load->type = GF_SM_LOAD_VRML;\n\t\t\telse if (strstr(szExt, \"x3dv\")) load->type = GF_SM_LOAD_X3DV;\n#ifndef GPAC_DISABLE_LOADER_XMT\n\t\t\telse if (strstr(szExt, \"xmt\") || strstr(szExt, \"xmta\")) load->type = GF_SM_LOAD_XMTA;\n\t\t\telse if (strstr(szExt, \"x3d\")) load->type = GF_SM_LOAD_X3D;\n#endif\n\t\t\telse if (strstr(szExt, \"swf\")) load->type = GF_SM_LOAD_SWF;\n\t\t\telse if (strstr(szExt, \"mov\")) load->type = GF_SM_LOAD_QT;\n\t\t\telse if (strstr(szExt, \"svg\")) load->type = GF_SM_LOAD_SVG;\n\t\t\telse if (strstr(szExt, \"xsr\")) load->type = GF_SM_LOAD_XSR;\n\t\t\telse if (strstr(szExt, \"xbl\")) load->type = GF_SM_LOAD_XBL;\n\t\t\telse if (strstr(szExt, \"xml\")) {\n\t\t\t\tchar *rtype = gf_xml_get_root_type(load->fileName, &e);\n\t\t\t\tif (rtype) {\n\t\t\t\t\tif (!strcmp(rtype, \"SAFSession\")) load->type = GF_SM_LOAD_XSR;\n\t\t\t\t\telse if (!strcmp(rtype, \"XMT-A\")) load->type = GF_SM_LOAD_XMTA;\n\t\t\t\t\telse if (!strcmp(rtype, \"X3D\")) load->type = GF_SM_LOAD_X3D;\n\t\t\t\t\telse if (!strcmp(rtype, \"bindings\")) load->type = GF_SM_LOAD_XBL;\n\n\t\t\t\t\tgf_free(rtype);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!load->type) return e;\n\n\tif (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;\n\n\tswitch (load->type) {\n#ifndef GPAC_DISABLE_LOADER_BT\n\tcase GF_SM_LOAD_BT:\n\tcase GF_SM_LOAD_VRML:\n\tcase GF_SM_LOAD_X3DV:\n\t\treturn gf_sm_load_init_bt(load);\n#endif\n\n#ifndef GPAC_DISABLE_LOADER_XMT\n\tcase GF_SM_LOAD_XMTA:\n\tcase GF_SM_LOAD_X3D:\n\t\treturn gf_sm_load_init_xmt(load);\n#endif\n\n#ifndef GPAC_DISABLE_SVG\n\tcase GF_SM_LOAD_SVG:\n\tcase GF_SM_LOAD_XSR:\n\tcase GF_SM_LOAD_DIMS:\n\t\treturn gf_sm_load_init_svg(load);\n\n\tcase GF_SM_LOAD_XBL:\n\t\te = gf_sm_load_init_xbl(load);\n\n\t\tload->process = gf_sm_load_run_xbl;\n\t\tload->done = gf_sm_load_done_xbl;\n\t\treturn e;\n#endif\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\tcase GF_SM_LOAD_SWF:\n\t\treturn gf_sm_load_init_swf(load);\n#endif\n\n#ifndef GPAC_DISABLE_LOADER_ISOM\n\tcase GF_SM_LOAD_MP4:\n\t\treturn gf_sm_load_init_isom(load);\n#endif\n\n#ifndef GPAC_DISABLE_QTVR\n\tcase GF_SM_LOAD_QT:\n\t\treturn gf_sm_load_init_qt(load);\n#endif\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\treturn GF_NOT_SUPPORTED;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tsize_t n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tsize_t newbufsize;\n\tsize_t newpos;\n\n\tassert(buf);\n\tassert(cnt >= 0);\n\n\tJAS_DBGLOG(100, (\"mem_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\t\t\tif (!jas_safe_size_mul(newbufsize, 2, &newbufsize)) {\n\t\t\t\tJAS_DBGLOG(100, (\"new buffer size would cause overflow\\n\"));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %zu\\n\", m->bufsize_,\n\t\t  newbufsize));\n\t\tassert(newbufsize > 0);\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\t\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_list_destroy(&perm->classperms, CIL_FALSE);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nnet_bind(short unsigned *port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  union net_sockaddr naddr = { 0 };\n  socklen_t naddr_len = sizeof(naddr);\n  const char *cfgaddr;\n  char addr[INET6_ADDRSTRLEN];\n  char strport[8];\n  int yes = 1;\n  int no = 0;\n  int fd;\n  int ret;\n\n  cfgaddr = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n\n  hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM));  hints.ai_family = (cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\")) ? AF_INET6 : AF_INET;\n  hints.ai_flags = cfgaddr ? 0 : AI_PASSIVE;\n\n  snprintf(strport, sizeof(strport), \"%hu\", *port);\n  ret = getaddrinfo(cfgaddr, strport, &hints, &servinfo);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Failure creating '%s' service, could not resolve '%s' (port %s): %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", strport, gai_strerror(ret));\n      return -1;\n    }\n\n  for (ptr = servinfo, fd = -1; ptr != NULL; ptr = ptr->ai_next)\n    {\n      if (fd >= 0)\n\tclose(fd);\n\n      fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol);\n      if (fd < 0)\n\tcontinue;\n\n           ret = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes));\n      if (ret < 0)\n\tcontinue;\n\n      ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n      if (ret < 0)\n\tcontinue;\n\n      if (ptr->ai_family == AF_INET6)\n\t{\n\t \t  ret = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &no, sizeof(no));\n\t  if (ret < 0)\n\t    continue;\n\t}\n\n      ret = bind(fd, ptr->ai_addr, ptr->ai_addrlen);\n      if (ret < 0)\n\tcontinue;\n\n      break;\n    }\n\n  freeaddrinfo(servinfo);\n\n  if (!ptr)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));\n      goto error;\n    }\n\n    ret = getsockname(fd, &naddr.sa, &naddr_len);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Error finding address of service '%s': %s\\n\", log_service_name, strerror(errno));\n      goto error;\n    }\n  else if (naddr_len > sizeof(naddr))\n    {\n      DPRINTF(E_LOG, L_MISC, \"Unexpected address length of service '%s'\\n\", log_service_name);\n      goto error;\n    }\n\n  net_port_get(port, &naddr);\n  net_address_get(addr, sizeof(addr), &naddr);\n\n  DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);\n\n  return fd;\n\n error:\n  close(fd);\n  return -1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int msg_flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tlong timeo;\n\tint ret = 0, nonblock = msg_flags & MSG_DONTWAIT;\n\tstruct sockaddr_in *sin;\n\tstruct rds_incoming *inc = NULL;\n\n\t\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n\n\trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n\n\tmsg->msg_namelen = 0;\n\n\tif (msg_flags & MSG_OOB)\n\t\tgoto out;\n\n\twhile (1) {\n\t\t\n\t\tif (!list_empty(&rs->rs_notify_queue)) {\n\t\t\tret = rds_notify_queue_get(rs, msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rs->rs_cong_notify) {\n\t\t\tret = rds_notify_cong(rs, msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rds_next_incoming(rs, &inc)) {\n\t\t\tif (nonblock) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\t(!list_empty(&rs->rs_notify_queue) ||\n\t\t\t\t\t rs->rs_cong_notify ||\n\t\t\t\t\t rds_next_incoming(rs, &inc)), timeo);\n\t\t\trdsdebug(\"recvmsg woke inc %p timeo %ld\\n\", inc,\n\t\t\t\t timeo);\n\t\t\tif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\n\t\t\t\tcontinue;\n\n\t\t\tret = timeo;\n\t\t\tif (ret == 0)\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\trdsdebug(\"copying inc %p from %pI4:%u to user\\n\", inc,\n\t\t\t &inc->i_conn->c_faddr,\n\t\t\t ntohs(inc->i_hdr.h_sport));\n\t\tret = inc->i_conn->c_trans->inc_copy_to_user(inc, msg->msg_iov,\n\t\t\t\t\t\t\t     size);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t\n\t\tif (!rds_still_queued(rs, inc, !(msg_flags & MSG_PEEK))) {\n\t\t\trds_inc_put(inc);\n\t\t\tinc = NULL;\n\t\t\trds_stats_inc(s_recv_deliver_raced);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret < be32_to_cpu(inc->i_hdr.h_len)) {\n\t\t\tif (msg_flags & MSG_TRUNC)\n\t\t\t\tret = be32_to_cpu(inc->i_hdr.h_len);\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\t}\n\n\t\tif (rds_cmsg_recv(inc, msg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\trds_stats_inc(s_recv_delivered);\n\n\t\tsin = (struct sockaddr_in *)msg->msg_name;\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n\t\t\tsin->sin_port = inc->i_hdr.h_sport;\n\t\t\tsin->sin_addr.s_addr = inc->i_saddr;\n\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t\tmsg->msg_namelen = sizeof(*sin);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (inc)\n\t\trds_inc_put(inc);\n\nout:\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\t\n\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n\t\treturn -EINVAL;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\t\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\n\t\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nMONGO_EXPORT int bson_iterator_int( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nCAMLprim value caml_alloc_dummy(value size)\n{\n  mlsize_t wosize = Int_val(size);\n\n  if (wosize == 0) return Atom(0);\n  return caml_alloc (wosize, 0);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringView data = attributes.value(QLatin1String(\"d\"));\n\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    if (!parsePathDataFast(data, qpath))\n        qCWarning(lcSvgHandler, \"Invalid path data; path truncated.\");\n\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, oidc_util_javascript_escape(r->pool, original_url));\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid trustedDkgVerifyAES(int *errStatus, char *errString, const char *public_shares, const char *s_share,\n                         uint8_t *encryptedPrivateKey, uint64_t enc_len, unsigned _t, int _ind, int *result) {\n    LOG_INFO(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(public_shares);\n    CHECK_STATE(s_share);\n    CHECK_STATE(encryptedPrivateKey);\n\n    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n    mpz_t s;\n    mpz_init(s);\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n\n    CHECK_STATUS2(\"AES_decrypt failed (in trustedDkgVerifyAES) with status %d\");\n\n    SAFE_CHAR_BUF(encr_sshare, ECDSA_SKEY_LEN);\n\n    strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1);\n\n    SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);\n\n    status = session_key_recover(skey, s_share, common_key);\n\n    CHECK_STATUS(\"session_key_recover failed\");\n\n    SAFE_CHAR_BUF(decr_sshare, ECDSA_SKEY_LEN);\n\n    status=xor_decrypt(common_key, encr_sshare, decr_sshare);\n\n    CHECK_STATUS(\"xor_decrypt failed\")\n\n\n    status  = mpz_set_str(s, decr_sshare, 16);\n    CHECK_STATUS(\"invalid decr secret share\");\n\n    *result = Verification(public_shares, s, _t, _ind);\n\n    SET_SUCCESS\n    clean:\n\n    mpz_clear(s);\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tstruct net *net = sock_net(cb->skb->sk);\n\n\txfrm_policy_walk_done(walk, net);\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nl2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic INLINE BOOL zgfx_GetBits(ZGFX_CONTEXT* _zgfx, UINT32 _nbits)\n{\n\tif (!_zgfx)\n\t\treturn FALSE;\n\n\twhile (_zgfx->cBitsCurrent < _nbits)\n\t{\n\t\t_zgfx->BitsCurrent <<= 8;\n\n\t\tif (_zgfx->pbInputCurrent < _zgfx->pbInputEnd)\n\t\t\t_zgfx->BitsCurrent += *(_zgfx->pbInputCurrent)++;\n\n\t\t_zgfx->cBitsCurrent += 8;\n\t}\n\n\t_zgfx->cBitsRemaining -= _nbits;\n\t_zgfx->cBitsCurrent -= _nbits;\n\t_zgfx->bits = _zgfx->BitsCurrent >> _zgfx->cBitsCurrent;\n\t_zgfx->BitsCurrent &= ((1 << _zgfx->cBitsCurrent) - 1);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int jas_iccgetsint32(jas_stream_t *in, jas_iccsint32_t *val)\n{\n\tjas_ulonglong tmp;\n\tif (jas_iccgetuint(in, 4, &tmp))\n\t\treturn -1;\n\t*val = (tmp & 0x80000000) ? (-JAS_CAST(jas_longlong, (((~tmp) &\n\t  0x7fffffff) + 1))) : JAS_CAST(jas_longlong, tmp);\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nconst char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrcat(line, buf);\n\t\tstrcat(line, \" \");\n\t\te = e->next;\n\t}\n\tline[strlen(line)-1] = 0; \n\treturn line;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nobj2ast_type_ignore(PyObject* obj, type_ignore_ty* out, PyArena* arena)\n{\n    int isinstance;\n\n    PyObject *tmp = NULL;\n\n    if (obj == Py_None) {\n        *out = NULL;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)TypeIgnore_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        int lineno;\n\n        if (_PyObject_LookupAttrId(obj, &PyId_lineno, &tmp) < 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"required field \\\"lineno\\\" missing from TypeIgnore\");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_int(tmp, &lineno, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = TypeIgnore(lineno, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n\n    PyErr_Format(PyExc_TypeError, \"expected some sort of type_ignore, but got %R\", obj);\n    failed:\n    Py_XDECREF(tmp);\n    return 1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n\n       u32in();\n       u32in();\n       mp4config.frame.ents = u32in();\n       mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n\n        mp4config.frame.data[cnt + 1] = ofs;\n\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n\n    return size;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint main()\n{\n    check_file(\"tiff_invalid_read_1.tiff\");\n    check_file(\"tiff_invalid_read_2.tiff\");\n    check_file(\"tiff_invalid_read_3.tiff\");\n\n    return gdNumFailures();\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool Decoder::canSplitFunctionOn(\n\t\tutils::Address addr,\n\t\tllvm::BasicBlock* splitBb,\n\t\tstd::set<llvm::BasicBlock*>& newFncStarts)\n{\n\tnewFncStarts.insert(splitBb);\n\n\tauto* f = splitBb->getParent();\n\tauto fAddr = getFunctionAddress(f);\n\n\tauto fSzIt = _fnc2sz.find(f);\n\tif (fSzIt != _fnc2sz.end())\n\t{\n\t\tif (fAddr <= addr && addr < (fAddr+fSzIt->second))\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\\t\" << \"!CAN S: addr cond @ \" << addr << std::endl;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstd::set<Address> fncStarts;\n\tfncStarts.insert(fAddr);\n\tfncStarts.insert(addr);\n\n\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << fAddr << std::endl;\n\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << addr << std::endl;\n\n\tbool changed = true;\n\twhile (changed)\n\t{\n\t\tchanged = false;\n\t\tfor (BasicBlock& b : *f)\n\t\t{\t\t\tAddress bAddr;\n\t\t\t\t\tBasicBlock* bPrev = &b;\n\t\t\twhile (bAddr.isUndefined() && bPrev)\n\t\t\t{\n\t\t\t\tbAddr = getBasicBlockAddress(bPrev);\n\t\t\t\tbPrev = bPrev->getPrevNode();\n\t\t\t}\n\t\t\tif (bAddr.isUndefined())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tauto up = fncStarts.upper_bound(bAddr);\n\t\t\tif (up == fncStarts.begin()) {\n\t\t\t\treturn false;\n\t\t\t}\t\n\t\t\t--up;\n\t\t\tAddress bFnc = *up;\n\n\t\t\tfor (auto* p : predecessors(&b))\n\t\t\t{\t\t\t\tAddress pAddr;\n\t\t\t\t\t\t\tBasicBlock* pPrev = p;\n\t\t\t\twhile (pAddr.isUndefined() && pPrev)\n\t\t\t\t{\n\t\t\t\t\tpAddr = getBasicBlockAddress(pPrev);\n\t\t\t\t\tpPrev = pPrev->getPrevNode();\n\t\t\t\t}\n\t\t\t\tif (pAddr.isUndefined())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tauto up = fncStarts.upper_bound(pAddr);\n\t\t\t\tif (up == fncStarts.begin()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t--up;\n\t\t\t\tAddress pFnc = *up;\n\n\t\t\t\tif (bFnc != pFnc)\n\t\t\t\t{\n\t\t\t\t\tif (!canSplitFunctionOn(&b))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tchanged |= newFncStarts.insert(&b).second;\n\t\t\t\t\tchanged |= fncStarts.insert(bAddr).second;\n\n\t\t\t\t\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << bAddr << std::endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (sec_attr == NULL || sec_attr_len) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ncheck_vim9_unlet(char_u *name)\n{\n    if (*name == NUL)\n    {\n\tsemsg(_(e_argument_required_for_str), \"unlet\");\n\treturn FAIL;\n    }\n\n    if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)\n    {\n\tif (*name == 's' && !script_is_vim9())\n\t    return OK;\n\tsemsg(_(e_cannot_unlet_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* data = GetInput(context, node, kInputDataTensor);\n  const TfLiteTensor* segment_ids =\n      GetInput(context, node, kInputSegmentIdsTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE(context,\n                 data->type == kTfLiteInt32 || data->type == kTfLiteFloat32);\n  TF_LITE_ENSURE_EQ(context, segment_ids->type, kTfLiteInt32);\n\n  if (!IsConstantTensor(data) || !IsConstantTensor(segment_ids)) {\n    SetTensorToDynamic(output);\n    return kTfLiteOk;\n  }\n\n  return ResizeOutputTensor(context, data, segment_ids, output);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void JS_FoxxAllowInstallFromRemote(v8::FunctionCallbackInfo<v8::Value> const& args) {\n  TRI_V8_TRY_CATCH_BEGIN(isolate)\n  v8::HandleScope scope(isolate);\n\n  TRI_GET_GLOBALS();\n  ServerSecurityFeature& security = v8g->_server.getFeature<ServerSecurityFeature>();\n  TRI_V8_RETURN_BOOL(security.foxxAllowInstallFromRemote());\n\n  TRI_V8_TRY_CATCH_END\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_for_comprehension(struct compiling *c, const node *n)\n{\n    int i, n_fors;\n    asdl_seq *comps;\n\n    n_fors = count_comp_fors(c, n);\n    if (n_fors == -1)\n        return NULL;\n\n    comps = _Ta3_asdl_seq_new(n_fors, c->c_arena);\n    if (!comps)\n        return NULL;\n\n    for (i = 0; i < n_fors; i++) {\n        comprehension_ty comp;\n        asdl_seq *t;\n        expr_ty expression, first;\n        node *for_ch;\n        node *sync_n;\n        int is_async = 0;\n\n        REQ(n, comp_for);\n\n        if (NCH(n) == 2) {\n            is_async = 1;\n            REQ(CHILD(n, 0), NAME);\n            assert(strcmp(STR(CHILD(n, 0)), \"async\") == 0);\n            sync_n = CHILD(n, 1);\n        }\n        else {\n            sync_n = CHILD(n, 0);\n        }\n        REQ(sync_n, sync_comp_for);\n\n        \n        if (is_async && c->c_feature_version < 6) {\n            ast_error(c, n,\n                    \"Async comprehensions are only supported in Python 3.6 and greater\");\n            return NULL;\n        }\n\n        for_ch = CHILD(sync_n, 1);\n        t = ast_for_exprlist(c, for_ch, Store);\n        if (!t)\n            return NULL;\n        expression = ast_for_expr(c, CHILD(sync_n, 3));\n        if (!expression)\n            return NULL;\n\n        \n        first = (expr_ty)asdl_seq_GET(t, 0);\n        if (NCH(for_ch) == 1)\n            comp = comprehension(first, expression, NULL,\n                                 is_async, c->c_arena);\n        else\n            comp = comprehension(Tuple(t, Store, first->lineno,\n                                       first->col_offset, c->c_arena),\n                                 expression, NULL, is_async, c->c_arena);\n        if (!comp)\n            return NULL;\n\n        if (NCH(sync_n) == 5) {\n            int j, n_ifs;\n            asdl_seq *ifs;\n\n            n = CHILD(sync_n, 4);\n            n_ifs = count_comp_ifs(c, n);\n            if (n_ifs == -1)\n                return NULL;\n\n            ifs = _Ta3_asdl_seq_new(n_ifs, c->c_arena);\n            if (!ifs)\n                return NULL;\n\n            for (j = 0; j < n_ifs; j++) {\n                REQ(n, comp_iter);\n                n = CHILD(n, 0);\n                REQ(n, comp_if);\n\n                expression = ast_for_expr(c, CHILD(n, 1));\n                if (!expression)\n                    return NULL;\n                asdl_seq_SET(ifs, j, expression);\n                if (NCH(n) == 3)\n                    n = CHILD(n, 2);\n            }\n            \n            if (TYPE(n) == comp_iter)\n                n = CHILD(n, 0);\n            comp->ifs = ifs;\n        }\n        asdl_seq_SET(comps, i, comp);\n    }\n    return comps;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nset_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\n\t\n\tif (strstr(name, \"..\") || strchr(name, '/'))\n\t\treturn -1;\n\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_pton\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    if (klinux_addr_buffer.size() != sizeof(klinux_in_addr)) {\n      ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n          \"enc_untrusted_inet_pton: unexpected output size\");\n    }\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    if (klinux_addr_buffer.size() != sizeof(klinux_in6_addr)) {\n      ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n          \"enc_untrusted_inet_pton: unexpected output size\");\n    }\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\t\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nunserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array;\n    char_u\t*line;\n    int\t\tline_len;\n\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tarray = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    else\n\tarray = NULL;\n    uep->ue_array = array;\n\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;\n\t    corruption_error(\"line length\", file_name);\n\t}\n\tif (line == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tarray[i] = line;\n    }\n    return uep;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nStatus GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst,\n                                  int input_index) {\n  if (output_index >= src->num_outputs()) {\n    return errors::InvalidArgument(\n        \"Output \", output_index, \" of node \", src->name(),\n        \" does not exist. Node only has \", src->num_outputs(), \" outputs.\");\n  }\n  if (input_index >= dst->num_inputs()) {\n    return errors::InvalidArgument(\n        \"Input \", input_index, \" of node \", dst->name(),\n        \" does not exist. Node only has \", dst->num_inputs(), \" inputs.\");\n  }\n\n  DataType src_out = src->output_type(output_index);\n  DataType dst_in = dst->input_type(input_index);\n  if (!TypesCompatible(dst_in, src_out)) {\n    return errors::InvalidArgument(\n        \"Input \", input_index, \" of node \", dst->name(), \" was passed \",\n        DataTypeString(src_out), \" from \", src->name(), \":\", output_index,\n        \" incompatible with expected \", DataTypeString(dst_in), \".\");\n  }\n  g_->AddEdge(src, output_index, dst, input_index);\n  return Status::OK();\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nload_header (XwdLoader *loader)\n{\n    XwdHeader *h = &loader->header;\n    XwdHeader in;\n    const XwdHeader *inp;\n\n    if (!file_mapping_taste (loader->mapping, &in, 0, sizeof (in)))\n        return FALSE;\n\n    inp = &in;\n\n    UNPACK_FIELD_U32 (h, inp, header_size);\n    UNPACK_FIELD_U32 (h, inp, file_version);\n    UNPACK_FIELD_U32 (h, inp, pixmap_format);\n    UNPACK_FIELD_U32 (h, inp, pixmap_depth);\n    UNPACK_FIELD_U32 (h, inp, pixmap_width);\n    UNPACK_FIELD_U32 (h, inp, pixmap_height);\n    UNPACK_FIELD_U32 (h, inp, x_offset);\n    UNPACK_FIELD_U32 (h, inp, byte_order);\n    UNPACK_FIELD_U32 (h, inp, bitmap_unit);\n    UNPACK_FIELD_U32 (h, inp, bitmap_bit_order);\n    UNPACK_FIELD_U32 (h, inp, bitmap_pad);\n    UNPACK_FIELD_U32 (h, inp, bits_per_pixel);\n    UNPACK_FIELD_U32 (h, inp, bytes_per_line);\n    UNPACK_FIELD_U32 (h, inp, visual_class);\n    UNPACK_FIELD_U32 (h, inp, red_mask);\n    UNPACK_FIELD_U32 (h, inp, green_mask);\n    UNPACK_FIELD_U32 (h, inp, blue_mask);\n    UNPACK_FIELD_U32 (h, inp, bits_per_rgb);\n    UNPACK_FIELD_U32 (h, inp, color_map_entries);\n    UNPACK_FIELD_U32 (h, inp, n_colors);\n    UNPACK_FIELD_U32 (h, inp, window_width);\n    UNPACK_FIELD_U32 (h, inp, window_height);\n    UNPACK_FIELD_S32 (h, inp, window_x);\n    UNPACK_FIELD_S32 (h, inp, window_y);\n    UNPACK_FIELD_U32 (h, inp, window_border_width);\n\n    \n\n    ASSERT_HEADER (h->header_size >= sizeof (XwdHeader));\n    ASSERT_HEADER (h->header_size <= 65535);\n    ASSERT_HEADER (h->file_version == 7);\n    ASSERT_HEADER (h->pixmap_depth == 24);\n\n    \n    ASSERT_HEADER (h->color_map_entries <= 256);\n\n    \n    ASSERT_HEADER (h->bits_per_rgb == 8 || h->bits_per_rgb == 24);\n\n    \n    ASSERT_HEADER (h->bits_per_pixel == 24 || h->bits_per_pixel == 32);\n\n    \n    ASSERT_HEADER (h->pixmap_width >= 1 && h->pixmap_width <= 65535);\n    ASSERT_HEADER (h->pixmap_height >= 1 && h->pixmap_height <= 65535);\n\n    \n    ASSERT_HEADER (h->bytes_per_line >= h->pixmap_width * (h->bits_per_pixel / 8));\n    ASSERT_HEADER (h->bytes_per_line <= h->pixmap_width * (h->bits_per_pixel / 8) + 1024);\n\n    \n    ASSERT_HEADER (h->bytes_per_line * h->pixmap_height < (1UL << 31) - 65536 - 256 * 32);\n\n    ASSERT_HEADER (compute_pixel_type (loader) < CHAFA_PIXEL_MAX);\n\n    loader->file_data = file_mapping_get_data (loader->mapping, &loader->file_data_len);\n    if (!loader->file_data)\n        return FALSE;\n\n    ASSERT_HEADER (loader->file_data_len >= h->header_size\n                   + h->color_map_entries * sizeof (XwdColor)\n                   + h->pixmap_height * (gsize) h->bytes_per_line);\n\n    loader->image_data = (const guint8 *) loader->file_data\n        + h->header_size + h->color_map_entries * sizeof (XwdColor);\n\n    return TRUE;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nRawTile OpenJPEGImage::getRegion( int ha, int va, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h ){\n\n   unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n  \n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n\n  RawTile rawtile( 0, res, ha, va, w, h, channels, obpc );\n\n  size_t np = (size_t) w * (size_t) h * (size_t) channels;\n  if( obpc == 16 ) rawtile.data = new unsigned short[np];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[np];\n  else throw file_error( \"OpenJPEG :: Unsupported number of bits\" );\n\n  rawtile.dataLength = np*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n\n  process( res, layers, x, y, w, h, rawtile.data );\n\n#ifdef DEBUG\n  logfile << \"OpenJPEG :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n\n  return rawtile;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nconst char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrncat(line, buf, sizeof line);\n\t\tstrncat(line, \" \", sizeof line);\n\t\te = e->next;\n\t}\n\tline[(sizeof line)-1] = '\\0'; \n\tline[strlen(line)-1] = 0; \n\treturn line;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid cipso_v4_sock_delattr(struct sock *sk)\n{\n\tint hdr_delta;\n\tstruct ip_options *opt;\n\tstruct inet_sock *sk_inet;\n\n\tsk_inet = inet_sk(sk);\n\topt = sk_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\n\thdr_delta = cipso_v4_delopt(&sk_inet->opt);\n\tif (sk_inet->is_icsk && hdr_delta > 0) {\n\t\tstruct inet_connection_sock *sk_conn = inet_csk(sk);\n\t\tsk_conn->icsk_ext_hdr_len -= hdr_delta;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  const int block_size = params->block_size;\n  const int input_height = input->dims->data[1];\n  const int input_width = input->dims->data[2];\n  const int input_channels = input->dims->data[3];\n  int output_height = input_height * block_size;\n  int output_width = input_width * block_size;\n  int output_channels = input_channels / block_size / block_size;\n\n  TF_LITE_ENSURE_EQ(context, input_height, output_height / block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width / block_size);\n  TF_LITE_ENSURE_EQ(context, input_channels,\n                    output_channels * block_size * block_size);\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  output_size->data[1] = output_height;\n  output_size->data[2] = output_width;\n  output_size->data[3] = output_channels;\n\n  return context->ResizeTensor(context, output, output_size);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t\n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t\n\tif (d->msg_len > (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))\n\t\treturn -EINVAL;\n\n\t\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t\n\tmsleep(100);\n\n\t\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nikev2_sa_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext1,\n\t\tu_int osa_length, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth)\n{\n\tconst struct isakmp_gen *ext;\n\tstruct isakmp_gen e;\n\tu_int sa_length;\n\tconst u_char *cp;\n\tint i;\n\tint pcount;\n\tu_char np;\n\tu_int item_len;\n\n\tND_TCHECK(*ext1);\n\tUNALIGNED_MEMCPY(&e, ext1, sizeof(e));\n\tikev2_pay_print(ndo, \"sa\", e.critical);\n\n\t\n\tosa_length= ntohs(e.len);\n\tsa_length = osa_length - 4;\n\tND_PRINT((ndo,\" len=%d\", sa_length));\n\n\t\n\tcp = (const u_char *)(ext1 + 1);\n\tpcount = 0;\n\tfor (np = ISAKMP_NPTYPE_P; np != 0; np = e.np) {\n\t\tpcount++;\n\t\text = (const struct isakmp_gen *)cp;\n\t\tif (sa_length < sizeof(*ext))\n\t\t\tgoto toolong;\n\t\tND_TCHECK(*ext);\n\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\n\t\t\n\t\titem_len = ntohs(e.len);\n\t\tif (item_len <= 4)\n\t\t\tgoto trunc;\n\n\t\tif (sa_length < item_len)\n\t\t\tgoto toolong;\n\t\tND_TCHECK2(*cp, item_len);\n\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tif (np == ISAKMP_NPTYPE_P) {\n\t\t\tcp = ikev2_p_print(ndo, np, pcount, ext, item_len,\n\t\t\t\t\t   ep, depth);\n\t\t\tif (cp == NULL) {\n\t\t\t\t\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s\", NPSTR(np)));\n\t\t\tcp += item_len;\n\t\t}\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tsa_length -= item_len;\n\t}\n\treturn cp;\ntoolong:\n\t\n\tcp += sa_length;\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tunsigned int *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\n\tfield_type = get_exif_ui16(e, tag_pos+2);\n\tvalue_count = get_exif_ui32(e, tag_pos+4);\n\n\tif(value_count!=1) return 0;\n\n\tif(field_type==3) {\t\t*pv = get_exif_ui16(e, tag_pos+8);\n\t\treturn 1;\n\t}\n\telse if(field_type==4) {\t\t*pv = get_exif_ui32(e, tag_pos+8);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ngoto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    CHECK_CMDWIN;\n\n       set_keep_msg(NULL, 0);\n\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nhorAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\n\tunsigned char* cp = (unsigned char*) cp0;\n    if((cc%stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horAcc8\",\n                     \"%s\", \"(cc%stride)!=0\");\n        return 0;\n    }\n\n\tif (cc > stride) {\n\t\t\n\t\tif (stride == 3)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tcc -= 3;\n\t\t\tcp += 3;\n\t\t\twhile (cc>0) {\n\t\t\t\tcp[0] = (unsigned char) ((cr += cp[0]) & 0xff);\n\t\t\t\tcp[1] = (unsigned char) ((cg += cp[1]) & 0xff);\n\t\t\t\tcp[2] = (unsigned char) ((cb += cp[2]) & 0xff);\n\t\t\t\tcc -= 3;\n\t\t\t\tcp += 3;\n\t\t\t}\n\t\t} else if (stride == 4)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tunsigned int ca = cp[3];\n\t\t\tcc -= 4;\n\t\t\tcp += 4;\n\t\t\twhile (cc>0) {\n\t\t\t\tcp[0] = (unsigned char) ((cr += cp[0]) & 0xff);\n\t\t\t\tcp[1] = (unsigned char) ((cg += cp[1]) & 0xff);\n\t\t\t\tcp[2] = (unsigned char) ((cb += cp[2]) & 0xff);\n\t\t\t\tcp[3] = (unsigned char) ((ca += cp[3]) & 0xff);\n\t\t\t\tcc -= 4;\n\t\t\t\tcp += 4;\n\t\t\t}\n\t\t} else  {\n\t\t\tcc -= stride;\n\t\t\tdo {\n\t\t\t\tREPEAT4(stride, cp[stride] =\n\t\t\t\t\t(unsigned char) ((cp[stride] + *cp) & 0xff); cp++)\n\t\t\t\tcc -= stride;\n\t\t\t} while (cc>0);\n\t\t}\n\t}\n\treturn 1;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nStatus GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,\n                        std::vector<string>* results) {\n  results->clear();\n  if (pattern.empty()) {\n    return Status::OK();\n  }\n\n  string fixed_prefix = pattern.substr(0, pattern.find_first_of(\"*?[\\\\\"));\n  string eval_pattern = pattern;\n  string dir(io::Dirname(fixed_prefix));\n    if (dir.empty()) {\n    dir = \".\";\n    fixed_prefix = io::JoinPath(dir, fixed_prefix);\n    eval_pattern = io::JoinPath(dir, eval_pattern);\n  }\n  bool is_directory = pattern[pattern.size() - 1] == '/';\n#ifdef PLATFORM_WINDOWS\n  is_directory = is_directory || pattern[pattern.size() - 1] == '\\\\';\n#endif\n  std::vector<string> dirs;\n  if (!is_directory) {\n    dirs.emplace_back(eval_pattern);\n  }\n  StringPiece tmp_dir(io::Dirname(eval_pattern));\n  while (tmp_dir.size() > dir.size()) {\n    dirs.emplace_back(string(tmp_dir));\n    tmp_dir = io::Dirname(tmp_dir);\n  }\n  dirs.emplace_back(dir);\n  std::reverse(dirs.begin(), dirs.end());\n   std::deque<std::pair<string, int>> dir_q;\n  std::deque<std::pair<string, int>> next_dir_q;\n  dir_q.emplace_back(std::make_pair(dirs[0], 0));\n  Status ret;   mutex results_mutex;\n  condition_variable results_cond;\n  mutex next_que_mutex;\n  condition_variable next_que_cond;\n  while (!dir_q.empty()) {\n    next_dir_q.clear();\n    std::vector<Status> new_rets(dir_q.size());\n    auto handle_level = [fs, &results, &dir_q, &next_dir_q, &new_rets,\n                         &is_directory, &dirs, &results_mutex, &results_cond,\n                         &next_que_mutex, &next_que_cond](int i) {\n      string current_dir = dir_q.at(i).first;\n      int dir_index = dir_q.at(i).second;\n      dir_index++;\n      std::vector<string> children;\n      Status s = fs->GetChildren(current_dir, &children);\n           if (s.code() == tensorflow::error::PERMISSION_DENIED) {\n        return;\n      }\n      new_rets[i] = s;\n      if (children.empty()) return;\n\n                          std::vector<Status> children_dir_status;\n\n           children_dir_status.resize(children.size());\n      auto handle_children = [fs, &current_dir, &children, &dirs, dir_index,\n                              is_directory, &children_dir_status](int j) {\n        const string child_path = io::JoinPath(current_dir, children[j]);\n        if (!fs->Match(child_path, dirs[dir_index])) {\n          children_dir_status[j] =\n              Status(tensorflow::error::CANCELLED, \"Operation not needed\");\n        } else if (dir_index != dirs.size() - 1) {\n          children_dir_status[j] = fs->IsDirectory(child_path);\n        } else {\n          children_dir_status[j] =\n              is_directory ? fs->IsDirectory(child_path) : Status::OK();\n        }\n      };\n      ForEach(0, children.size(), handle_children);\n\n      for (size_t j = 0; j < children.size(); ++j) {\n        const string child_path = io::JoinPath(current_dir, children[j]);\n               if (children_dir_status[j].code() == tensorflow::error::CANCELLED) {\n          continue;\n        }\n        if (children_dir_status[j].ok()) {\n          if (dir_index != dirs.size() - 1) {\n            mutex_lock lk(next_que_mutex);\n            next_dir_q.emplace_back(std::make_pair(child_path, dir_index));\n            next_que_cond.notify_one();\n          } else {\n            mutex_lock lk(results_mutex);\n            results->emplace_back(child_path);\n            results_cond.notify_one();\n          }\n        }\n      }\n    };\n    ForEach(0, dir_q.size(), handle_level);\n\n    ret.Update(new_rets[dir_q.size() - 1]);\n    std::swap(dir_q, next_dir_q);\n  }\n  return ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint pnm_validate(jas_stream_t *in)\n{\n\tuchar buf[2];\n\tint i;\n\tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= 2);\n\n\t\n\tif ((n = jas_stream_read(in, buf, 2)) < 0) {\n\t\treturn -1;\n\t}\n\t\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tif (n < 2) {\n\t\treturn -1;\n\t}\n\t\n\tif (buf[0] == 'P' && isdigit(buf[1])) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint t2p_process_jpeg_strip(\n\tunsigned char* strip, \n\ttsize_t* striplength, \n\tunsigned char* buffer, \n    tsize_t buffersize,\n\ttsize_t* bufferoffset, \n\ttstrip_t no, \n\tuint32 height){\n\n\ttsize_t i=0;\n\n\twhile (i < *striplength) {\n\t\ttsize_t datalen;\n\t\tuint16 ri;\n\t\tuint16 v_samp;\n\t\tuint16 h_samp;\n\t\tint j;\n\t\tint ncomp;\n\n\t\t\n\t\tif (strip[i] != 0xff)\n\t\t\treturn(0);\n\t\ti++;\n\t\twhile (i < *striplength && strip[i] == 0xff)\n\t\t\ti++;\n\t\tif (i >= *striplength)\n\t\t\treturn(0);\n\t\t\n\t\tif (strip[i] == 0xd8)\n\t\t\tdatalen = 0;\n\t\telse {\n\t\t\tif ((*striplength - i) <= 2)\n\t\t\t\treturn(0);\n\t\t\tdatalen = (strip[i+1] << 8) | strip[i+2];\n\t\t\tif (datalen < 2 || datalen >= (*striplength - i))\n\t\t\t\treturn(0);\n\t\t}\n\t\tswitch( strip[i] ){\n\t\t\tcase 0xd8:\t\n                if( *bufferoffset + 2 > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), 2);\n\t\t\t\t*bufferoffset+=2;\n\t\t\t\tbreak;\n\t\t\tcase 0xc0:\t\n\t\t\tcase 0xc1:\t\n\t\t\tcase 0xc3:\t\n\t\t\tcase 0xc9:\t\n\t\t\tcase 0xca:\t\n\t\t\t\tif(no==0){\n                    if( *bufferoffset + datalen + 2 + 6 > buffersize )\n                        return(0);\n\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n                    if( *bufferoffset + 9 >= buffersize )\n                        return(0);\n\t\t\t\t\tncomp = buffer[*bufferoffset+9];\n\t\t\t\t\tif (ncomp < 1 || ncomp > 4)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\tv_samp=1;\n\t\t\t\t\th_samp=1;\n                    if( *bufferoffset + 11 + 3*(ncomp-1) >= buffersize )\n                        return(0);\n\t\t\t\t\tfor(j=0;j<ncomp;j++){\n\t\t\t\t\t\tuint16 samp = buffer[*bufferoffset+11+(3*j)];\n\t\t\t\t\t\tif( (samp>>4) > h_samp) \n\t\t\t\t\t\t\th_samp = (samp>>4);\n\t\t\t\t\t\tif( (samp & 0x0f) > v_samp) \n\t\t\t\t\t\t\tv_samp = (samp & 0x0f);\n\t\t\t\t\t}\n\t\t\t\t\tv_samp*=8;\n\t\t\t\t\th_samp*=8;\n\t\t\t\t\tri=((( ((uint16)(buffer[*bufferoffset+5])<<8) | \n\t\t\t\t\t(uint16)(buffer[*bufferoffset+6]) )+v_samp-1)/ \n\t\t\t\t\tv_samp);\n\t\t\t\t\tri*=((( ((uint16)(buffer[*bufferoffset+7])<<8) | \n\t\t\t\t\t(uint16)(buffer[*bufferoffset+8]) )+h_samp-1)/ \n\t\t\t\t\th_samp);\n\t\t\t\t\tbuffer[*bufferoffset+5]=\n                                          (unsigned char) ((height>>8) & 0xff);\n\t\t\t\t\tbuffer[*bufferoffset+6]=\n                                            (unsigned char) (height & 0xff);\n\t\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\t\t\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xdd;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0x00;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0x04;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=(ri >> 8) & 0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]= ri & 0xff;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xc4: \n\t\t\tcase 0xdb: \n                if( *bufferoffset + datalen + 2 > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\tbreak;\n\t\t\tcase 0xda: \n\t\t\t\tif(no==0){\n                    if( *bufferoffset + datalen + 2 > buffersize )\n                        return(0);\n\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n\t\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\t} else {\n                    if( *bufferoffset + 2 > buffersize )\n                        return(0);\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=\n                                            (unsigned char)(0xd0 | ((no-1)%8));\n\t\t\t\t}\n\t\t\t\ti += datalen + 1;\n\t\t\t\t\n                if( *bufferoffset + *striplength - i > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i]), *striplength - i);\n\t\t\t\t*bufferoffset+= *striplength - i;\n\t\t\t\treturn(1);\n\t\t\tdefault:\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t}\n\t\ti += datalen + 1;\n\t}\n\n\t\n\treturn(0);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\tcpumask_clear(&mm->context.cpu_attach_mask);\n\tatomic_set(&mm->context.attach_count, 0);\n\tmm->context.flush_mm = 0;\n\tmm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;\n\tmm->context.asce_bits |= _ASCE_TYPE_REGION3;\n#ifdef CONFIG_PGSTE\n\tmm->context.alloc_pgste = page_table_allocate_pgste;\n\tmm->context.has_pgste = 0;\n\tmm->context.use_skey = 0;\n#endif\n\tmm->context.asce_limit = STACK_TOP_MAX;\n\tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nhorizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n\t    wp += n + stride - 1;\t\n\t    ip += n + stride - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nkey_ref_t key_create_or_update(key_ref_t keyring_ref,\n\t\t\t       const char *type,\n\t\t\t       const char *description,\n\t\t\t       const void *payload,\n\t\t\t       size_t plen,\n\t\t\t       key_perm_t perm,\n\t\t\t       unsigned long flags)\n{\n\tstruct keyring_index_key index_key = {\n\t\t.description\t= description,\n\t};\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tconst struct cred *cred = current_cred();\n\tstruct key *keyring, *key = NULL;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\t\n\tindex_key.type = key_type_lookup(type);\n\tif (IS_ERR(index_key.type)) {\n\t\tkey_ref = ERR_PTR(-ENODEV);\n\t\tgoto error;\n\t}\n\n\tkey_ref = ERR_PTR(-EINVAL);\n\tif (!index_key.type->instantiate ||\n\t    (!index_key.description && !index_key.type->preparse))\n\t\tgoto error_put_type;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkey_check(keyring);\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error_put_type;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = index_key.type->def_datalen;\n\tprep.trusted = flags & KEY_ALLOC_TRUSTED;\n\tprep.expiry = TIME_T_MAX;\n\tif (index_key.type->preparse) {\n\t\tret = index_key.type->preparse(&prep);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t\tif (!index_key.description)\n\t\t\tindex_key.description = prep.description;\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (!index_key.description)\n\t\t\tgoto error_free_prep;\n\t}\n\tindex_key.desc_len = strlen(index_key.description);\n\n\tkey_ref = ERR_PTR(-EPERM);\n\tif (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))\n\t\tgoto error_free_prep;\n\tflags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;\n\n\tret = __key_link_begin(keyring, &index_key, &edit);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_free_prep;\n\t}\n\n\t\n\tret = key_permission(keyring_ref, KEY_NEED_WRITE);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\t\n\tif (index_key.type->update) {\n\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\tif (key_ref)\n\t\t\tgoto found_matching_key;\n\t}\n\n\t\n\tif (perm == KEY_PERM_UNDEF) {\n\t\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\t\tperm |= KEY_USR_VIEW;\n\n\t\tif (index_key.type->read)\n\t\t\tperm |= KEY_POS_READ;\n\n\t\tif (index_key.type == &key_type_keyring ||\n\t\t    index_key.type->update)\n\t\t\tperm |= KEY_POS_WRITE;\n\t}\n\n\t\n\tkey = key_alloc(index_key.type, index_key.description,\n\t\t\tcred->fsuid, cred->fsgid, cred, perm, flags);\n\tif (IS_ERR(key)) {\n\t\tkey_ref = ERR_CAST(key);\n\t\tgoto error_link_end;\n\t}\n\n\t\n\tret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\n\nerror_link_end:\n\t__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\n\tif (index_key.type->preparse)\n\t\tindex_key.type->free_preparse(&prep);\nerror_put_type:\n\tkey_type_put(index_key.type);\nerror:\n\treturn key_ref;\n\n found_matching_key:\n\t\n\t__key_link_end(keyring, &index_key, edit);\n\n\tkey_ref = __key_update(key_ref, &prep);\n\tgoto error_free_prep;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_for_call(struct compiling *c, const node *n, expr_ty func,\n             const node *maybegenbeg, const node *closepar)\n{\n    \n\n    int i, nargs, nkeywords;\n    int ndoublestars;\n    asdl_seq *args;\n    asdl_seq *keywords;\n\n    REQ(n, arglist);\n\n    nargs = 0;\n    nkeywords = 0;\n    for (i = 0; i < NCH(n); i++) {\n        node *ch = CHILD(n, i);\n        if (TYPE(ch) == argument) {\n            if (NCH(ch) == 1)\n                nargs++;\n            else if (TYPE(CHILD(ch, 1)) == comp_for) {\n                nargs++;\n                if (!maybegenbeg) {\n                    ast_error(c, ch, \"invalid syntax\");\n                    return NULL;\n                }\n                if (NCH(n) > 1) {\n                    ast_error(c, ch, \"Generator expression must be parenthesized\");\n                    return NULL;\n                }\n            }\n            else if (TYPE(CHILD(ch, 0)) == STAR)\n                nargs++;\n            else if (TYPE(CHILD(ch, 1)) == COLONEQUAL) {\n                nargs++;\n            }\n            else\n                \n                nkeywords++;\n        }\n    }\n\n    args = _Py_asdl_seq_new(nargs, c->c_arena);\n    if (!args)\n        return NULL;\n    keywords = _Py_asdl_seq_new(nkeywords, c->c_arena);\n    if (!keywords)\n        return NULL;\n\n    nargs = 0;  \n    nkeywords = 0;  \n    ndoublestars = 0;  \n    for (i = 0; i < NCH(n); i++) {\n        node *ch = CHILD(n, i);\n        if (TYPE(ch) == argument) {\n            expr_ty e;\n            node *chch = CHILD(ch, 0);\n            if (NCH(ch) == 1) {\n                \n                if (nkeywords) {\n                    if (ndoublestars) {\n                        ast_error(c, chch,\n                                  \"positional argument follows \"\n                                  \"keyword argument unpacking\");\n                    }\n                    else {\n                        ast_error(c, chch,\n                                  \"positional argument follows \"\n                                  \"keyword argument\");\n                    }\n                    return NULL;\n                }\n                e = ast_for_expr(c, chch);\n                if (!e)\n                    return NULL;\n                asdl_seq_SET(args, nargs++, e);\n            }\n            else if (TYPE(chch) == STAR) {\n                \n                expr_ty starred;\n                if (ndoublestars) {\n                    ast_error(c, chch,\n                              \"iterable argument unpacking follows \"\n                              \"keyword argument unpacking\");\n                    return NULL;\n                }\n                e = ast_for_expr(c, CHILD(ch, 1));\n                if (!e)\n                    return NULL;\n                starred = Starred(e, Load, LINENO(chch),\n                        chch->n_col_offset,\n                        chch->n_end_lineno, chch->n_end_col_offset,\n                        c->c_arena);\n                if (!starred)\n                    return NULL;\n                asdl_seq_SET(args, nargs++, starred);\n\n            }\n            else if (TYPE(chch) == DOUBLESTAR) {\n                \n                keyword_ty kw;\n                i++;\n                e = ast_for_expr(c, CHILD(ch, 1));\n                if (!e)\n                    return NULL;\n                kw = keyword(NULL, e, c->c_arena);\n                asdl_seq_SET(keywords, nkeywords++, kw);\n                ndoublestars++;\n            }\n            else if (TYPE(CHILD(ch, 1)) == comp_for) {\n                \n                e = copy_location(ast_for_genexp(c, ch), maybegenbeg);\n                if (!e)\n                    return NULL;\n                asdl_seq_SET(args, nargs++, e);\n            }\n            else if (TYPE(CHILD(ch, 1)) == COLONEQUAL) {\n                \n                if (nkeywords) {\n                    if (ndoublestars) {\n                        ast_error(c, chch,\n                                  \"positional argument follows \"\n                                  \"keyword argument unpacking\");\n                    }\n                    else {\n                        ast_error(c, chch,\n                                  \"positional argument follows \"\n                                  \"keyword argument\");\n                    }\n                    return NULL;\n                }\n                e = ast_for_namedexpr(c, ch);\n                if (!e)\n                    return NULL;\n                asdl_seq_SET(args, nargs++, e);\n            }\n            else {\n                \n                keyword_ty kw;\n                identifier key, tmp;\n                int k;\n\n                                                             static const int name_tree[] = {\n                    test,\n                    or_test,\n                    and_test,\n                    not_test,\n                    comparison,\n                    expr,\n                    xor_expr,\n                    and_expr,\n                    shift_expr,\n                    arith_expr,\n                    term,\n                    factor,\n                    power,\n                    atom_expr,\n                    atom,\n                    0,\n                };\n                node *expr_node = chch;\n                for (int i = 0; name_tree[i]; i++) {\n                    if (TYPE(expr_node) != name_tree[i])\n                        break;\n                    if (NCH(expr_node) != 1)\n                        break;\n                    expr_node = CHILD(expr_node, 0);\n                }\n                if (TYPE(expr_node) != NAME) {\n                    ast_error(c, chch,\n                              \"expression cannot contain assignment, \"\n                              \"perhaps you meant \\\"==\\\"?\");\n                    return NULL;\n                }\n                key = new_identifier(STR(expr_node), c);\n                if (key == NULL) {\n                    return NULL;\n                }\n                if (forbidden_name(c, key, chch, 1)) {\n                    return NULL;\n                }\n                for (k = 0; k < nkeywords; k++) {\n                    tmp = ((keyword_ty)asdl_seq_GET(keywords, k))->arg;\n                    if (tmp && !PyUnicode_Compare(tmp, key)) {\n                        ast_error(c, chch,\n                                  \"keyword argument repeated\");\n                        return NULL;\n                    }\n                }\n                e = ast_for_expr(c, CHILD(ch, 2));\n                if (!e)\n                    return NULL;\n                kw = keyword(key, e, c->c_arena);\n                if (!kw)\n                    return NULL;\n                asdl_seq_SET(keywords, nkeywords++, kw);\n            }\n        }\n    }\n\n    return Call(func, args, keywords, func->lineno, func->col_offset,\n                closepar->n_end_lineno, closepar->n_end_col_offset, c->c_arena);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool ActiveStreamEncoderFilter::canContinue() {\n    return !parent_.state_.remote_encode_complete_;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  const int num_elements = NumElements(input);\n  TF_LITE_ENSURE_EQ(context, num_elements, NumElements(output));\n  switch (input->type) {\n    case kTfLiteInt64:\n      return copyToTensor(context, input->data.i64, output, num_elements);\n    case kTfLiteInt32:\n      return copyToTensor(context, input->data.i32, output, num_elements);\n    case kTfLiteUInt8:\n      return copyToTensor(context, input->data.uint8, output, num_elements);\n    case kTfLiteFloat32:\n      return copyToTensor(context, GetTensorData<float>(input), output,\n                          num_elements);\n    case kTfLiteBool:\n      return copyToTensor(context, input->data.b, output, num_elements);\n    case kTfLiteComplex64:\n      return copyToTensor(\n          context, reinterpret_cast<std::complex<float>*>(input->data.c64),\n          output, num_elements);\n    default:\n           TF_LITE_UNSUPPORTED_TYPE(context, input->type, \"Cast\");\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\"PLEN %d type %d len %d\\n\",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len && plen > 0); \n\n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\n\treturn nh.nh_type;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nrdpsnddbg_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tstatic char *rest = NULL;\n\tchar *buf;\n\n\tif (!s_check(s))\n\t{\n\t\trdp_protocol_error(\"rdpsnddbg_process(), stream is in unstable state\", s);\n\t}\n\n\tpkglen = s->end - s->p;\n\t\n\tbuf = (char *) xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\n\tstr_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);\n\n\txfree(buf);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t       indx, 0, data, size, 500);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid set_cfg_option(char *opt_string)\n{\n\tchar *sep, *sep2, szSec[1024], szKey[1024], szVal[1024];\n\tsep = strchr(opt_string, ':');\n\tif (!sep) {\n\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);\n\t\treturn;\n\t}\n\t{\n\t\tconst size_t sepIdx = sep - opt_string;\n\t\tif (sepIdx >= sizeof(szSec)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - Section name is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\n\t\tstrncpy(szSec, opt_string, sepIdx);\n\t\tszSec[sepIdx] = 0;\n\t}\n\tsep ++;\n\tsep2 = strchr(sep, '=');\n\tif (!sep2) {\n\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);\n\t\treturn;\n\t}\n\t{\n\t\tconst size_t sepIdx = sep2 - sep;\n\t\tif (sepIdx >= sizeof(szKey)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - key name is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tstrncpy(szKey, sep, sepIdx);\n\t\tszKey[sepIdx] = 0;\n\t\tif (strlen(sep2 + 1) >= sizeof(szVal)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - value is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tstrcpy(szVal, sep2+1);\n\t}\n\n\tif (!stricmp(szKey, \"*\")) {\n\t\tif (stricmp(szVal, \"null\")) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:*=null\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tgf_cfg_del_section(cfg_file, szSec);\n\t\treturn;\n\t}\n\n\tif (!stricmp(szVal, \"null\")) {\n\t\tszVal[0]=0;\n\t}\n\tgf_cfg_set_key(cfg_file, szSec, szKey, szVal[0] ? szVal : NULL);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  absl::Status IsSupported(const TfLiteContext* context,\n                           const TfLiteNode* tflite_node,\n                           const TfLiteRegistration* registration) final {\n    RETURN_IF_ERROR(CheckMaxSupportedOpVersion(registration, 3));\n    if (tflite_node->inputs->size != 2) {\n      return absl::UnimplementedError(\"MUL requires two input tensors.\");\n    }\n    auto input0 = tflite::GetInput(context, tflite_node, 0);\n    auto input1 = tflite::GetInput(context, tflite_node, 1);\n    if (input0 == nullptr || input1 == nullptr) {\n      return absl::InvalidArgumentError(\"At least one input tensor is null\");\n    }\n    if (input0->dims->size == input1->dims->size) {\n                               bool first_has_smaller_dim = false;\n      bool second_has_smaller_dim = false;\n      for (int i = 0; i < input0->dims->size; ++i) {\n        if (input0->dims->data[i] < input1->dims->data[i]) {\n          first_has_smaller_dim = true;\n        }\n        if (input1->dims->data[i] < input0->dims->data[i]) {\n          second_has_smaller_dim = true;\n        }\n      }\n      if (first_has_smaller_dim && second_has_smaller_dim) {\n        return absl::UnimplementedError(\n            \"MUL requires one tensor that not less than second in all \"\n            \"dimensions.\");\n      }\n    }\n    const TfLiteMulParams* tf_options;\n    RETURN_IF_ERROR(RetrieveBuiltinData(tflite_node, &tf_options));\n    return IsActivationSupported(tf_options->activation);\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint read_xattrs_from_disk(int fd, struct squashfs_super_block *sBlk, int flag, long long *table_start)\n{\n\tint res, bytes, i, indexes, index_bytes, ids;\n\tlong long *index, start, end;\n\tstruct squashfs_xattr_table id_table;\n\n\tTRACE(\"read_xattrs_from_disk\\n\");\n\n\tif(sBlk->xattr_id_table_start == SQUASHFS_INVALID_BLK)\n\t\treturn SQUASHFS_INVALID_BLK;\n\n\t\n\tres = read_fs_bytes(fd, sBlk->xattr_id_table_start, sizeof(id_table),\n\t\t&id_table);\n\tif(res == 0)\n\t\treturn 0;\n\n\tSQUASHFS_INSWAP_XATTR_TABLE(&id_table);\n\n\tif(flag) {\n\t\t\n\t\t*table_start = id_table.xattr_table_start;\n\t\treturn id_table.xattr_ids;\n\t}\n\n\t\n\tids = id_table.xattr_ids;\n\txattr_table_start = id_table.xattr_table_start;\n\tindex_bytes = SQUASHFS_XATTR_BLOCK_BYTES(ids);\n\tindexes = SQUASHFS_XATTR_BLOCKS(ids);\n\tindex = malloc(index_bytes);\n\tif(index == NULL)\n\t\tMEM_ERROR();\n\n\tres = read_fs_bytes(fd, sBlk->xattr_id_table_start + sizeof(id_table),\n\t\tindex_bytes, index);\n\tif(res ==0)\n\t\tgoto failed1;\n\n\tSQUASHFS_INSWAP_LONG_LONGS(index, indexes);\n\n\t\n\tbytes = SQUASHFS_XATTR_BYTES(ids);\n\txattr_ids = malloc(bytes);\n\tif(xattr_ids == NULL)\n\t\tMEM_ERROR();\n\n\tfor(i = 0; i < indexes; i++) {\n\t\tint expected = (i + 1) != indexes ? SQUASHFS_METADATA_SIZE :\n\t\t\t\t\tbytes & (SQUASHFS_METADATA_SIZE - 1);\n\t\tint length = read_block(fd, index[i], NULL, expected,\n\t\t\t((unsigned char *) xattr_ids) +\n\t\t\t(i * SQUASHFS_METADATA_SIZE));\n\t\tTRACE(\"Read xattr id table block %d, from 0x%llx, length \"\n\t\t\t\"%d\\n\", i, index[i], length);\n\t\tif(length == 0) {\n\t\t\tERROR(\"Failed to read xattr id table block %d, \"\n\t\t\t\t\"from 0x%llx, length %d\\n\", i, index[i],\n\t\t\t\tlength);\n\t\t\tgoto failed2;\n\t\t}\n\t}\n\n\t\n\tstart = xattr_table_start;\n\tend = index[0];\n\tfor(i = 0; start < end; i++) {\n\t\tint length;\n\t\txattrs = realloc(xattrs, (i + 1) * SQUASHFS_METADATA_SIZE);\n\t\tif(xattrs == NULL)\n\t\t\tMEM_ERROR();\n\n\t\t\n\t\tsave_xattr_block(start, i * SQUASHFS_METADATA_SIZE);\n\n\t\tlength = read_block(fd, start, &start, 0,\n\t\t\t((unsigned char *) xattrs) +\n\t\t\t(i * SQUASHFS_METADATA_SIZE));\n\t\tTRACE(\"Read xattr block %d, length %d\\n\", i, length);\n\t\tif(length == 0) {\n\t\t\tERROR(\"Failed to read xattr block %d\\n\", i);\n\t\t\tgoto failed3;\n\t\t}\n\n\t\t\n\t\tif(start != end && length != SQUASHFS_METADATA_SIZE) {\n\t\t\tERROR(\"Xattr block %d should be %d bytes in length, \"\n\t\t\t\t\"it is %d bytes\\n\", i, SQUASHFS_METADATA_SIZE,\n\t\t\t\tlength);\n\t\t\tgoto failed3;\n\t\t}\n\t}\n\n\t\n\tfor(i = 0; i < ids; i++)\n\t\tSQUASHFS_INSWAP_XATTR_ID(&xattr_ids[i]);\n\n\tfree(index);\n\n\treturn ids;\n\nfailed3:\n\tfree(xattrs);\nfailed2:\n\tfree(xattr_ids);\nfailed1:\n\tfree(index);\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *component,\n\t\t\tvoid *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, path, component, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, path, component);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int RsaPad_PSS(const byte* input, word32 inputLen, byte* pkcsBlock,\n        word32 pkcsBlockLen, WC_RNG* rng, enum wc_HashType hType, int mgf,\n        int saltLen, int bits, void* heap)\n{\n    int   ret = 0;\n    int   hLen, i, o, maskLen, hiBits;\n    byte* m;\n    byte* s;\n#if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)\n    byte msg[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];\n#else\n    byte* msg = NULL;\n#endif\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    byte* salt;\n#else\n    byte salt[WC_MAX_DIGEST_SIZE];\n#endif\n\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    if (pkcsBlockLen > RSA_MAX_SIZE/8) {\n        return MEMORY_E;\n    }\n#endif\n\n    hLen = wc_HashGetDigestSize(hType);\n    if (hLen < 0)\n        return hLen;\n    if ((int)inputLen != hLen) {\n        return BAD_FUNC_ARG;\n    }\n\n    hiBits = (bits - 1) & 0x7;\n    if (hiBits == 0) {\n        \n        *(pkcsBlock++) = 0;\n        pkcsBlockLen--;\n    }\n\n    if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {\n        saltLen = hLen;\n        #ifdef WOLFSSL_SHA512\n            \n            if (bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE) {\n                saltLen = RSA_PSS_SALT_MAX_SZ;\n            }\n        #endif\n    }\n#ifndef WOLFSSL_PSS_LONG_SALT\n    else if (saltLen > hLen) {\n        return PSS_SALTLEN_E;\n    }\n#endif\n#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER\n    else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT) {\n        return PSS_SALTLEN_E;\n    }\n#else\n    else if (saltLen == RSA_PSS_SALT_LEN_DISCOVER) {\n        saltLen = (int)pkcsBlockLen - hLen - 2;\n        if (saltLen < 0) {\n            return PSS_SALTLEN_E;\n        }\n    }\n    else if (saltLen < RSA_PSS_SALT_LEN_DISCOVER) {\n        return PSS_SALTLEN_E;\n    }\n#endif\n    if ((int)pkcsBlockLen - hLen < saltLen + 2) {\n        return PSS_SALTLEN_E;\n    }\n    maskLen = pkcsBlockLen - 1 - hLen;\n\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n                                                       DYNAMIC_TYPE_RSA_BUFFER);\n        if (msg == NULL) {\n            return MEMORY_E;\n        }\n    #endif\n    salt = s = m = msg;\n    XMEMSET(m, 0, RSA_PSS_PAD_SZ);\n    m += RSA_PSS_PAD_SZ;\n    XMEMCPY(m, input, inputLen);\n    m += inputLen;\n    o = (int)(m - s);\n    if (saltLen > 0) {\n        ret = wc_RNG_GenerateBlock(rng, m, saltLen);\n        if (ret == 0) {\n            m += saltLen;\n        }\n    }\n#else\n    if (pkcsBlockLen < RSA_PSS_PAD_SZ + inputLen + saltLen) {\n    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n                                                       DYNAMIC_TYPE_RSA_BUFFER);\n        if (msg == NULL) {\n            return MEMORY_E;\n        }\n    #endif\n        m = msg;\n    }\n    else {\n        m = pkcsBlock;\n    }\n    s = m;\n    XMEMSET(m, 0, RSA_PSS_PAD_SZ);\n    m += RSA_PSS_PAD_SZ;\n    XMEMCPY(m, input, inputLen);\n    m += inputLen;\n    o = 0;\n    if (saltLen > 0) {\n        ret = wc_RNG_GenerateBlock(rng, salt, saltLen);\n        if (ret == 0) {\n            XMEMCPY(m, salt, saltLen);\n            m += saltLen;\n        }\n    }\n#endif\n    if (ret == 0) {\n        \n        ret = wc_Hash(hType, s, (word32)(m - s), pkcsBlock + maskLen, hLen);\n    }\n    if (ret == 0) {\n       \n        pkcsBlock[pkcsBlockLen - 1] = RSA_PSS_PAD_TERM;\n\n        ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, pkcsBlock, maskLen, heap);\n    }\n    if (ret == 0) {\n        \n        if (hiBits)\n            pkcsBlock[0] &= (1 << hiBits) - 1;\n\n        m = pkcsBlock + maskLen - saltLen - 1;\n        *(m++) ^= 0x01;\n        for (i = 0; i < saltLen; i++) {\n            m[i] ^= salt[o + i];\n        }\n    }\n\n    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        if (msg != NULL) {\n            XFREE(msg, heap, DYNAMIC_TYPE_RSA_BUFFER);\n        }\n    #endif\n    return ret;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nDECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n        \n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid CLua::init_libraries()\n{\n    lua_stack_cleaner clean(state());\n\n    lua_pushcfunction(_state, lua_loadstring);\n    lua_setglobal(_state, \"loadstring\");\n    lua_pushnil(_state);\n    lua_setglobal(_state, \"load\");\n\n       cluaopen_kills(_state);\n    cluaopen_you(_state);\n    cluaopen_item(_state);\n    cluaopen_food(_state);\n    cluaopen_crawl(_state);\n    cluaopen_file(_state);\n    cluaopen_moninf(_state);\n    cluaopen_options(_state);\n    cluaopen_travel(_state);\n    cluaopen_view(_state);\n    cluaopen_spells(_state);\n\n    cluaopen_globals(_state);\n\n    execfile(\"dlua/macro.lua\", true, true);\n\n       execstring(\"chk_startgame = { }\", \"base\");\n\n    lua_register(_state, \"loadfile\", _clua_loadfile);\n    lua_register(_state, \"dofile\", _clua_dofile);\n\n    lua_register(_state, \"crawl_require\", _clua_require);\n\n    execfile(\"dlua/util.lua\", true, true);\n    execfile(\"dlua/iter.lua\", true, true);\n    execfile(\"dlua/tags.lua\", true, true);\n    execfile(\"dlua/init.lua\", true, true);\n\n    if (managed_vm)\n    {\n        lua_register(_state, \"pcall\", _clua_guarded_pcall);\n        execfile(\"dlua/userbase.lua\", true, true);\n        execfile(\"dlua/persist.lua\", true, true);\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_pli(\n\t\t\t\t\tpjmedia_rtcp_session *session, \n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length)\n{\n    pjmedia_rtcp_fb_common *hdr;\n    unsigned len;\n\n    PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);\n\n    len = 12;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    \n    hdr = (pjmedia_rtcp_fb_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));\n    hdr->rtcp_common.pt = RTCP_PSFB;\n    hdr->rtcp_common.count = 1; \n    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    \n    *length = len;\n\n    return PJ_SUCCESS;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTEST(BasicFlatBufferModel, TestHandleMalformedModelInvalidBuffer) {\n  const auto model_path =\n      \"tensorflow/lite/testdata/segment_sum_invalid_buffer.bin\";\n\n  std::unique_ptr<tflite::FlatBufferModel> model =\n      FlatBufferModel::BuildFromFile(model_path);\n  ASSERT_NE(model, nullptr);\n\n  tflite::ops::builtin::BuiltinOpResolver resolver;\n  InterpreterBuilder builder(*model, resolver);\n  std::unique_ptr<Interpreter> interpreter;\n  ASSERT_EQ(builder(&interpreter), kTfLiteOk);\n  ASSERT_NE(interpreter, nullptr);\n  ASSERT_EQ(interpreter->AllocateTensors(), kTfLiteOk);\n  ASSERT_NE(interpreter->Invoke(), kTfLiteOk);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nrfbBool HandleCursorShape(rfbClient* client,int xhot, int yhot, int width, int height, uint32_t enc)\n{\n  int bytesPerPixel;\n  size_t bytesPerRow, bytesMaskData;\n  rfbXCursorColors rgb;\n  uint32_t colors[2];\n  char *buf;\n  uint8_t *ptr;\n  int x, y, b;\n\n  bytesPerPixel = client->format.bitsPerPixel / 8;\n  bytesPerRow = (width + 7) / 8;\n  bytesMaskData = bytesPerRow * height;\n\n  if (width * height == 0)\n    return TRUE;\n\n  if (width >= MAX_CURSOR_SIZE || height >= MAX_CURSOR_SIZE)\n    return FALSE;\n\n  \n  if(client->rcSource)\n    free(client->rcSource);\n\n  client->rcSource = malloc(width * height * bytesPerPixel);\n  if (client->rcSource == NULL)\n    return FALSE;\n\n  buf = malloc(bytesMaskData);\n  if (buf == NULL) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    return FALSE;\n  }\n\n  \n\n  if (enc == rfbEncodingXCursor) {\n    \n    if (!ReadFromRFBServer(client, (char *)&rgb, sz_rfbXCursorColors)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n    colors[0] = RGB24_TO_PIXEL(32, rgb.backRed, rgb.backGreen, rgb.backBlue);\n    colors[1] = RGB24_TO_PIXEL(32, rgb.foreRed, rgb.foreGreen, rgb.foreBlue);\n\n    \n    if (!ReadFromRFBServer(client, buf, bytesMaskData)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n\n    \n    ptr = client->rcSource;\n    for (y = 0; y < height; y++) {\n      for (x = 0; x < width / 8; x++) {\n\tfor (b = 7; b >= 0; b--) {\n\t  *ptr = buf[y * bytesPerRow + x] >> b & 1;\n\t  ptr += bytesPerPixel;\n\t}\n      }\n      for (b = 7; b > 7 - width % 8; b--) {\n\t*ptr = buf[y * bytesPerRow + x] >> b & 1;\n\tptr += bytesPerPixel;\n      }\n    }\n\n    \n    switch (bytesPerPixel) {\n    case 1:\n      for (x = 0; x < width * height; x++)\n\tclient->rcSource[x] = (uint8_t)colors[client->rcSource[x]];\n      break;\n    case 2:\n      for (x = 0; x < width * height; x++)\n\t((uint16_t *)client->rcSource)[x] = (uint16_t)colors[client->rcSource[x * 2]];\n      break;\n    case 4:\n      for (x = 0; x < width * height; x++)\n\t((uint32_t *)client->rcSource)[x] = colors[client->rcSource[x * 4]];\n      break;\n    }\n\n  } else {\t\t\t\n\n    if (!ReadFromRFBServer(client, (char *)client->rcSource, width * height * bytesPerPixel)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n\n  }\n\n  \n\n  if (!ReadFromRFBServer(client, buf, bytesMaskData)) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    free(buf);\n    return FALSE;\n  }\n\n  client->rcMask = malloc(width * height);\n  if (client->rcMask == NULL) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    free(buf);\n    return FALSE;\n  }\n\n  ptr = client->rcMask;\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width / 8; x++) {\n      for (b = 7; b >= 0; b--) {\n\t*ptr++ = buf[y * bytesPerRow + x] >> b & 1;\n      }\n    }\n    for (b = 7; b > 7 - width % 8; b--) {\n      *ptr++ = buf[y * bytesPerRow + x] >> b & 1;\n    }\n  }\n\n  if (client->GotCursorShape != NULL) {\n     client->GotCursorShape(client, xhot, yhot, width, height, bytesPerPixel);\n  }\n\n  free(buf);\n\n  return TRUE;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nQualifyIpPacket(IPHeader *pIpHeader, ULONG len, BOOLEAN verifyLength)\n{\n    tTcpIpPacketParsingResult res;\n    res.value = 0;\n\n    if (len < 4)\n    {\n        res.ipStatus = ppresNotIP;\n        return res;\n    }\n\n    UCHAR  ver_len = pIpHeader->v4.ip_verlen;\n    UCHAR  ip_version = (ver_len & 0xF0) >> 4;\n    USHORT ipHeaderSize = 0;\n    USHORT fullLength = 0;\n    res.value = 0;\n\n    if (ip_version == 4)\n    {\n        if (len < sizeof(IPv4Header))\n        {\n            res.ipStatus = ppresNotIP;\n            return res;\n        }\n        ipHeaderSize = (ver_len & 0xF) << 2;\n        fullLength = swap_short(pIpHeader->v4.ip_length);\n        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\n            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n\n        res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\n        if (res.ipStatus == ppresNotIP)\n        {\n            return res;\n        }\n\n        if (ipHeaderSize >= fullLength || ( verifyLength && len < fullLength))\n        {\n            DPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d, verify = %s\\n\", __FUNCTION__,\n                ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len, (verifyLength ? \"true\" : \"false\")));\n            res.ipCheckSum = ppresIPTooShort;\n            return res;\n        }\n    }\n    else if (ip_version == 6)\n    {\n        if (len < sizeof(IPv6Header))\n        {\n            res.ipStatus = ppresNotIP;\n            return res;\n        }\n\n        UCHAR nextHeader = pIpHeader->v6.ip6_next_header;\n        BOOLEAN bParsingDone = FALSE;\n        ipHeaderSize = sizeof(pIpHeader->v6);\n        res.ipStatus = ppresIPV6;\n        res.ipCheckSum = ppresCSOK;\n        fullLength = swap_short(pIpHeader->v6.ip6_payload_len);\n        fullLength += ipHeaderSize;\n\n        if (verifyLength && (len < fullLength))\n        {\n            res.ipStatus = ppresNotIP;\n            return res;\n        }\n        while (nextHeader != 59)\n        {\n            IPv6ExtHeader *pExt;\n            switch (nextHeader)\n            {\n                case PROTOCOL_TCP:\n                    bParsingDone = TRUE;\n                    res.xxpStatus = ppresXxpKnown;\n                    res.TcpUdp = ppresIsTCP;\n                    res.xxpFull = len >= fullLength ? 1 : 0;\n                    res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n                    break;\n                case PROTOCOL_UDP:\n                    bParsingDone = TRUE;\n                    res.xxpStatus = ppresXxpKnown;\n                    res.TcpUdp = ppresIsUDP;\n                    res.xxpFull = len >= fullLength ? 1 : 0;\n                    res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\n                    break;\n                                   case 0:\n                case 60:\n                case 43:\n                case 44:\n                case 51:\n                case 50:\n                case 135:\n                    if (len >= ((ULONG)ipHeaderSize + 8))\n                    {\n                        pExt = (IPv6ExtHeader *)((PUCHAR)pIpHeader + ipHeaderSize);\n                        nextHeader = pExt->ip6ext_next_header;\n                        ipHeaderSize += 8;\n                        ipHeaderSize += pExt->ip6ext_hdr_len * 8;\n                    }\n                    else\n                    {\n                        DPrintf(0, (\"[%s] ERROR: Break in the middle of ext. headers(len %d, hdr > %d)\\n\", __FUNCTION__, len, ipHeaderSize));\n                        res.ipStatus = ppresNotIP;\n                        bParsingDone = TRUE;\n                    }\n                    break;\n                                   default:\n                    res.xxpStatus = ppresXxpOther;\n                    bParsingDone = TRUE;\n                    break;\n            }\n            if (bParsingDone)\n                break;\n        }\n        if (ipHeaderSize <= MAX_SUPPORTED_IPV6_HEADERS)\n        {\n            DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",\n                ip_version, ipHeaderSize, nextHeader, fullLength));\n            res.ipHeaderSize = ipHeaderSize;\n        }\n        else\n        {\n            DPrintf(0, (\"[%s] ERROR: IP chain is too large (%d)\\n\", __FUNCTION__, ipHeaderSize));\n            res.ipStatus = ppresNotIP;\n        }\n    }\n    \n    if (res.ipStatus == ppresIPV4)\n    {\n        res.ipHeaderSize = ipHeaderSize;\n\n               res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\n        switch (pIpHeader->v4.ip_protocol)\n        {\n            case PROTOCOL_TCP:\n            {\n                res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        case PROTOCOL_UDP:\n            {\n                res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        default:\n            res.xxpStatus = ppresXxpOther;\n            break;\n        }\n    }\n    return res;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n\n  int32_t* out_buf = GetOutput(context, node, 0)->data.i32;\n  const TfLiteTensor* hash = GetInput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 1);\n  const TfLiteTensor* weight =\n      NumInputs(node) == 2 ? nullptr : GetInput(context, node, 2);\n\n  switch (params->type) {\n    case kTfLiteLshProjectionDense:\n      DenseLshProjection(hash, input, weight, out_buf);\n      break;\n    case kTfLiteLshProjectionSparse:\n      SparseLshProjection(hash, input, weight, out_buf);\n      break;\n    default:\n      return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len;\n\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n\t\t\t\t\t\t     &varint_len);\n\t\tsize_t last_len = strlen(last);\n\t\tsize_t prefix_len = last_len - strip_len;\n\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n\t\tsize_t path_len;\n\n\t\tif (varint_len == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_dealloc(AST_object *self)\n{\n    \n    PyObject_GC_UnTrack(self);\n    Py_CLEAR(self->dict);\n    Py_TYPE(self)->tp_free(self);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic struct desc_struct *get_desc(unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc = NULL;\n\t\tstruct ldt_struct *ldt;\n\n\t\t\n\t\tsel >>= 3;\n\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries)\n\t\t\tdesc = &ldt->entries[sel];\n\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\n\t\treturn desc;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\n\t\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\n\tif (desc_base > gdt_desc.size)\n\t\treturn NULL;\n\n\treturn (struct desc_struct *)(gdt_desc.address + desc_base);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint ecryptfs_privileged_open(struct file **lower_file,\n\t\t\t     struct dentry *lower_dentry,\n\t\t\t     struct vfsmount *lower_mnt,\n\t\t\t     const struct cred *cred)\n{\n\tstruct ecryptfs_open_req req;\n\tint flags = O_LARGEFILE;\n\tint rc = 0;\n\n\tinit_completion(&req.done);\n\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\n\t\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n\t\trc = PTR_ERR(*lower_file);\nout:\n\treturn rc;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic bool check_reg_sane_offset(struct bpf_verifier_env *env,\n\t\t\t\t  const struct bpf_reg_state *reg,\n\t\t\t\t  enum bpf_reg_type type)\n{\n\tbool known = tnum_is_const(reg->var_off);\n\ts64 val = reg->var_off.value;\n\ts64 smin = reg->smin_value;\n\n\tif (known && (val >= BPF_MAX_VAR_OFF || val <= -BPF_MAX_VAR_OFF)) {\n\t\tverbose(env, \"math between %s pointer and %lld is not allowed\\n\",\n\t\t\treg_type_str[type], val);\n\t\treturn false;\n\t}\n\n\tif (reg->off >= BPF_MAX_VAR_OFF || reg->off <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"%s pointer offset %d is not allowed\\n\",\n\t\t\treg_type_str[type], reg->off);\n\t\treturn false;\n\t}\n\n\tif (smin == S64_MIN) {\n\t\tverbose(env, \"math between %s pointer and register with unbounded min value is not allowed\\n\",\n\t\t\treg_type_str[type]);\n\t\treturn false;\n\t}\n\n\tif (smin >= BPF_MAX_VAR_OFF || smin <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"value %lld makes %s pointer be out of bounds\\n\",\n\t\t\tsmin, reg_type_str[type]);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nSPL_METHOD(SplFileObject, setMaxLineLen)\n{\n\tlong max_len;\n\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &max_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (max_len < 0) {\n\t\tzend_throw_exception_ex(spl_ce_DomainException, 0 TSRMLS_CC, \"Maximum line length must be greater than or equal zero\");\n\t\treturn;\n\t}\n\t\n\tintern->u.file.max_line_len = max_len;\n} \n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic char *__filterShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tchar ch = *arg;\n\t\tswitch (ch) {\n\t\tcase '@':\n\t\tcase '`':\n\t\tcase '|':\n\t\tcase ';':\n\t\tcase '=':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = ch;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR) {  \n    luaE_exitCcall(L);  \n    luaE_enterCcall(L);  \n  }\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsearch_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    \n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\t\t\t\t\n    op->tas.rsize = size;\t\t\t\t\n    push(2);\n    op[-1] = *op1;\t\t\t\t\t\n    op[-3].value.bytes = ptr + size;\t\t\t\n    if (forward) {\n        op[-1].tas.rsize = ptr - op[-1].value.bytes;\t\n        op[-3].tas.rsize = count;\t\t\t\n    } else {\n        op[-1].tas.rsize = count;\t\t\t\n        op[-3].tas.rsize -= count + size;\t\t\n    }\n    make_true(op);\n    return 0;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint TLSInStream::pos()\n{\n  return offset + ptr - start;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int on_header_value(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->header_field)\n        CASE(OGS_SBI_CONTENT_TYPE)\n            if (data->part[data->num_of_part].content_type)\n                ogs_free(data->part[data->num_of_part].content_type);\n            data->part[data->num_of_part].content_type =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_type);\n            break;\n        CASE(OGS_SBI_CONTENT_ID)\n            if (data->part[data->num_of_part].content_id)\n                ogs_free(data->part[data->num_of_part].content_id);\n            data->part[data->num_of_part].content_id =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_id);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown header field [%s]\", data->header_field);\n        END\n    }\n\n    return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node,\n                             const TfLiteConvParams* params, int width,\n                             int height, int filter_width, int filter_height,\n                             int out_width, int out_height,\n                             const TfLiteType data_type, OpData* data) {\n  bool has_bias = node->inputs->size == 3;\n   TF_LITE_ENSURE(context, has_bias || node->inputs->size == 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n\n   auto padding = params->padding;\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width,\n      params->dilation_height_factor, params->dilation_width_factor, height,\n      width, filter_height, filter_width, padding, &out_height, &out_width);\n\n    if (data_type != kTfLiteFloat32) {\n    const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n    TF_LITE_ENSURE(context, input != nullptr);\n    const TfLiteTensor* filter = GetInput(context, node, kFilterTensor);\n    TF_LITE_ENSURE(context, filter != nullptr);\n    const TfLiteTensor* bias =\n        GetOptionalInputTensor(context, node, kBiasTensor);\n    TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n    TF_LITE_ENSURE(context, output != nullptr);\n    int output_channels = filter->dims->data[kConvQuantizedDimension];\n\n    TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams(\n        context, input, filter, bias, output, params->activation,\n        &data->output_multiplier, &data->output_shift,\n        &data->output_activation_min, &data->output_activation_max,\n        data->per_channel_output_multiplier,\n        reinterpret_cast<int*>(data->per_channel_output_shift),\n        output_channels));\n  }\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_flags = op->open_flag;\n\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out2;\n\t}\n\n\terror = path_init(dfd, pathname, flags, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { \n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n\t}\nout:\n\tpath_cleanup(nd);\nout2:\n\tif (!(opened & FILE_OPENED)) {\n\t\tBUG_ON(!error);\n\t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void Compute(OpKernelContext *ctx) override {\n    const Tensor *indices_t, *values_t, *shape_t, *dense_t;\n    OP_REQUIRES_OK(ctx, ctx->input(\"sp_indices\", &indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"sp_values\", &values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"sp_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense\", &dense_t));\n\n       OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices_t->shape()),\n                errors::InvalidArgument(\n                    \"Input sp_indices should be a matrix but received shape: \",\n                    indices_t->shape().DebugString()));\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(values_t->shape()) &&\n                    TensorShapeUtils::IsVector(shape_t->shape()),\n                errors::InvalidArgument(\n                    \"Inputs sp_values and sp_shape should be vectors \"\n                    \"but received shapes: \",\n                    values_t->shape().DebugString(), \" and \",\n                    shape_t->shape().DebugString()));\n    OP_REQUIRES(\n        ctx, TensorShapeUtils::IsVector(shape_t->shape()),\n        errors::InvalidArgument(\"Input sp_shape must be a vector. Got: \",\n                                shape_t->shape().DebugString()));\n    OP_REQUIRES(\n        ctx, values_t->dim_size(0) == indices_t->dim_size(0),\n        errors::InvalidArgument(\n            \"The first dimension of values and indices should match. (\",\n            values_t->dim_size(0), \" vs. \", indices_t->dim_size(0), \")\"));\n    OP_REQUIRES(\n        ctx, shape_t->shape().dim_size(0) == indices_t->shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices. \",\n            \"Got \", shape_t->shape().dim_size(0),\n            \" dimensions, indices shape: \", indices_t->shape().DebugString()));\n    OP_REQUIRES(ctx, shape_t->NumElements() > 0,\n                errors::InvalidArgument(\n                    \"The shape argument requires at least one element.\"));\n\n    const auto indices_mat = indices_t->matrix<int64_t>();\n    const auto shape_vec = shape_t->vec<int64_t>();\n    const auto lhs_dims = BCast::FromShape(TensorShape(shape_vec));\n    const auto rhs_dims = BCast::FromShape(dense_t->shape());\n    BCast b(lhs_dims, rhs_dims, false); \n          auto VecGreaterEq = [](ArraySlice<int64_t> lhs, ArraySlice<int64_t> rhs) {\n      if (lhs.size() < rhs.size()) return false;\n      for (size_t i = 0; i < rhs.size(); ++i) {\n        if (lhs[lhs.size() - 1 - i] < rhs[rhs.size() - 1 - i]) return false;\n      }\n      return true;\n    };\n    OP_REQUIRES(ctx, VecGreaterEq(lhs_dims, rhs_dims) && b.IsValid(),\n                errors::InvalidArgument(\n                    \"SparseDenseBinaryOpShared broadcasts dense to sparse \"\n                    \"only; got incompatible shapes: [\",\n                    absl::StrJoin(lhs_dims, \",\"), \"] vs. [\",\n                    absl::StrJoin(rhs_dims, \",\"), \"]\"));\n\n    Tensor *output_values = nullptr;\n    Tensor dense_gathered;\n    const int64_t nnz = indices_t->dim_size(0);\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({nnz}), &output_values));\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_temp(DataTypeToEnum<T>::value, TensorShape({nnz}),\n                                &dense_gathered));\n    bool op_is_div = false;\n    if (absl::StrContains(ctx->op_kernel().type_string_view(), \"Div\")) {\n      op_is_div = true;\n    }\n                      auto dense_gathered_flat = dense_gathered.flat<T>();\n    const int ndims = lhs_dims.size();\n    switch (ndims) {\n#define CASE(NDIM)                                                             \\\n  case NDIM: {                                                                 \\\n    TensorRef<Eigen::Tensor<const T, NDIM, Eigen::RowMajor>> rhs_ref =         \\\n        dense_t->shaped<T, NDIM>(b.y_reshape())                                \\\n            .broadcast(BCast::ToIndexArray<NDIM>(b.y_bcast()));                \\\n    Eigen::array<Eigen::DenseIndex, NDIM> idx;                                 \\\n    bool indices_valid = true;                                                 \\\n    for (int i = 0; i < nnz; ++i) {                                            \\\n      for (int d = 0; d < NDIM; ++d) {                                         \\\n        idx[d] = internal::SubtleMustCopy(indices_mat(i, d));                  \\\n        if (!FastBoundsCheck(idx[d], rhs_ref.dimension(d))) {                  \\\n          indices_valid = false;                                               \\\n        }                                                                      \\\n      }                                                                        \\\n      OP_REQUIRES(                                                             \\\n          ctx, indices_valid,                                                  \\\n          errors::InvalidArgument(\"Provided indices are out-of-bounds w.r.t. \" \\\n                                  \"dense side with broadcasted shape\"));       \\\n      dense_gathered_flat(i) = rhs_ref.coeff(idx);                             \\\n      if (op_is_div) {                                                         \\\n        OP_REQUIRES(ctx, dense_gathered_flat(i) != 0,                          \\\n                    errors::InvalidArgument(                                   \\\n                        \"SparseDenseCwiseDiv cannot divide by zero,\"           \\\n                        \"but input dense tensor contains zero \"));             \\\n      }                                                                        \\\n    }                                                                          \\\n    break;                                                                     \\\n  }\n\n      CASE(1);\n      CASE(2);\n      CASE(3);\n      CASE(4);\n      CASE(5);\n      default:\n        OP_REQUIRES(\n            ctx, false,\n            errors::InvalidArgument(\"Only tensors with ranks between 1 and 5 \"\n                                    \"are currently supported.  Tensor rank: \",\n                                    ndims));\n#undef CASE\n    }\n\n    output_values->flat<T>().device(ctx->eigen_device<Device>()) =\n        values_t->flat<T>().binaryExpr(dense_gathered_flat,\n                                       typename Functor::func());\n  }\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbuild_principal_va(krb5_context context, krb5_principal princ,\n                   unsigned int rlen, const char *realm, va_list ap)\n{\n    krb5_error_code retval = 0;\n    char *r = NULL;\n    krb5_data *data = NULL;\n    krb5_int32 count = 0;\n    krb5_int32 size = 2;  \n    char *component = NULL;\n\n    data = malloc(size * sizeof(krb5_data));\n    if (!data) { retval = ENOMEM; }\n\n    if (!retval) {\n        r = strdup(realm);\n        if (!r) { retval = ENOMEM; }\n    }\n\n    while (!retval && (component = va_arg(ap, char *))) {\n        if (count == size) {\n            krb5_data *new_data = NULL;\n\n            size *= 2;\n            new_data = realloc(data, size * sizeof(krb5_data));\n            if (new_data) {\n                data = new_data;\n            } else {\n                retval = ENOMEM;\n            }\n        }\n\n        if (!retval) {\n            data[count].length = strlen(component);\n            data[count].data = strdup(component);\n            if (!data[count].data) { retval = ENOMEM; }\n            count++;\n        }\n    }\n\n    if (!retval) {\n        princ->type = KRB5_NT_UNKNOWN;\n        princ->magic = KV5M_PRINCIPAL;\n        princ->realm = make_data(r, rlen);\n        princ->data = data;\n        princ->length = count;\n        r = NULL;    \n        data = NULL; \n    }\n\n    if (data) {\n        while (--count >= 0) {\n            free(data[count].data);\n        }\n        free(data);\n    }\n    free(r);\n\n    return retval;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\t\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\n\t\n\tif ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)\n\t    && !vendor_intel(ctxt))\n\t\treturn emulate_ud(ctxt);\n\n\t\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tctxt->eflags &= ~(EFLG_VM | EFLG_IF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n\tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;\n\n\treturn X86EMUL_CONTINUE;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Privilege Management"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic inline bool key_is_positive(const struct key *key)\n{\n\treturn key_read_state(key) == KEY_IS_POSITIVE;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid VariableUnserializer::unserializeProp(ObjectData* obj,\n                                           const String& key,\n                                           Class* ctx,\n                                           const String& realKey,\n                                           int nProp) {\n\n  auto const cls = obj->getVMClass();\n  auto const lookup = cls->getDeclPropSlot(ctx, key.get());\n  auto const slot = lookup.slot;\n  tv_lval t;\n\n  if (slot == kInvalidSlot || !lookup.accessible) {\n             obj->reserveDynProps(nProp);\n    t = obj->makeDynProp(realKey.get());\n  } else {\n          t = obj->getPropLval(ctx, key.get());\n  }\n\n  unserializePropertyValue(t, nProp);\n  if (!RuntimeOption::RepoAuthoritative) return;\n  if (!Repo::get().global().HardPrivatePropInference) return;\n\n  \n  if (UNLIKELY(slot == kInvalidSlot)) return;\n  auto const repoTy = cls->declPropRepoAuthType(slot);\n  if (LIKELY(tvMatchesRepoAuthType(*t, repoTy))) return;\n  if (t.type() == KindOfUninit &&\n      (cls->declProperties()[slot].attrs & AttrLateInit)) {\n    return;\n  }\n  throwUnexpectedType(key, obj, *t);\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\n\tDBG(\"\");\n\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\n\t\n\tif (!(adapter->current_settings & MGMT_OP_SET_DISCOVERABLE)) {\n\t\tGSList *l;\n\n\t\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\t\tstruct discovery_client *client = l->data;\n\n\t\t\tif (!client->discovery_filter)\n\t\t\t\tcontinue;\n\n\t\t\tif (client->discovery_filter->discoverable) {\n\t\t\t\tset_discovery_discoverable(adapter, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\n\ttrigger_start_discovery(adapter, 0);\n\n\treturn -EINPROGRESS;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nHexOutStream::HexOutStream(OutStream& os, int buflen)\n: out_stream(os), offset(0), bufSize(buflen ? buflen : DEFAULT_BUF_LEN)\n{\n  if (bufSize % 2)\n    bufSize--;\n  ptr = start = new U8[bufSize];\n  end = start + bufSize;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPJ_DEF(void) pjmedia_rtcp_rx_rtcp( pjmedia_rtcp_session *sess,\n\t\t\t\t   const void *pkt,\n\t\t\t\t   pj_size_t size)\n{\n    pj_uint8_t *p, *p_end;\n\n    p = (pj_uint8_t*)pkt;\n    p_end = p + size;\n    while (p < p_end) {\n\tpjmedia_rtcp_common *common;\n\tunsigned len;\n\n\tif (p + sizeof(pjmedia_rtcp_common) > p_end) {\n\t    TRACE_((sess->name, \"Receiving truncated RTCP packet (1)\"));\n\t    break;\n\t}\n\tcommon = (pjmedia_rtcp_common*)p;\n\n\tlen = (pj_ntohs((pj_uint16_t)common->length)+1) * 4;\n\tif (p + len > p_end) {\n\t    TRACE_((sess->name, \"Receiving truncated RTCP packet (2)\"));\n\t    break;\n\t}\n\n\tswitch(common->pt) {\n\tcase RTCP_SR:\n\tcase RTCP_RR:\n\tcase RTCP_XR:\n\t    parse_rtcp_report(sess, p, len);\n\t    break;\n\tcase RTCP_SDES:\n\t    parse_rtcp_sdes(sess, p, len);\n\t    break;\n\tcase RTCP_BYE:\n\t    parse_rtcp_bye(sess, p, len);\n\t    break;\n\tcase RTCP_RTPFB:\n\tcase RTCP_PSFB:\n\t    parse_rtcp_fb(sess, p, len);\n\t    break;\n\tdefault:\n\t    \n\t    TRACE_((sess->name, \"Received unknown RTCP packet type=%d\",\n\t\t    common->pt));\n\t    break;\n\t}\n\n\tp += len;\n    }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_sli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *sli_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);\n\n    \n    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 2)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->rtcp_common.length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *sli_cnt = PJ_MIN(*sli_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *sli_cnt; ++i) {\n\t\n\tsli[i].first = (p[0] << 5) + ((p[1] & 0xF8) >> 3);\n\t\n\tsli[i].number = ((p[1] & 0x07) << 10) +\n\t\t\t(p[2] << 2) +\n\t\t\t((p[3] & 0xC0) >> 6);\n\t\n\tsli[i].pict_id = (p[3] & 0x3F);\n\tp += 4;\n    }\n\n    return PJ_SUCCESS;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* data =\n      reinterpret_cast<TfLiteAudioMicrofrontendParams*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 1);\n\n  TF_LITE_ENSURE_EQ(context, input->type, kTfLiteInt16);\n  output->type = kTfLiteInt32;\n  if (data->out_float) {\n    output->type = kTfLiteFloat32;\n  }\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(2);\n  int num_frames = 0;\n  if (input->dims->data[0] >= data->state->window.size) {\n    num_frames = (input->dims->data[0] - data->state->window.size) /\n                     data->state->window.step / data->frame_stride +\n                 1;\n  }\n  output_size->data[0] = num_frames;\n  output_size->data[1] = data->state->filterbank.num_channels *\n                         (1 + data->left_context + data->right_context);\n\n  return context->ResizeTensor(context, output, output_size);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstd::shared_ptr<SQLiteDBInstance> getTestDBC() {\n  auto dbc = SQLiteDBManager::getUnique();\n\n  char* err = nullptr;\n  std::vector<std::string> queries = {\n      \"CREATE TABLE test_table (username varchar(30), age int)\",\n      \"INSERT INTO test_table VALUES (\\\"mike\\\", 23)\",\n      \"INSERT INTO test_table VALUES (\\\"matt\\\", 24)\"};\n\n  for (auto q : queries) {\n    sqlite3_exec(dbc->db(), q.c_str(), nullptr, nullptr, &err);\n    if (err != nullptr) {\n      throw std::domain_error(std::string(\"Cannot create testing DBC's db: \") +\n                              err);\n    }\n  }\n\n  return dbc;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbool Inflator::DecodeBody()\n{\n\tbool blockEnd = false;\n\tswitch (m_blockType)\n\t{\n\tcase 0:\t\tCRYPTOPP_ASSERT(m_reader.BitsBuffered() == 0);\n\t\twhile (!m_inQueue.IsEmpty() && !blockEnd)\n\t\t{\n\t\t\tsize_t size;\n\t\t\tconst byte *block = m_inQueue.Spy(size);\n\t\t\tsize = UnsignedMin(m_storedLen, size);\n\t\t\tCRYPTOPP_ASSERT(size <= 0xffff);\n\n\t\t\tOutputString(block, size);\n\t\t\tm_inQueue.Skip(size);\n\t\t\tm_storedLen = m_storedLen - (word16)size;\n\t\t\tif (m_storedLen == 0)\n\t\t\t\tblockEnd = true;\n\t\t}\n\t\tbreak;\n\tcase 1:\tcase 2:\t\tstatic const unsigned int lengthStarts[] = {\n\t\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n\t\t\t35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};\n\t\tstatic const unsigned int lengthExtraBits[] = {\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\t\tstatic const unsigned int distanceStarts[] = {\n\t\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n\t\t\t257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n\t\t\t8193, 12289, 16385, 24577};\n\t\tstatic const unsigned int distanceExtraBits[] = {\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n\t\t\t12, 12, 13, 13};\n\n\t\tconst HuffmanDecoder& literalDecoder = GetLiteralDecoder();\n\t\tconst HuffmanDecoder& distanceDecoder = GetDistanceDecoder();\n\n\t\tswitch (m_nextDecode)\n\t\t{\n\t\tcase LITERAL:\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (!literalDecoder.Decode(m_reader, m_literal))\n\t\t\t\t{\n\t\t\t\t\tm_nextDecode = LITERAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (m_literal < 256)\n\t\t\t\t\tOutputByte((byte)m_literal);\n\t\t\t\telse if (m_literal == 256)\t\t\t\t{\n\t\t\t\t\tblockEnd = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (m_literal > 285)\n\t\t\t\t\t\tthrow BadBlockErr();\n\t\t\t\t\tunsigned int bits;\n\t\tcase LENGTH_BITS:\n\t\t\t\t\tbits = lengthExtraBits[m_literal-257];\n\t\t\t\t\tif (!m_reader.FillBuffer(bits))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_nextDecode = LENGTH_BITS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tm_literal = m_reader.GetBits(bits) + lengthStarts[m_literal-257];\n\t\tcase DISTANCE:\n\t\t\t\t\tif (!distanceDecoder.Decode(m_reader, m_distance))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_nextDecode = DISTANCE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\tcase DISTANCE_BITS:\n\t\t\t\t\t\t\t\t\tCRYPTOPP_ASSERT(m_distance < COUNTOF(distanceExtraBits));\n\t\t\t\t\tif (m_distance >= COUNTOF(distanceExtraBits))\n\t\t\t\t\t\tthrow BadDistanceErr();\n\t\t\t\t\tbits = distanceExtraBits[m_distance];\n\t\t\t\t\tif (!m_reader.FillBuffer(bits))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_nextDecode = DISTANCE_BITS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tCRYPTOPP_ASSERT(m_distance < COUNTOF(distanceStarts));\n\t\t\t\t\tif (m_distance >= COUNTOF(distanceStarts))\n\t\t\t\t\t\tthrow BadDistanceErr();\n\t\t\t\t\tm_distance = m_reader.GetBits(bits) + distanceStarts[m_distance];\n\t\t\t\t\tOutputPast(m_literal, m_distance);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCRYPTOPP_ASSERT(0);\n\t\t}\n\t}\n\tif (blockEnd)\n\t{\n\t\tif (m_eof)\n\t\t{\n\t\t\tFlushOutput();\n\t\t\tm_reader.SkipBits(m_reader.BitsBuffered()%8);\n\t\t\tif (m_reader.BitsBuffered())\n\t\t\t{\n\t\t\t\t\t\t\tSecBlockWithHint<byte, 4> buffer(m_reader.BitsBuffered() / 8);\n\t\t\t\tfor (unsigned int i=0; i<buffer.size(); i++)\n\t\t\t\t\tbuffer[i] = (byte)m_reader.GetBits(8);\n\t\t\t\tm_inQueue.Unget(buffer, buffer.size());\n\t\t\t}\n\t\t\tm_state = POST_STREAM;\n\t\t}\n\t\telse\n\t\t\tm_state = WAIT_HEADER;\n\t}\n\treturn blockEnd;\n}\n\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmcs_recv_connect_response(STREAM mcs_data)\n{\n\tUNUSED(mcs_data);\n\tuint8 result;\n\tint length;\n\tSTREAM s;\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\tber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\n\n\tber_parse_header(s, BER_TAG_RESULT, &length);\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);\n\t\treturn False;\n\t}\n\n\tber_parse_header(s, BER_TAG_INTEGER, &length);\n\tin_uint8s(s, length);\t\n\tmcs_parse_domain_params(s);\n\n\tber_parse_header(s, BER_TAG_OCTET_STRING, &length);\n\n\tsec_process_mcs_data(s);\n\t\n\treturn s_check_end(s);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint TLSInStream::readTLS(U8* buf, int len, bool wait)\n{\n  int n;\n\n  n = in->check(1, 1, wait);\n  if (n == 0)\n    return 0;\n\n  n = gnutls_record_recv(session, (void *) buf, len);\n  if (n == GNUTLS_E_INTERRUPTED || n == GNUTLS_E_AGAIN)\n    return 0;\n\n  if (n < 0) throw TLSException(\"readTLS\", n);\n\n  return n;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += bytes_read;\n        }\n\n        return 1;\n} \n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int nsv_read_chunk(AVFormatContext *s, int fill_header)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; \n    uint32_t vsize;\n    uint16_t asize;\n    uint16_t auxsize;\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n        return 0;\nnull_chunk_retry:\n    if (pb->eof_reached)\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n    if (err < 0)\n        return err;\n    if (nsv->state == NSV_FOUND_NSVS)\n        err = nsv_parse_NSVs_header(s);\n    if (err < 0)\n        return err;\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n        return -1;\n\n    auxcount = avio_r8(pb);\n    vsize = avio_rl16(pb);\n    asize = avio_rl16(pb);\n    vsize = (vsize << 4) | (auxcount >> 4);\n    auxcount &= 0x0f;\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n           auxcount, vsize, asize);\n    \n    for (i = 0; i < auxcount; i++) {\n        uint32_t av_unused auxtag;\n        auxsize = avio_rl16(pb);\n        auxtag = avio_rl32(pb);\n        avio_skip(pb, auxsize);\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); \n    }\n\n    if (pb->eof_reached)\n        return -1;\n    if (!vsize && !asize) {\n        nsv->state = NSV_UNSYNC;\n        goto null_chunk_retry;\n    }\n\n    \n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n        nst = st[NSV_ST_VIDEO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n        av_get_packet(pb, pkt, vsize);\n        pkt->stream_index = st[NSV_ST_VIDEO]->index        pkt->dts = nst->frame_offset;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; \n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                   i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n    if (asize && st[NSV_ST_AUDIO]) {\n        nst = st[NSV_ST_AUDIO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n        \n        \n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')) {\n            uint8_t bps;\n            uint8_t channels;\n            uint16_t samplerate;\n            bps = avio_r8(pb);\n            channels = avio_r8(pb);\n            samplerate = avio_rl16(pb);\n            if (!channels || !samplerate)\n                return AVERROR_INVALIDDATA;\n            asize-=4;\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                   bps, channels, samplerate);\n            if (fill_header) {\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; \n                if (bps != 16) {\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n                }\n                bps /= channels;                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate /= 4;\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                       bps, channels, samplerate);\n            }\n        }\n        av_get_packet(pb, pkt, asize);\n        pkt->stream_index = st[NSV_ST_AUDIO]->index        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; \n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            \n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n                   nsv->avsync, pkt->dts);\n        }\n        nst->frame_offset++;\n    }\n\n    nsv->state = NSV_UNSYNC;\n    return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int pop_sync_mailbox (CONTEXT *ctx, int *index_hint)\n{\n  int i, j, ret = 0;\n  char buf[LONG_STRING];\n  POP_DATA *pop_data = (POP_DATA *)ctx->data;\n  progress_t progress;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n#endif\n\n  pop_data->check_time = 0;\n\n  FOREVER\n  {\n    if (pop_reconnect (ctx) < 0)\n      return -1;\n\n    mutt_progress_init (&progress, _(\"Marking messages deleted...\"),\n\t\t\tMUTT_PROGRESS_MSG, WriteInc, ctx->deleted);\n\n#if USE_HCACHE\n    hc = pop_hcache_open (pop_data, ctx->path);\n#endif\n\n    for (i = 0, j = 0, ret = 0; ret == 0 && i < ctx->msgcount; i++)\n    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n\tj++;\n\tif (!ctx->quiet)\n\t  mutt_progress_update (&progress, j, -1);\n\tsnprintf (buf, sizeof (buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n\tif ((ret = pop_query (pop_data, buf, sizeof (buf))) == 0)\n\t{\n\t  mutt_bcache_del (pop_data->bcache, cache_id (ctx->hdrs[i]->data));\n#if USE_HCACHE\n\t  mutt_hcache_delete (hc, ctx->hdrs[i]->data, strlen);\n#endif\n\t}\n      }\n\n#if USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n\tmutt_hcache_store (hc, ctx->hdrs[i]->data, ctx->hdrs[i], 0, strlen, MUTT_GENERATE_UIDVALIDITY);\n      }\n#endif\n\n    }\n\n#if USE_HCACHE\n    mutt_hcache_close (hc);\n#endif\n\n    if (ret == 0)\n    {\n      strfcpy (buf, \"QUIT\\r\\n\", sizeof (buf));\n      ret = pop_query (pop_data, buf, sizeof (buf));\n    }\n\n    if (ret == 0)\n    {\n      pop_data->clear_cache = 1;\n      pop_clear_cache (pop_data);\n      pop_data->status = POP_DISCONNECTED;\n      return 0;\n    }\n\n    if (ret == -2)\n    {\n      mutt_error (\"%s\", pop_data->err_msg);\n      mutt_sleep (2);\n      return -1;\n    }\n  }\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nparse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n    char *line, int *err, gchar **err_info)\n{\n\tint\t\tpkt_len;\n\tint\t\tsec;\n\tint\t\tdsec;\n\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n\tchar\t\tdirection[2];\n\tchar\t\tcap_src[13];\n\tchar\t\tcap_dst[13];\n\tguint8\t\t*pd;\n\tgchar\t\t*p;\n\tint\t\tn, i = 0;\n\tint\t\toffset = 0;\n\tgchar\t\tdststr[13];\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\n\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",\n\t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n\t\treturn -1;\n\t}\n\tif (pkt_len < 0) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"netscreen: packet header has a negative packet length\");\n\t\treturn FALSE;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n\t\t\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\t\n\n\tphdr->ts.secs  = sec;\n\tphdr->ts.nsecs = dsec * 100000000;\n\tphdr->len = pkt_len;\n\n\t\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\twhile(1) {\n\n\t\t\n\t\tif (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tfor (p = &line[0]; g_ascii_isspace(*p); p++)\n\t\t\t;\n\t\t\n\t\tif (*p == '\\0') {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = parse_single_hex_dump_line(p, pd, offset);\n\n\t\t\n\t\tif (offset == 0 && n < 6) {\n\t\t\tif (info_line(line)) {\n\t\t\t\tif (++i <= NETSCREEN_MAX_INFOLINES) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tif (n == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t\n\t\toffset += n;\n\n\t\t\n\t\tif (offset > pkt_len) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"netscreen: too much hex-data\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t\n\tif (strncmp(cap_int, \"adsl\", 4) == 0) {\n\t\t\n\t\tg_snprintf(dststr, 13, \"%02x%02x%02x%02x%02x%02x\",\n\t\t   pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);\n\t\tif (strncmp(dststr, cap_dst, 12) == 0)\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\telse\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\t\t}\n\telse if (strncmp(cap_int, \"seri\", 4) == 0)\n\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\telse\n\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\n\tphdr->caplen = offset;\n\n\treturn TRUE;\n}\n```\n\nResponse:\n", "label": false, "cwe_name": "N/A"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_for_for_stmt(struct compiling *c, const node *n0, bool is_async)\n{\n    const node * const n = is_async ? CHILD(n0, 1) : n0;\n    asdl_seq *_target, *seq = NULL, *suite_seq;\n    expr_ty expression;\n    expr_ty target, first;\n    const node *node_target;\n    int end_lineno, end_col_offset;\n    \n    REQ(n, for_stmt);\n\n    if (NCH(n) == 9) {\n        seq = ast_for_suite(c, CHILD(n, 8));\n        if (!seq)\n            return NULL;\n    }\n\n    node_target = CHILD(n, 1);\n    _target = ast_for_exprlist(c, node_target, Store);\n    if (!_target)\n        return NULL;\n    \n    first = (expr_ty)asdl_seq_GET(_target, 0);\n    if (NCH(node_target) == 1)\n        target = first;\n    else\n        target = Tuple(_target, Store, first->lineno, first->col_offset,\n                       node_target->n_end_lineno, node_target->n_end_col_offset,\n                       c->c_arena);\n\n    expression = ast_for_testlist(c, CHILD(n, 3));\n    if (!expression)\n        return NULL;\n    suite_seq = ast_for_suite(c, CHILD(n, 5));\n    if (!suite_seq)\n        return NULL;\n\n    if (seq != NULL) {\n        get_last_end_pos(seq, &end_lineno, &end_col_offset);\n    } else {\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n    }\n    if (is_async)\n        return AsyncFor(target, expression, suite_seq, seq,\n                        LINENO(n0), n0->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    else\n        return For(target, expression, suite_seq, seq,\n                   LINENO(n), n->n_col_offset,\n                   end_lineno, end_col_offset, c->c_arena);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void nodeDestruct(struct SaveNode* node)\n{\n    if (node->v == &node->sorted)\n    {\n        tr_free(node->sorted.val.l.vals);\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nfiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  switch (status) {\n  case MRB_FIBER_TRANSFERRED:\n    if (resume) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n    }\n    break;\n  case MRB_FIBER_RUNNING:\n  case MRB_FIBER_RESUMED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume\");\n    break;\n  case MRB_FIBER_TERMINATED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n    break;\n  default:\n    break;\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n\n    if (!c->ci->proc) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"double resume (current)\");\n    }\n    mrb_stack_extend(mrb, len+2); \n    b = c->stbase+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n    if (vmexec) {\n      c->ci--;                    \n    }\n    c->cibase->n = len;\n    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n    if (vmexec) {\n      c->ci[1].stack[0] = value;\n    }\n  }\n\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ndtls1_process_record(SSL *s)\n{\n\tint i,al;\n\tint enc_err;\n\tSSL_SESSION *sess;\n\tSSL3_RECORD *rr;\n\tunsigned int mac_size;\n\tunsigned char md[EVP_MAX_MD_SIZE];\n\n\trr= &(s->s3->rrec);\n\tsess = s->session;\n\n\t\n\trr->input= &(s->packet[DTLS1_RT_HEADER_LENGTH]);\n\n\t \n\n\t\n\n\t\n\tif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)\n\t\t{\n\t\tal=SSL_AD_RECORD_OVERFLOW;\n\t\tSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n\t\tgoto f_err;\n\t\t}\n\n\t\n\trr->data=rr->input;\n\trr->orig_len=rr->length;\n\n\tenc_err = s->method->ssl3_enc->enc(s,0);\n\t\n\tif (enc_err == 0)\n\t\t{\n\t\t\n\t\trr->length = 0;\n\t\ts->packet_length = 0;\n\t\tgoto err;\n\t\t}\n\n#ifdef TLS_DEBUG\nprintf(\"dec %d\\n\",rr->length);\n{ unsigned int z; for (z=0; z<rr->length; z++) printf(\"%02X%c\",rr->data[z],((z+1)%16)?' ':'\\n'); }\nprintf(\"\\n\");\n#endif\n\n\t\n\tif ((sess != NULL) &&\n\t    (s->enc_read_ctx != NULL) &&\n\t    (EVP_MD_CTX_md(s->read_hash) != NULL))\n\t\t{\n\t\t\n\t\tunsigned char *mac = NULL;\n\t\tunsigned char mac_tmp[EVP_MAX_MD_SIZE];\n\t\tmac_size=EVP_MD_CTX_size(s->read_hash);\n\t\tOPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n\n\t\t\n\t\tif (rr->orig_len < mac_size ||\n\t\t    \n\t\t    (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n\t\t     rr->orig_len < mac_size+1))\n\t\t\t{\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE)\n\t\t\t{\n\t\t\t\n\t\t\tmac = mac_tmp;\n\t\t\tssl3_cbc_copy_mac(mac_tmp, rr, mac_size);\n\t\t\trr->length -= mac_size;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t\n\t\t\trr->length -= mac_size;\n\t\t\tmac = &rr->data[rr->length];\n\t\t\t}\n\n\t\ti=s->method->ssl3_enc->mac(s,md,0 );\n\t\tif (i < 0 || mac == NULL || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)\n\t\t\tenc_err = -1;\n\t\tif (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+mac_size)\n\t\t\tenc_err = -1;\n\t\t}\n\n\tif (enc_err < 0)\n\t\t{\n\t\t\n\t\trr->length = 0;\n\t\ts->packet_length = 0;\n\t\tgoto err;\n\t\t}\n\n\t\n\tif (s->expand != NULL)\n\t\t{\n\t\tif (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH)\n\t\t\t{\n\t\t\tal=SSL_AD_RECORD_OVERFLOW;\n\t\t\tSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_COMPRESSED_LENGTH_TOO_LONG);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (!ssl3_do_uncompress(s))\n\t\t\t{\n\t\t\tal=SSL_AD_DECOMPRESSION_FAILURE;\n\t\t\tSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_BAD_DECOMPRESSION);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\n\tif (rr->length > SSL3_RT_MAX_PLAIN_LENGTH)\n\t\t{\n\t\tal=SSL_AD_RECORD_OVERFLOW;\n\t\tSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_DATA_LENGTH_TOO_LONG);\n\t\tgoto f_err;\n\t\t}\n\n\trr->off=0;\n\t\n\n\t\n\ts->packet_length=0;\n\tdtls1_record_bitmap_update(s, &(s->d1->bitmap));\n\treturn(1);\n\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\treturn(0);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nR_API char *r_socket_http_get(const char *url, int *code, int *rlen) {\n\tchar *curl_env = r_sys_getenv (\"R2_CURL\");\n\tif (curl_env && *curl_env) {\n\t\tchar *encoded_url = r_str_escape (url);\n\t\tchar *res = r_sys_cmd_strf (\"curl '%s'\", encoded_url);\n\t\tfree (encoded_url);\n\t\tif (res) {\n\t\t\tif (code) {\n\t\t\t\t*code = 200;\n\t\t\t}\n\t\t\tif (rlen) {\n\t\t\t\t*rlen = strlen (res);\n\t\t\t}\n\t\t}\n\t\tfree (curl_env);\n\t\treturn res;\n\t}\n\tfree (curl_env);\n\tRSocket *s;\n\tint ssl = r_str_startswith (url, \"https://\");\n\tchar *response, *host, *path, *port = \"80\";\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\n\tif (code) {\n\t\t*code = 0;\n\t}\n\tif (rlen) {\n\t\t*rlen = 0;\n\t}\n\thost = strstr (uri, \"://\");\n\tif (!host) {\n\t\tfree (uri);\n\t\teprintf (\"r_socket_http_get: Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tport = strchr (host, ':');\n\tif (!port) {\n\t\tport = ssl? \"443\": \"80\";\n\t\tpath = host;\n\t} else {\n\t\t*port++ = 0;\n\t\tpath = port;\n\t}\n\tpath = strchr (path, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\teprintf (\"r_socket_http_get: Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (r_socket_connect_tcp (s, host, port, 0)) {\n\t\tr_socket_printf (s,\n\t\t\t\t\"GET /%s HTTP/1.1\\r\\n\"\n\t\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\t\"Accept: */*\\r\\n\"\n\t\t\t\t\"Host: %s:%s\\r\\n\"\n\t\t\t\t\"\\r\\n\", path, host, port);\n\t\tresponse = r_socket_http_answer (s, code, rlen);\n\t} else {\n\t\teprintf (\"Cannot connect to %s:%s\\n\", host, port);\n\t\tresponse = NULL;\n\t}\n\tfree (uri);\n\tr_socket_free (s);\n\treturn response;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "OS Command Injection"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n   const TfLiteTensor* input = GetInput(context, node, kInput);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* axis = GetInput(context, node, kAxis);\n  if (IsDynamicTensor(output)) {\n    int axis_value;\n    TF_LITE_ENSURE_OK(context,\n                      GetAxisValueFromTensor(context, *axis, &axis_value));\n    TF_LITE_ENSURE_OK(context,\n                      ExpandTensorDim(context, *input, axis_value, output));\n  }\n  if (output->type == kTfLiteString) {\n    TfLiteTensorRealloc(input->bytes, output);\n  }\n  memcpy(output->data.raw, input->data.raw, input->bytes);\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                         uint32 width, uint16 spp,\n                                         struct dump_opts *dump)\n  {\n  int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n  int32  bytes_read = 0;\n  uint16 bps, nstrips, planar, strips_per_sample;\n  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n  uint32 rows_this_strip = 0;\n  tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);\n  tsize_t stripsize    = TIFFStripSize(in);\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *buff = NULL;\n  unsigned char *dst = NULL;\n\n  if (obuf == NULL)\n    {\n    TIFFError(\"readSeparateStripsIntoBuffer\",\"Invalid buffer argument\");\n    return (0);\n    }\n\n  memset (srcbuffs, '\\0', sizeof(srcbuffs));\n  TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n  if (rps > length)\n    rps = length;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if (bytes_per_pixel < (bytes_per_sample + 1))\n    shift_width = bytes_per_pixel;\n  else\n    shift_width = bytes_per_sample + 1;\n\n  src_rowsize = ((bps * width) + 7) / 8;\n  dst_rowsize = ((bps * width * spp) + 7) / 8;\n  dst = obuf;\n\n  if ((dump->infile != NULL) && (dump->level == 3))\n    {\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Image width %d, length %d, Scanline size, %4d bytes\",\n                width, length,  scanlinesize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d, Shift width %d\",\n\t\tbps, spp, shift_width);\n    }\n\n  \n  nstrips = TIFFNumberOfStrips(in);\n  strips_per_sample = nstrips /spp;\n\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    srcbuffs[s] = NULL;\n    buff = _TIFFmalloc(stripsize);\n    if (!buff)\n      {\n      TIFFError (\"readSeparateStripsIntoBuffer\", \n                 \"Unable to allocate strip read buffer for sample %d\", s);\n      for (i = 0; i < s; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[s] = buff;\n    }\n\n  rows_processed = 0;\n  for (j = 0; (j < strips_per_sample) && (result == 1); j++)\n    {\n    for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n      {\n      buff = srcbuffs[s];\n      strip = (s * strips_per_sample) + j; \n      bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);\n      rows_this_strip = bytes_read / src_rowsize;\n      if (bytes_read < 0 && !ignore)\n        {\n        TIFFError(TIFFFileName(in),\n\t          \"Error, can't read strip %lu for sample %d\",\n         \t   (unsigned long) strip, s + 1);\n        result = 0;\n        break;\n        }\n#ifdef DEVELMODE\n      TIFFError(\"\", \"Strip %2d, read %5d bytes for %4d scanlines, shift width %d\", \n\t\tstrip, bytes_read, rows_this_strip, shift_width);\n#endif\n      }\n\n    if (rps > rows_this_strip)\n      rps = rows_this_strip;\n    dst = obuf + (dst_rowsize * rows_processed);\n    if ((bps % 8) == 0)\n      {\n      if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,\n                                       spp, bps, dump->infile, \n                                       dump->format, dump->level))\n        {\n        result = 0;\n        break;\n\t}\n      }\n    else\n      {\n      switch (shift_width)\n        {\n        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,\n                                                 spp, bps, dump->infile,\n                                                 dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n      \t          }\n\t        break;\n        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n       \t          }\n                break;\n        case 4: \n        case 5:\n        case 6:\n        case 7:\n        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        default: TIFFError (\"readSeparateStripsIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  result = 0;\n                  break;\n        }\n      }\n \n    if ((rows_processed + rps) > length)\n      {\n      rows_processed = length;\n      rps = length - rows_processed;\n      }\n    else\n      rows_processed += rps;\n    }\n\n  \n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    buff = srcbuffs[s];\n    if (buff != NULL)\n      _TIFFfree(buff);\n    }\n\n  return (result);\n  } \n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nerror_t dm9000UpdateMacAddrFilter(NetInterface *interface)\n{\n   uint_t i;\n   uint_t k;\n   uint32_t crc;\n   uint8_t hashTable[8];\n   MacFilterEntry *entry;\n\n     TRACE_DEBUG(\"Updating MAC filter...\\r\\n\");\n\n     osMemset(hashTable, 0, sizeof(hashTable));\n     hashTable[7] = 0x80;\n\n       for(i = 0; i < MAC_ADDR_FILTER_SIZE; i++)\n   {\n           entry = &interface->macAddrFilter[i];\n\n           if(entry->refCount > 0)\n      {\n                 crc = dm9000CalcCrc(&entry->addr, sizeof(MacAddr));\n                 k = crc & 0x3F;\n                 hashTable[k / 8] |= (1 << (k % 8));\n      }\n   }\n\n     for(i = 0; i < 8; i++)\n   {\n      dm9000WriteReg(DM9000_REG_MAR0 + i, hashTable[i]);\n   }\n\n     TRACE_DEBUG(\"  MAR = %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" \"\n      \"%02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \"\\r\\n\",\n      dm9000ReadReg(DM9000_REG_MAR0), dm9000ReadReg(DM9000_REG_MAR1),\n      dm9000ReadReg(DM9000_REG_MAR2), dm9000ReadReg(DM9000_REG_MAR3),\n      dm9000ReadReg(DM9000_REG_MAR4), dm9000ReadReg(DM9000_REG_MAR5),\n      dm9000ReadReg(DM9000_REG_MAR6), dm9000ReadReg(DM9000_REG_MAR7));\n\n     return NO_ERROR;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ncdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SEC_SIZE(h), i, j;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\n\tif (sst->sst_tab == NULL || scn->sst_len == (size_t)-1)\n\t\treturn -1;\n\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    i, scn->sst_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)ssat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(scn->sst_tab);\n\treturn -1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nMOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) {\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char huff_magic[5];\n    mobi_buffer_getstring(huff_magic, buf, 4);\n    const size_t header_length = mobi_buffer_get32(buf);\n    if (strncmp(huff_magic, HUFF_MAGIC, 4) != 0 || header_length < HUFF_HEADER_LEN) {\n        debug_print(\"HUFF wrong magic: %s\\n\", huff_magic);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t data1_offset = mobi_buffer_get32(buf);\n    const size_t data2_offset = mobi_buffer_get32(buf);\n    \n    mobi_buffer_setpos(buf, data1_offset);\n    if (buf->offset + (256 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data1 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    \n    for (int i = 0; i < 256; i++) {\n        huffcdic->table1[i] = mobi_buffer_get32(buf);\n    }\n    mobi_buffer_setpos(buf, data2_offset);\n    if (buf->offset + (64 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data2 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    \n    huffcdic->mincode_table[0] = 0;\n    huffcdic->maxcode_table[0] = 0xFFFFFFFF;\n    for (int i = 1; i < 33; i++) {\n        const uint32_t mincode = mobi_buffer_get32(buf);\n        const uint32_t maxcode = mobi_buffer_get32(buf);\n        huffcdic->mincode_table[i] =  mincode << (32 - i);\n        huffcdic->maxcode_table[i] =  ((maxcode + 1) << (32 - i)) - 1;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *m, size_t len, int flags)\n\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint ret;\n\tint copylen;\n\n\tret = -EOPNOTSUPP;\n\tif (m->msg_flags&MSG_OOB)\n\t\tgoto read_error;\n\n\tm->msg_namelen = 0;\n\n\tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n\tif (!skb)\n\t\tgoto read_error;\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\n\tret = skb_copy_datagram_iovec(skb, 0, m->msg_iov, copylen);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = (flags & MSG_TRUNC) ? skb->len : copylen;\nout_free:\n\tskb_free_datagram(sk, skb);\n\tcaif_check_flow_release(sk);\n\treturn ret;\n\nread_error:\n\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nheader_put_le_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\t} ;\n} \n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    EXRContext *s = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    uint8_t *ptr;\n\n    int i, y, ret, ymax;\n    int planes;\n    int out_line_size;\n    int nb_blocks;   \n    uint64_t start_offset_table;\n    uint64_t start_next_scanline;\n    PutByteContext offset_table_writer;\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n\n    if ((ret = decode_header(s, picture)) < 0)\n        return ret;\n\n    switch (s->pixel_type) {\n    case EXR_FLOAT:\n    case EXR_HALF:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            } else {\n                \n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRPF32;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAYF32;\n            }\n        }\n        break;\n    case EXR_UINT:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGBA64;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_YA16;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGB48;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n            }\n        }\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Missing channel list.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED)\n        avctx->color_trc = s->apply_trc_type;\n\n    switch (s->compression) {\n    case EXR_RAW:\n    case EXR_RLE:\n    case EXR_ZIP1:\n        s->scan_lines_per_block = 1;\n        break;\n    case EXR_PXR24:\n    case EXR_ZIP16:\n        s->scan_lines_per_block = 16;\n        break;\n    case EXR_PIZ:\n    case EXR_B44:\n    case EXR_B44A:\n        s->scan_lines_per_block = 32;\n        break;\n    default:\n        avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    \n    if (s->xmin > s->xmax  || s->ymin > s->ymax ||\n        s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) {\n        av_log(avctx, AV_LOG_ERROR, \"Wrong or missing size information.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0)\n        return ret;\n\n    s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);\n    if (!s->desc)\n        return AVERROR_INVALIDDATA;\n\n    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {\n        planes           = s->desc->nb_components;\n        out_line_size    = avctx->width * 4;\n    } else {\n        planes           = 1;\n        out_line_size    = avctx->width * 2 * s->desc->nb_components;\n    }\n\n    if (s->is_tile) {\n        nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) *\n        ((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize);\n    } else { \n        nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) /\n        s->scan_lines_per_block;\n    }\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        return ret;\n\n    if (bytestream2_get_bytes_left(&s->gb)/8 < nb_blocks)\n        return AVERROR_INVALIDDATA;\n\n       if (!s->is_tile && bytestream2_peek_le64(&s->gb) == 0) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\");\n\n        start_offset_table = bytestream2_tell(&s->gb);\n        start_next_scanline = start_offset_table + nb_blocks * 8;\n        bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);\n\n        for (y = 0; y < nb_blocks; y++) {\n            \n            bytestream2_put_le64(&offset_table_writer, start_next_scanline);\n\n            \n            bytestream2_seek(&s->gb, start_next_scanline + 4, SEEK_SET);\n            start_next_scanline += (bytestream2_get_le32(&s->gb) + 8);\n        }\n        bytestream2_seek(&s->gb, start_offset_table, SEEK_SET);\n    }\n\n       s->buf      = avpkt->data;\n    s->buf_size = avpkt->size;\n\n       for (i = 0; i < planes; i++) {\n        ptr = picture->data[i];\n        for (y = 0; y < s->ymin; y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    s->picture = picture;\n\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n       for (i = 0; i < planes; i++) {\n        ptr = picture->data[i] + (ymax * picture->linesize[i]);\n        for (y = ymax; y < avctx->height; y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n{\n\tstruct au1100fb_device *fbdev;\n\tunsigned int len;\n\tunsigned long start=0, off;\n\n\tfbdev = to_au1100fb_device(fbi);\n\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= (6 << 9);\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\tvma->vm_end - vma->vm_start,\n\t\t\t\tvma->vm_page_prot)) {\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid SPECTRA::run( Session* session, const std::string& argument ){\n\n  \n\n  if( session->loglevel >= 3 ) (*session->logfile) << \"SPECTRA handler reached\" << endl;\n\n  int resolution, tile, x, y;\n\n\n   if( session->loglevel >= 2 ) command_timer.start();\n\n\n   string arg = argument;\n  int delimitter = arg.find( \",\" );\n  resolution = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  tile = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  x = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  y = atoi( arg.substr(0,arg.length()).c_str() );\n\n  if( session->loglevel >= 5 ){ \n    (*session->logfile) << \"SPECTRA :: resolution: \" << resolution\n\t\t\t<< \", tile: \" << tile\n\t\t\t<< \", x: \" << x\n\t\t\t<< \", y: \" << y << endl;\n  }\n\n   if( x < 0 || x >= (int)(*session->image)->getTileWidth() ||\n      y < 0 || y >= (int)(*session->image)->getTileHeight() ){\n    throw invalid_argument( \"SPECTRA :: Error: x,y coordinates outside of tile boundaries\" );\n  }\n  \n\n  TileManager tilemanager( session->tileCache, *session->image, session->watermark, session->jpeg, session->logfile, session->loglevel );\n\n   list <int> views = (*session->image)->getHorizontalViewsList();\n  list <int> :: const_iterator i;\n\n   list <float> spectrum;\n\n\n#ifndef DEBUG\n   stringstream header;\n  header << session->response->createHTTPHeader( \"xml\", (*session->image)->getTimestamp() );\n  session->out->putStr( (const char*) header.str().c_str(), header.tellp() );\n  session->out->flush();\n#endif\n\n  session->out->putS( \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" );\n  session->out->putS( \"<spectra>\\n\" );\n  session->out->flush();\n\n  for( i = views.begin(); i != views.end(); i++ ){\n\n    int n = *i;\n\n    RawTile rawtile = tilemanager.getTile( resolution, tile, n, session->view->yangle, session->view->getLayers(), UNCOMPRESSED );\n\n       if( x >= (int)rawtile.width || y >= (int)rawtile.height ){\n      if( session->loglevel >= 1 ){\n\t(*session->logfile) << \"SPECTRA :: Error: x,y coordinates outside of tile boundaries\" << endl;\n      }\n      break;\n    }\n\n\n    unsigned int tw = (*session->image)->getTileWidth();\n    unsigned int index = y*tw + x;\n\n    void *ptr;\n    float reflectance = 0.0;\n\n    if( session->loglevel >= 5 ) (*session->logfile) << \"SPECTRA :: \" << rawtile.bpc << \" bits per channel data\" << endl;\n\n       if( rawtile.bpc == 8 ){\n      ptr = (unsigned char*) (rawtile.data);\n      reflectance = static_cast<float>((float)((unsigned char*)ptr)[index]) / 255.0;\n    }\n    else if( rawtile.bpc == 16 ){\n      ptr = (unsigned short*) (rawtile.data);\n      reflectance = static_cast<float>((float)((unsigned short*)ptr)[index]) / 65535.0;\n    }\n    else if( rawtile.bpc == 32 ){\n      if( rawtile.sampleType == FIXEDPOINT ) {\n        ptr = (unsigned int*) rawtile.data;\n        reflectance = static_cast<float>((float)((unsigned int*)ptr)[index]);\n      }\n      else {\n        ptr = (float*) rawtile.data;\n        reflectance = static_cast<float>((float)((float*)ptr)[index]);\n      }\n    }\n\n    spectrum.push_front( reflectance );\n\n    string metadata = (*session->image)->getMetadata( \"subject\" );\n\n    char tmp[1024];\n    snprintf( tmp, 1024, \"\\t<point>\\n\\t\\t<wavelength>%d</wavelength>\\n\\t\\t<reflectance>%f</reflectance>\\n\\t</point>\\n\", n, reflectance );\n    session->out->putS( tmp );\n    session->out->flush();\n\n    if( session->loglevel >= 3 ) (*session->logfile) << \"SPECTRA :: Band: \" << n << \", reflectance: \" << reflectance << endl;\n  }\n\n\n  session->out->putS( \"</spectra>\" );\n\n  if( session->out->flush() == -1 ) {\n    if( session->loglevel >= 1 ){\n      *(session->logfile) << \"SPECTRA :: Error flushing XML\" << endl;\n    }\n  }\n\n\n   session->response->setImageSent();\n\n   if( session->loglevel >= 2 ){\n    *(session->logfile) << \"SPECTRA :: Total command time \" << command_timer.getTime() << \" microseconds\" << endl;\n  }\n\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  \n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "OS Command Injection"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid PCRECache::dump(const std::string& filename) {\n  std::ofstream out(filename.c_str());\n  switch (m_kind) {\n    case CacheKind::Static:\n      for (auto& it : *m_staticCache) {\n        out << it.first->data() << \"\\n\";\n      }\n      break;\n    case CacheKind::Lru:\n    case CacheKind::Scalable:\n      {\n        std::vector<LRUCacheKey> keys;\n        if (m_kind == CacheKind::Lru) {\n          m_lruCache->snapshotKeys(keys);\n        } else {\n          m_scalableCache->snapshotKeys(keys);\n        }\n        for (auto& key: keys) {\n          out << key.c_str() << \"\\n\";\n        }\n      }\n      break;\n  }\n  out.close();\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Path Traversal"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nAssign(asdl_seq * targets, expr_ty value, int lineno, int col_offset, int\n       end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!value) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field value is required for Assign\");\n        return NULL;\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = Assign_kind;\n    p->v.Assign.targets = targets;\n    p->v.Assign.value = value;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  int num_inputs = NumInputs(node);\n  TF_LITE_ENSURE(context, num_inputs >= 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = input1->type;\n\n   for (int i = kInputTensor1 + 1; i < num_inputs; ++i) {\n    const TfLiteTensor* input = GetInput(context, node, i);\n    TF_LITE_ENSURE(context, HaveSameShapes(input1, input));\n    TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input->type);\n  }\n\n    TfLiteIntArray* input1_dims = input1->dims;\n  TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input1_dims);\n  return context->ResizeTensor(context, output, output_dims);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n\t\treturn -1;\n\t\tbreak;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n_Unpickler_MemoGet(UnpicklerObject *self, Py_ssize_t idx)\n{\n    if (idx < 0 || idx >= self->memo_size)\n        return NULL;\n\n    return self->memo[idx];\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csc_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csc_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_column_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csc_file_handle = fopen( i_csc_file_in, \"r\" );\n  if ( l_csc_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csc_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose( l_csc_file_handle ); \n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_LEN );\n      return;\n    }\n    \n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      \n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          \n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count));\n\n          \n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_column_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csc_file_handle); \n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          \n          memset(*o_row_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_column_idx_id, 0, sizeof(unsigned int) * (*o_column_count));\n\n          \n          for (l_i = 0; l_i <= *o_column_count; ++l_i) {\n            (*o_column_idx)[l_i] = *o_element_count;\n          }\n          \n          (*o_column_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_DESC );\n          fclose( l_csc_file_handle ); \n          return;\n        }\n      \n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        \n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csc_file_handle); \n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_ELEMS );\n          return;\n        }\n        \n        l_row--;\n        l_column--;\n        \n        (*o_row_idx)[l_i] = l_row;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        \n        l_column_idx_id[l_column] = 1;\n        (*o_column_idx)[l_column+1] = l_i;\n      }\n    }\n  }\n\n  \n  fclose( l_csc_file_handle );\n\n  \n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_LEN );\n    return;\n  }\n\n  if ( l_column_idx_id != NULL ) {\n    \n    for ( l_i = 0; l_i < (*o_column_count); l_i++) {\n      if ( l_column_idx_id[l_i] == 0 ) {\n        (*o_column_idx)[l_i+1] = (*o_column_idx)[l_i];\n      }\n    }\n\n    \n    free( l_column_idx_id );\n  }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nRemoteFsDevice::RemoteFsDevice(MusicLibraryModel *m, const Details &d)\n    : FsDevice(m, d.name, createUdi(d.name))\n    , mountToken(0)\n    , currentMountStatus(false)\n    , details(d)\n    , proc(0)\n    , mounterIface(0)\n    , messageSent(false)\n{    setup();\n    icn=MonoIcon::icon(details.isLocalFile()\n                       ? FontAwesome::foldero\n                       : constSshfsProtocol==details.url.scheme()\n                         ? FontAwesome::linux_os\n                         : FontAwesome::windows, Utils::monoIconColor());\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Path Traversal"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\n\tkenter(\"%p\", dest_keyring);\n\n\t\n\tif (dest_keyring) {\n\t\t\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\t\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Missing Authorization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus PrepareSimple(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  OpContext op_context(context, node);\n  TF_LITE_ENSURE_TYPES_EQ(context, op_context.axis->type, kTfLiteInt32);\n  TF_LITE_ENSURE_OK(context, InitializeTemporaries(context, node, &op_context));\n\n  TfLiteTensor* resolved_axis = GetTemporary(context, node, 1);\n   if (!IsConstantTensor(op_context.axis)) {\n    SetTensorToDynamic(op_context.output);\n    SetTensorToDynamic(resolved_axis);\n    return kTfLiteOk;\n  }\n  resolved_axis->allocation_type = kTfLiteArenaRw;\n  TF_LITE_ENSURE_OK(context,\n                    ResizeTempAxis(context, &op_context, resolved_axis));\n  TF_LITE_ENSURE_OK(context, ResizeOutputTensor(context, &op_context));\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nchar *path_name(struct strbuf *path, const char *name)\n{\n\tstruct strbuf ret = STRBUF_INIT;\n\tif (path)\n\t\tstrbuf_addbuf(&ret, path);\n\tstrbuf_addstr(&ret, name);\n\treturn strbuf_detach(&ret, NULL);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid handle_debug_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n\n               const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, DEBUG_MSG);\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    int istart = 0, n, i = 0, dir=1, idx=-1;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Obj *obj = _this->d.obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    if (!seq) {\n        goto bail;\n    }\n    \n    n = Jsi_ObjGetLength(interp, obj);    \n    if (n == 0) {\n        goto bail;\n    }\n    Jsi_Number nstart;\n    if (op == 2) {\n        istart = n-1;\n    }\n    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (op == 2) {\n        istart = n-1;\n        dir = -1;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    for (i = istart; ; i+=dir)\n    {\n        if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt)\n            break;\n        if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) {\n            idx = i;\n            break;\n        }\n    }\nbail:\n    if (op == 3)\n        Jsi_ValueMakeBool(interp, ret, (idx!=-1));\n    else\n        Jsi_ValueMakeNumber(interp, ret, idx);\n    return JSI_OK;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nmptctl_gettargetinfo (unsigned long arg)\n{\n\tstruct mpt_ioctl_targetinfo __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_targetinfo karg;\n\tMPT_ADAPTER\t\t*ioc;\n\tVirtDevice\t\t*vdevice;\n\tchar\t\t\t*pmem;\n\tint\t\t\t*pdata;\n\tint\t\t\tiocnum;\n\tint\t\t\tnumDevices = 0;\n\tint\t\t\tlun;\n\tint\t\t\tmaxWordsLeft;\n\tint\t\t\tnumBytes;\n\tu8\t\t\tport;\n\tstruct scsi_device \t*sdev;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_targetinfo))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to read in mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_gettargetinfo() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_gettargetinfo called.\\n\",\n\t    ioc->name));\n\t\n\tnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\n\tmaxWordsLeft = numBytes/sizeof(int);\n\tport = karg.hdr.port;\n\n\tif (maxWordsLeft <= 0) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo() - no memory available!\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\t\n\n\t\n\tpmem = kzalloc(numBytes, GFP_KERNEL);\n\tif (!pmem) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo() - no memory available!\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\tpdata =  (int *) pmem;\n\n\t\n\tif (ioc->sh){\n\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\tif (!maxWordsLeft)\n\t\t\t\tcontinue;\n\t\t\tvdevice = sdev->hostdata;\n\t\t\tif (vdevice == NULL || vdevice->vtarget == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (vdevice->vtarget->tflags &\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\t\t\tcontinue;\n\t\t\tlun = (vdevice->vtarget->raidVolume) ? 0x80 : vdevice->lun;\n\t\t\t*pdata = (((u8)lun << 16) + (vdevice->vtarget->channel << 8) +\n\t\t\t    (vdevice->vtarget->id ));\n\t\t\tpdata++;\n\t\t\tnumDevices++;\n\t\t\t--maxWordsLeft;\n\t\t}\n\t}\n\tkarg.numDevices = numDevices;\n\n\t\n\tif (copy_to_user((char __user *)arg, &karg,\n\t\t\t\tsizeof(struct mpt_ioctl_targetinfo))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\tkfree(pmem);\n\t\treturn -EFAULT;\n\t}\n\n\t\n\tif (copy_to_user(uarg->targetInfo, pmem, numBytes)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, pdata);\n\t\tkfree(pmem);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(pmem);\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_enter *rec;\n\tstruct hlist_head *head;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->enter_event->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\t\n\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = (struct syscall_trace_enter *)perf_trace_buf_prepare(size,\n\t\t\t\tsys_data->enter_event->event.type, regs, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args,\n\t\t\t       (unsigned long *)&rec->args);\n\tperf_trace_buf_submit(rec, size, rctx, 0, 1, regs, head, NULL);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,\n                                  NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn FALSE;\n\n\treturn ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),\n\t                        ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ncssp_read_tsrequest(STREAM token, STREAM pubkey)\n{\n\tSTREAM s;\n\tint length;\n\tint tagval;\n\n\ts = tcp_recv(NULL, 4);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\tif (s->p[0] != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t{\n\t\tlogger(Protocol, Error,\n\t\t       \"cssp_read_tsrequest(), expected BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED, got %x\",\n\t\t       s->p[0]);\n\t\treturn False;\n\t}\n\n\tif (s->p[1] < 0x80)\n\t\tlength = s->p[1] - 2;\n\telse if (s->p[1] == 0x81)\n\t\tlength = s->p[2] - 1;\n\telse if (s->p[1] == 0x82)\n\t\tlength = (s->p[2] << 8) | s->p[3];\n\telse\n\t\treturn False;\n\n\ts = tcp_recv(s, length);\n\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\treturn False;\n\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\treturn False;\n\tin_uint8s(s, length);\n\n\tif (token)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\ttoken->end = token->p = token->data;\n\t\tout_uint8p(token, s->p, length);\n\t\ts_mark_end(token);\n\t}\n\n\tif (pubkey)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\tpubkey->data = pubkey->p = s->p;\n\t\tpubkey->end = pubkey->data + length;\n\t\tpubkey->size = length;\n\t}\n\n\n\treturn True;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int hns_gmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_gmac_stats_string);\n\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_type_reduce(PyObject *self, PyObject *unused)\n{\n    PyObject *res;\n    _Py_IDENTIFIER(__dict__);\n    PyObject *dict = _PyObject_GetAttrId(self, &PyId___dict__);\n    if (dict == NULL) {\n        if (PyErr_ExceptionMatches(PyExc_AttributeError))\n            PyErr_Clear();\n        else\n            return NULL;\n    }\n    if (dict) {\n        res = Py_BuildValue(\"O()O\", Py_TYPE(self), dict);\n        Py_DECREF(dict);\n        return res;\n    }\n    return Py_BuildValue(\"O()\", Py_TYPE(self));\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsf_flac_write_callback (const FLAC__StreamDecoder * UNUSED (decoder), const FLAC__Frame *frame, const int32_t * const buffer [], void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\n\tpflac->frame = frame ;\n\tpflac->bufferpos = 0 ;\n\n\tpflac->bufferbackup = SF_FALSE ;\n\tpflac->wbuffer = buffer ;\n\n\tflac_buffer_copy (psf) ;\n\n\treturn FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE ;\n} \n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nAP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    \n       if (size < AP4_FULL_ATOM_HEADER_SIZE+20) return;\n    AP4_UI32 name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    char* name = new char[name_size+1];\n    if (name == NULL) return;\n    stream.Read(name, name_size);\n    name[name_size] = '\\0';             if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint main(int argc, char **argv)\n{\n\tint fmtid;\n\tint id;\n\tchar *infile;\n\tjas_stream_t *instream;\n\tjas_image_t *image;\n\tint width;\n\tint height;\n\tint depth;\n\tint numcmpts;\n\tint verbose;\n\tchar *fmtname;\n\tint debug;\n\tsize_t max_mem;\n\n\tif (jas_init()) {\n\t\tabort();\n\t}\n\n\tcmdname = argv[0];\n\n\tinfile = 0;\n\tverbose = 0;\n\tdebug = 0;\n#if defined(JAS_DEFAULT_MAX_MEM_USAGE)\n\tmax_mem = JAS_DEFAULT_MAX_MEM_USAGE;\n#endif\n\n\t\n\twhile ((id = jas_getopt(argc, argv, opts)) >= 0) {\n\t\tswitch (id) {\n\t\tcase OPT_VERBOSE:\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\t\tcase OPT_VERSION:\n\t\t\tprintf(\"%s\\n\", JAS_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\tdebug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase OPT_INFILE:\n\t\t\tinfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase OPT_MAXMEM:\n\t\t\tmax_mem = strtoull(jas_optarg, 0, 10);\n\t\t\tbreak;\n\t\tcase OPT_HELP:\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_setdbglevel(debug);\n#if defined(JAS_DEFAULT_MAX_MEM_USAGE)\n\tjas_set_max_mem_usage(max_mem);\n#endif\n\n\t\n\tif (infile) {\n\t\t\n\t\tif (!(instream = jas_stream_fopen(infile, \"rb\"))) {\n\t\t\tfprintf(stderr, \"cannot open input image file %s\\n\", infile);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} else {\n\t\t\n\t\tif (!(instream = jas_stream_fdopen(0, \"rb\"))) {\n\t\t\tfprintf(stderr, \"cannot open standard input\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif ((fmtid = jas_image_getfmt(instream)) < 0) {\n\t\tfprintf(stderr, \"unknown image format\\n\");\n\t}\n\n\t\n\tif (!(image = jas_image_decode(instream, fmtid, 0))) {\n\t\tjas_stream_close(instream);\n\t\tfprintf(stderr, \"cannot load image\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t\n\tjas_stream_close(instream);\n\n\tif (!(numcmpts = jas_image_numcmpts(image))) {\n\t\tfprintf(stderr, \"warning: image has no components\\n\");\n\t}\n\tif (numcmpts) {\n\t\twidth = jas_image_cmptwidth(image, 0);\n\t\theight = jas_image_cmptheight(image, 0);\n\t\tdepth = jas_image_cmptprec(image, 0);\n\t} else {\n\t\twidth = 0;\n\t\theight = 0;\n\t\tdepth = 0;\n\t}\n\tif (!(fmtname = jas_image_fmttostr(fmtid))) {\n\t\tabort();\n\t}\n\tprintf(\"%s %d %d %d %d %ld\\n\", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));\n\n\tjas_image_destroy(image);\n\tjas_image_clearfmts();\n\n\treturn EXIT_SUCCESS;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstruct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb,\n\t\t\t     struct ip_options *opt)\n{\n\tstruct tcp_options_received tcp_opt;\n\tu8 *hash_location;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint mss;\n\tstruct rtable *rt;\n\t__u8 rcv_wscale;\n\tbool ecn_ok;\n\n\tif (!sysctl_tcp_syncookies || !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk) ||\n\t    (mss = cookie_check(skb, cookie)) == 0) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t\n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(skb, &tcp_opt, &hash_location, 0);\n\n\tif (!cookie_check_timestamp(&tcp_opt, &ecn_ok))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = inet_reqsk_alloc(&tcp_request_sock_ops); \n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n\ttreq = tcp_rsk(req);\n\ttreq->rcv_isn\t\t= ntohl(th->seq) - 1;\n\ttreq->snt_isn\t\t= cookie;\n\treq->mss\t\t= mss;\n\tireq->loc_port\t\t= th->dest;\n\tireq->rmt_port\t\t= th->source;\n\tireq->loc_addr\t\t= ip_hdr(skb)->daddr;\n\tireq->rmt_addr\t\t= ip_hdr(skb)->saddr;\n\tireq->ecn_ok\t\t= ecn_ok;\n\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\n\t\n\tif (opt && opt->optlen) {\n\t\tint opt_size = sizeof(struct ip_options) + opt->optlen;\n\n\t\tireq->opt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (ireq->opt != NULL && ip_options_echo(ireq->opt, skb)) {\n\t\t\tkfree(ireq->opt);\n\t\t\tireq->opt = NULL;\n\t\t}\n\t}\n\n\tif (security_inet_conn_request(sk, skb, req)) {\n\t\treqsk_free(req);\n\t\tgoto out;\n\t}\n\n\treq->expires\t= 0UL;\n\treq->retrans\t= 0;\n\n\t\n\t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, 0, sk->sk_mark, RT_CONN_FLAGS(sk),\n\t\t\t\t   RT_SCOPE_UNIVERSE, IPPROTO_TCP,\n\t\t\t\t   inet_sk_flowi_flags(sk),\n\t\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t\t   ireq->loc_addr, th->source, th->dest);\n\t\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt)) {\n\t\t\treqsk_free(req);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t\n\treq->window_clamp = tp->window_clamp ? :dst_metric(&rt->dst, RTAX_WINDOW);\n\n\ttcp_select_initial_window(tcp_full_space(sk), req->mss,\n\t\t\t\t  &req->rcv_wnd, &req->window_clamp,\n\t\t\t\t  ireq->wscale_ok, &rcv_wscale,\n\t\t\t\t  dst_metric(&rt->dst, RTAX_INITRWND));\n\n\tireq->rcv_wscale  = rcv_wscale;\n\n\tret = get_cookie_sock(sk, skb, req, &rt->dst);\nout:\treturn ret;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n\n  return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputVariableId);\n  const TfLiteTensor* input_value_tensor = GetInput(context, node, kInputValue);\n\n  int resource_id = input_resource_id_tensor->data.i32[0];\n  auto& resources = subgraph->resources();\n  resource::CreateResourceVariableIfNotAvailable(&resources, resource_id);\n  auto* variable = resource::GetResourceVariable(&resources, resource_id);\n  TF_LITE_ENSURE(context, variable != nullptr);\n  variable->AssignFrom(input_value_tensor);\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  absl::Status IsSupported(const TfLiteContext* context,\n                           const TfLiteNode* tflite_node,\n                           const TfLiteRegistration* registration) final {\n    if (mirror_pad_) {\n      const TfLiteMirrorPaddingParams* tf_options;\n      RETURN_IF_ERROR(RetrieveBuiltinData(tflite_node, &tf_options));\n      if (tf_options->mode !=\n          TfLiteMirrorPaddingMode::kTfLiteMirrorPaddingReflect) {\n        return absl::InvalidArgumentError(\n            \"Only Reflective padding is supported for Mirror Pad operation.\");\n      }\n    }\n    RETURN_IF_ERROR(CheckMaxSupportedOpVersion(registration, 2));\n    RETURN_IF_ERROR(CheckInputsOutputs(context, tflite_node,\n                                       1, 1));\n    RETURN_IF_ERROR(CheckTensorIsAvailable(context, tflite_node, 1));\n    auto pad_tensor = tflite::GetInput(context, tflite_node, 1);\n    if (pad_tensor->dims->size != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor dimension: expected 2 dim, got \",\n          pad_tensor->dims->size, \" dim\"));\n    }\n    bool supported =\n        pad_tensor->dims->data[0] == 3 || pad_tensor->dims->data[0] == 4;\n    if (!supported || pad_tensor->dims->data[1] != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor shape: expected 4x2 or 3x2, got \",\n          pad_tensor->dims->data[0], \"x\", pad_tensor->dims->data[1]));\n    }\n    return absl::OkStatus();\n  }\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n   OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const TfLiteType type = input1->type;\n  if (type != kTfLiteBool) {\n    context->ReportError(context, \"Logical ops only support bool type.\");\n    return kTfLiteError;\n  }\n  output->type = type;\n\n  data->requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (data->requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* fft_length = GetInput(context, node, kFftLengthTensor);\n  const int32_t* fft_length_data = GetTensorData<int32_t>(fft_length);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type != kTfLiteComplex64) {\n    context->ReportError(context,\n                         \"Type '%s' for output is not supported by rfft2d.\",\n                         TfLiteTypeGetName(output->type));\n    return kTfLiteError;\n  }\n\n    if (!IsConstantTensor(fft_length)) {\n    TF_LITE_ENSURE_STATUS(ResizeOutputandTemporaryTensors(context, node));\n  } else {\n    int num_dims_output = NumDimensions(output);\n    const RuntimeShape output_shape = GetTensorShape(output);\n    TF_LITE_ENSURE_EQ(context, num_dims_output, NumDimensions(input));\n    TF_LITE_ENSURE(context, num_dims_output >= 2);\n    TF_LITE_ENSURE_EQ(context, output_shape.Dims(num_dims_output - 2),\n                      fft_length_data[0]);\n    TF_LITE_ENSURE_EQ(context, output_shape.Dims(num_dims_output - 1),\n                      fft_length_data[1] / 2 + 1);\n  }\n\n  return Rfft2dHelper(context, node);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\njas_matrix_t *jas_seq2d_input(FILE *in)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\tint j;\n\tlong x;\n\tint numrows;\n\tint numcols;\n\tint xoff;\n\tint yoff;\n\n\tif (fscanf(in, \"%d %d\", &xoff, &yoff) != 2)\n\t\treturn 0;\n\tif (fscanf(in, \"%d %d\", &numcols, &numrows) != 2)\n\t\treturn 0;\n\tif (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols, yoff + numrows)))\n\t\treturn 0;\n\n\tif (jas_matrix_numrows(matrix) != numrows ||\n\t  jas_matrix_numcols(matrix) != numcols) {\n\t\tabort();\n\t}\n\n\t\n\tfor (i = 0; i < jas_matrix_numrows(matrix); i++) {\n\t\tfor (j = 0; j < jas_matrix_numcols(matrix); j++) {\n\t\t\tif (fscanf(in, \"%ld\", &x) != 1) {\n\t\t\t\tjas_matrix_destroy(matrix);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tjas_matrix_set(matrix, i, j, JAS_CAST(jas_seqent_t, x));\n\t\t}\n\t}\n\n\treturn matrix;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nread_viminfo_barline(vir_T *virp, int got_encoding, int force, int writing)\n{\n    char_u\t*p = virp->vir_line + 1;\n    int\t\tbartype;\n    garray_T\tvalues;\n    bval_T\t*vp;\n    int\t\ti;\n    int\t\tread_next = TRUE;\n\n                            if (*p == '<')\n    {\n\tif (writing)\n\t    ga_add_string(&virp->vir_barlines, virp->vir_line);\n    }\n    else\n    {\n\tga_init2(&values, sizeof(bval_T), 20);\n\tbartype = getdigits(&p);\n\tswitch (bartype)\n\t{\n\t    case BARTYPE_VERSION:\n\t\t\t\t\tif (!got_encoding)\n\t\t{\n\t\t    read_next = barline_parse(virp, p, &values);\n\t\t    vp = (bval_T *)values.ga_data;\n\t\t    if (values.ga_len > 0 && vp->bv_type == BVAL_NR)\n\t\t\tvirp->vir_version = vp->bv_nr;\n\t\t}\n\t\tbreak;\n\n\t    case BARTYPE_HISTORY:\n\t\tread_next = barline_parse(virp, p, &values);\n\t\thandle_viminfo_history(&values, writing);\n\t\tbreak;\n\n\t    case BARTYPE_REGISTER:\n\t\tread_next = barline_parse(virp, p, &values);\n\t\thandle_viminfo_register(&values, force);\n\t\tbreak;\n\n\t    case BARTYPE_MARK:\n\t\tread_next = barline_parse(virp, p, &values);\n\t\thandle_viminfo_mark(&values, force);\n\t\tbreak;\n\n\t    default:\n\t\t\tif (writing)\n\t\t    ga_add_string(&virp->vir_barlines, virp->vir_line);\n\t}\n\tfor (i = 0; i < values.ga_len; ++i)\n\t{\n\t    vp = (bval_T *)values.ga_data + i;\n\t    if (vp->bv_type == BVAL_STRING && vp->bv_allocated)\n\t\tvim_free(vp->bv_string);\n\t    vim_free(vp->bv_tofree);\n\t}\n\tga_clear(&values);\n    }\n\n    if (read_next)\n\treturn viminfo_readline(virp);\n    return FALSE;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int ip_options_get_finish(struct net *net, struct ip_options **optp,\n\t\t\t\t struct ip_options *opt, int optlen)\n{\n\twhile (optlen & 3)\n\t\topt->__data[optlen++] = IPOPT_END;\n\topt->optlen = optlen;\n\tif (optlen && ip_options_compile(net, opt, NULL)) {\n\t\tkfree(opt);\n\t\treturn -EINVAL;\n\t}\n\tkfree(*optp);\n\t*optp = opt;\n\treturn 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nget_user_commands(expand_T *xp UNUSED, int idx)\n{\n       buf_T *buf =\n#ifdef FEAT_CMDWIN\n\tis_in_cmdwin() ? prevwin->w_buffer :\n#endif\n\tcurbuf;\n\n    if (idx < buf->b_ucmds.ga_len)\n\treturn USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    idx -= buf->b_ucmds.ga_len;\n    if (idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    return NULL;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nget_function_args(\n    char_u\t**argp,\n    char_u\tendchar,\n    garray_T\t*newargs,\n    garray_T\t*argtypes,    int\t\ttypes_optional,    evalarg_T\t*evalarg,    int\t\t*varargs,\n    garray_T\t*default_args,\n    int\t\tskip,\n    exarg_T\t*eap,\n    char_u\t**line_to_free)\n{\n    int\t\tmustend = FALSE;\n    char_u\t*arg;\n    char_u\t*p;\n    int\t\tc;\n    int\t\tany_default = FALSE;\n    char_u\t*expr;\n    char_u\t*whitep = *argp;\n\n    if (newargs != NULL)\n\tga_init2(newargs, (int)sizeof(char_u *), 3);\n    if (argtypes != NULL)\n\tga_init2(argtypes, (int)sizeof(char_u *), 3);\n    if (!skip && default_args != NULL)\n\tga_init2(default_args, (int)sizeof(char_u *), 3);\n\n    if (varargs != NULL)\n\t*varargs = FALSE;\n\n    \n    arg = skipwhite(*argp);\n    p = arg;\n    while (*p != endchar)\n    {\n\twhile (eap != NULL && eap->getline != NULL\n\t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))\n\t{\n\t   \t    char_u *theline = get_function_line(eap, line_to_free, 0,\n\t\t\t\t\t\t\t  GETLINE_CONCAT_CONT);\n\n\t    if (theline == NULL)\n\t\tbreak;\n\t    whitep = (char_u *)\" \";\n\t    p = skipwhite(theline);\n\t}\n\n\tif (mustend && *p != endchar)\n\t{\n\t    if (!skip)\n\t\tsemsg(_(e_invalid_argument_str), *argp);\n\t    goto err_ret;\n\t}\n\tif (*p == endchar)\n\t    break;\n\n\tif (p[0] == '.' && p[1] == '.' && p[2] == '.')\n\t{\n\t    if (varargs != NULL)\n\t\t*varargs = TRUE;\n\t    p += 3;\n\t    mustend = TRUE;\n\n\t    if (argtypes != NULL)\n\t    {\n\t\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    if (!skip)\n\t\t\temsg(_(e_missing_name_after_dots));\n\t\t    goto err_ret;\n\t\t}\n\n\t\targ = p;\n\t\tp = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t  evalarg, TRUE, skip);\n\t\tif (p == arg)\n\t\t    break;\n\t\tif (*skipwhite(p) == '=')\n\t\t{\n\t\t    emsg(_(e_cannot_use_default_for_variable_arguments));\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *np;\n\n\t    arg = p;\n\t    p = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t evalarg, FALSE, skip);\n\t    if (p == arg)\n\t\tbreak;\n\n\t   \t   \t    np = skipwhite(p);\n\t    if (*np == '=' && np[1] != '=' && np[1] != '~'\n\t\t\t\t\t\t       && default_args != NULL)\n\t    {\n\t\ttypval_T\trettv;\n\n\t\t\tany_default = TRUE;\n\t\tp = skipwhite(p) + 1;\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t\texpr = p;\n\t\tif (eval1(&p, &rettv, NULL) != FAIL)\n\t\t{\n\t\t    if (!skip)\n\t\t    {\n\t\t\tif (ga_grow(default_args, 1) == FAIL)\n\t\t\t    goto err_ret;\n\n\t\t\t\t\twhile (p > expr && VIM_ISWHITE(p[-1]))\n\t\t\t    p--;\n\t\t\tc = *p;\n\t\t\t*p = NUL;\n\t\t\texpr = vim_strsave(expr);\n\t\t\tif (expr == NULL)\n\t\t\t{\n\t\t\t    *p = c;\n\t\t\t    goto err_ret;\n\t\t\t}\n\t\t\t((char_u **)(default_args->ga_data))\n\t\t\t\t\t\t [default_args->ga_len] = expr;\n\t\t\tdefault_args->ga_len++;\n\t\t\t*p = c;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    mustend = TRUE;\n\t    }\n\t    else if (any_default)\n\t    {\n\t\temsg(_(e_non_default_argument_follows_default_argument));\n\t\tgoto err_ret;\n\t    }\n\n\t    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')\n\t    {\n\t\t\tif (!skip)\n\t\t{\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t\t    goto err_ret;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\t\t\t\tif (!skip && argtypes != NULL\n\t\t\t\t      && !IS_WHITE_OR_NUL(*p) && *p != endchar)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\t    goto err_ret;\n\t\t}\n\t    }\n\t    else\n\t\tmustend = TRUE;\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n\n    if (*p != endchar)\n\tgoto err_ret;\n    ++p;\n    *argp = p;\n    return OK;\n\nerr_ret:\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    if (!skip && default_args != NULL)\n\tga_clear_strings(default_args);\n    return FAIL;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t  struct msghdr *msg, size_t len,\n\t\t  int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)msg->msg_name;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (addr_len)\n\t\t*addr_len=sizeof(*sin6);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tcopied = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tif (skb_csum_unnecessary(skb)) {\n\t\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\t} else if (msg->msg_flags&MSG_TRUNC) {\n\t\tif (__skb_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\t} else {\n\t\terr = skb_copy_and_csum_datagram_iovec(skb, 0, msg->msg_iov);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (err)\n\t\tgoto out_free;\n\n\t\n\tif (sin6) {\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t\t  IP6CB(skb)->iif);\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = skb->len;\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tskb_kill_datagram(sk, skb, flags);\n\n\t\n\terr = (flags&MSG_DONTWAIT) ? -EAGAIN : -EHOSTUNREACH;\n\tgoto out;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid enc28j60WritePhyReg(NetInterface *interface, uint16_t address,\n   uint16_t data)\n{\n     enc28j60WriteReg(interface, ENC28J60_REG_MIREGADR, address & REG_ADDR_MASK);\n\n     enc28j60WriteReg(interface, ENC28J60_REG_MIWRL, LSB(data));\n     enc28j60WriteReg(interface, ENC28J60_REG_MIWRH, MSB(data));\n\n     while((enc28j60ReadReg(interface, ENC28J60_REG_MISTAT) & MISTAT_BUSY) != 0)\n   {\n   }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic spl_filesystem_object * spl_filesystem_object_create_info(spl_filesystem_object *source, char *file_path, int file_path_len, int use_copy, zend_class_entry *ce, zval *return_value TSRMLS_DC) \n{\n\tspl_filesystem_object *intern;\n\tzval *arg1;\n\tzend_error_handling error_handling;\n\n\tif (!file_path || !file_path_len) {\n#if defined(PHP_WIN32)\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot create SplFileInfo for empty path\");\n\t\tif (file_path && !use_copy) {\n\t\t\tefree(file_path);\n\t\t}\n#else\n\t\tif (file_path && !use_copy) {\n\t\t\tefree(file_path);\n\t\t}\n\t\tfile_path_len = 1;\n\t\tfile_path = \"/\";\n#endif\n\t\treturn NULL;\n\t}\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tce = ce ? ce : source->info_class;\n\n\tzend_update_class_constants(ce TSRMLS_CC);\n\n\treturn_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n\tZ_TYPE_P(return_value) = IS_OBJECT;\n\n\tif (ce->constructor->common.scope != spl_ce_SplFileInfo) {\n\t\tMAKE_STD_ZVAL(arg1);\n\t\tZVAL_STRINGL(arg1, file_path, file_path_len, use_copy);\n\t\tzend_call_method_with_1_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1);\n\t\tzval_ptr_dtor(&arg1);\n\t} else {\n\t\tspl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);\n\t}\n\t\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\treturn intern;\n} \n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n           handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nctcompare(const char *a,\t\t\n          const char *b)\t\t\n{\n  int\tresult = 0;\t\t\t\n\n\n  while (*a && *b)\n  {\n    result |= *a ^ *b;\n    a ++;\n    b ++;\n  }\n\n  return (result);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Privilege Management"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint my_redel(const char *org_name, const char *tmp_name,\n             time_t backup_time_stamp, myf MyFlags)\n{\n  int error=1;\n  DBUG_ENTER(\"my_redel\");\n  DBUG_PRINT(\"my\",(\"org_name: '%s' tmp_name: '%s'  MyFlags: %d\",\n\t\t   org_name,tmp_name,MyFlags));\n\n  if (my_copystat(org_name,tmp_name,MyFlags) < 0)\n    goto end;\n  if (MyFlags & MY_REDEL_MAKE_BACKUP)\n  {\n    char name_buff[FN_REFLEN + MY_BACKUP_NAME_EXTRA_LENGTH];    \n    my_create_backup_name(name_buff, org_name, backup_time_stamp);\n    if (my_rename(org_name, name_buff, MyFlags))\n      goto end;\n  }\n  else if (my_delete(org_name, MyFlags))\n      goto end;\n  if (my_rename(tmp_name,org_name,MyFlags))\n    goto end;\n\n  error=0;\nend:\n  DBUG_RETURN(error);\n} \n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\ngtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileSeparateRoutine put = img->put.separate;\n\tunsigned char *buf = NULL;\n\tunsigned char *p0 = NULL, *p1 = NULL, *p2 = NULL, *pa = NULL;\n\tuint32 row, y, nrow, rowstoread;\n\ttmsize_t pos;\n\ttmsize_t scanline;\n\tuint32 rowsperstrip, offset_row;\n\tuint32 imagewidth = img->width;\n\ttmsize_t stripsize;\n\ttmsize_t bufsize;\n\tint32 fromskew, toskew;\n\tint alpha = img->alpha;\n\tint ret = 1, flip;\n        uint16 colorchannels;\n\n\tstripsize = TIFFStripSize(tif);  \n\tbufsize = _TIFFMultiplySSize(tif,alpha?4:3,stripsize, \"gtStripSeparate\");\n\tif (bufsize == 0) {\n\t\treturn (0);\n\t}\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(w + w);\n\t}\n\telse {\n\t\ty = 0;\n\t\ttoskew = -(int32)(w - w);\n\t}\n\n        switch( img->photometric )\n        {\n          case PHOTOMETRIC_MINISWHITE:\n          case PHOTOMETRIC_MINISBLACK:\n          case PHOTOMETRIC_PALETTE:\n            colorchannels = 1;\n            break;\n\n          default:\n            colorchannels = 3;\n            break;\n        }\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\tscanline = TIFFScanlineSize(tif);  \n\tfromskew = (w < imagewidth ? imagewidth - w : 0);\n\tfor (row = 0; row < h; row += nrow)\n\t{\n\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\toffset_row = row + img->row_offset;\n                if( buf == NULL )\n                {\n                    if (_TIFFReadEncodedStripAndAllocBuffer(\n                            tif, TIFFComputeStrip(tif, offset_row, 0),\n                            (void**) &buf, bufsize,\n                            ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1)\n                        && (buf == NULL || img->stoponerr))\n                    {\n                            ret = 0;\n                            break;\n                    }\n                    p0 = buf;\n                    if( colorchannels == 1 )\n                    {\n                        p2 = p1 = p0;\n                        pa = (alpha?(p0+3*stripsize):NULL);\n                    }\n                    else\n                    {\n                        p1 = p0 + stripsize;\n                        p2 = p1 + stripsize;\n                        pa = (alpha?(p2+stripsize):NULL);\n                    }\n                }\n\t\telse if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 0),\n\t\t    p0, ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (colorchannels > 1 \n                    && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 1),\n                                            p1, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) == (tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (colorchannels > 1 \n                    && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 2),\n                                            p2, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) == (tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (alpha)\n\t\t{\n\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, colorchannels),\n\t\t\t    pa, ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1)\n\t\t\t    && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline + \\\n\t\t\t((tmsize_t) img->col_offset * img->samplesperpixel);\n\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, p0 + pos, p1 + pos,\n\t\t    p2 + pos, (alpha?(pa+pos):NULL));\n\t\ty += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Subgraph::Invoke() {\n  if (!consistent_) {\n    ReportError(\"Invoke called on model that is not consistent.\");\n    return kTfLiteError;\n  }\n\n  TfLiteStatus status = kTfLiteOk;\n  if (state_ == kStateUninvokable) {\n    ReportError(\"Invoke called on model that is not ready.\");\n    return kTfLiteError;\n  } else if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {\n    ReportError(\"Non-persistent memory is not available.\");\n    return kTfLiteError;\n  }\n  TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), \"Invoke\");\n\n      for (int execution_plan_index = 0;\n       execution_plan_index < execution_plan_.size(); execution_plan_index++) {\n    if (execution_plan_index == next_execution_plan_index_to_prepare_) {\n      TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());\n      TF_LITE_ENSURE(&context_, next_execution_plan_index_to_prepare_ >=\n                                    execution_plan_index);\n    }\n    int node_index = execution_plan_[execution_plan_index];\n    TfLiteNode& node = nodes_and_registration_[node_index].first;\n    const TfLiteRegistration& registration =\n        nodes_and_registration_[node_index].second;\n\n    const char* op_name = nullptr;\n    if (profiler_) op_name = GetTFLiteOpName(registration);\n    TFLITE_SCOPED_TAGGED_OPERATOR_PROFILE(profiler_.get(), op_name, node_index);\n\n    for (int i = 0; i < node.inputs->size; ++i) {\n      int tensor_index = node.inputs->data[i];\n      if (tensor_index == kTfLiteOptionalTensor) {\n        continue;\n      }\n      TfLiteTensor* tensor = &tensors_[tensor_index];\n      if (tensor->delegate && tensor->delegate != node.delegate &&\n          tensor->data_is_stale) {\n        TF_LITE_ENSURE_STATUS(EnsureTensorDataIsReadable(tensor_index));\n      }\n      if (tensor->data.raw == nullptr && tensor->bytes > 0) {\n        if (registration.builtin_code == kTfLiteBuiltinReshape && i == 1) {\n                                     continue;\n        } else {\n                            ReportError(\"Input tensor %d lacks data\", tensor_index);\n          return kTfLiteError;\n        }\n      }\n    }\n\n    if (check_cancelled_func_ != nullptr &&\n        check_cancelled_func_(cancellation_data_)) {\n      ReportError(\"Client requested cancel during Invoke()\");\n      return kTfLiteError;\n    }\n\n    EnsureTensorsVectorCapacity();\n    tensor_resized_since_op_invoke_ = false;\n    if (OpInvoke(registration, &node) != kTfLiteOk) {\n      return ReportOpError(&context_, node, registration, node_index,\n                           \"failed to invoke\");\n    }\n\n          if (tensor_resized_since_op_invoke_ &&\n        HasDynamicTensor(context_, node.outputs)) {\n      next_execution_plan_index_to_prepare_ = execution_plan_index + 1;\n\n                     if (next_execution_plan_index_to_plan_allocation_ >\n          next_execution_plan_index_to_prepare_) {\n        next_execution_plan_index_to_plan_allocation_ =\n            next_execution_plan_index_to_prepare_;\n        if (memory_planner_) {\n          TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocationsAfter(\n              next_execution_plan_index_to_plan_allocation_ - 1));\n        }\n      }\n    }\n  }\n\n  return status;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nbuiltin_compile_impl(PyObject *module, PyObject *source, PyObject *filename,\n                     const char *mode, int flags, int dont_inherit,\n                     int optimize)\n\n{\n    PyObject *source_copy;\n    const char *str;\n    int compile_mode = -1;\n    int is_ast;\n    PyCompilerFlags cf;\n    int start[] = {Py_file_input, Py_eval_input, Py_single_input};\n    PyObject *result;\n\n    cf.cf_flags = flags | PyCF_SOURCE_IS_UTF8;\n\n    if (flags &\n        ~(PyCF_MASK | PyCF_MASK_OBSOLETE | PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST))\n    {\n        PyErr_SetString(PyExc_ValueError,\n                        \"compile(): unrecognised flags\");\n        goto error;\n    }\n    \n\n    if (optimize < -1 || optimize > 2) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"compile(): invalid optimize value\");\n        goto error;\n    }\n\n    if (!dont_inherit) {\n        PyEval_MergeCompilerFlags(&cf);\n    }\n\n    if (strcmp(mode, \"exec\") == 0)\n        compile_mode = 0;\n    else if (strcmp(mode, \"eval\") == 0)\n        compile_mode = 1;\n    else if (strcmp(mode, \"single\") == 0)\n        compile_mode = 2;\n    else {\n        PyErr_SetString(PyExc_ValueError,\n                        \"compile() mode must be 'exec', 'eval' or 'single'\");\n        goto error;\n    }\n\n    is_ast = PyAST_Check(source);\n    if (is_ast == -1)\n        goto error;\n    if (is_ast) {\n        if (flags & PyCF_ONLY_AST) {\n            Py_INCREF(source);\n            result = source;\n        }\n        else {\n            PyArena *arena;\n            mod_ty mod;\n\n            arena = PyArena_New();\n            if (arena == NULL)\n                goto error;\n            mod = PyAST_obj2mod(source, arena, compile_mode);\n            if (mod == NULL) {\n                PyArena_Free(arena);\n                goto error;\n            }\n            if (!PyAST_Validate(mod)) {\n                PyArena_Free(arena);\n                goto error;\n            }\n            result = (PyObject*)PyAST_CompileObject(mod, filename,\n                                                    &cf, optimize, arena);\n            PyArena_Free(arena);\n        }\n        goto finally;\n    }\n\n    str = source_as_string(source, \"compile\", \"string, bytes or AST\", &cf, &source_copy);\n    if (str == NULL)\n        goto error;\n\n    result = Py_CompileStringObject(str, filename, start[compile_mode], &cf, optimize);\n    Py_XDECREF(source_copy);\n    goto finally;\n\nerror:\n    result = NULL;\nfinally:\n    Py_DECREF(filename);\n    return result;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\n\tif (flags)\n\t\t*flags++ = '\\0';\t\n\n\tif (nodelist) {\n\t\t\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\t\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\t\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\t\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\t\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\t\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\n\tmode_flags = 0;\n\tif (flags) {\n\t\t\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\n\t\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\n\t\n\tnew->w.user_nodemask = nodes;\n\n\terr = 0;\n\nout:\n\t\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    \n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus NonMaxSuppressionMultiClassRegularHelper(TfLiteContext* context,\n                                                      TfLiteNode* node,\n                                                      OpData* op_data,\n                                                      const float* scores) {\n  const TfLiteTensor* input_box_encodings =\n      GetInput(context, node, kInputTensorBoxEncodings);\n  const TfLiteTensor* input_class_predictions =\n      GetInput(context, node, kInputTensorClassPredictions);\n  const TfLiteTensor* decoded_boxes =\n      &context->tensors[op_data->decoded_boxes_index];\n\n  TfLiteTensor* detection_boxes =\n      GetOutput(context, node, kOutputTensorDetectionBoxes);\n  TfLiteTensor* detection_classes =\n      GetOutput(context, node, kOutputTensorDetectionClasses);\n  TfLiteTensor* detection_scores =\n      GetOutput(context, node, kOutputTensorDetectionScores);\n  TfLiteTensor* num_detections =\n      GetOutput(context, node, kOutputTensorNumDetections);\n\n  const int num_boxes = input_box_encodings->dims->data[1];\n  const int num_classes = op_data->num_classes;\n  const int num_detections_per_class = op_data->detections_per_class;\n  const int max_detections = op_data->max_detections;\n  const int num_classes_with_background =\n      input_class_predictions->dims->data[2];\n   int label_offset = num_classes_with_background - num_classes;\n  TF_LITE_ENSURE(context, num_detections_per_class > 0);\n\n   std::vector<float> class_scores(num_boxes);\n\n  std::vector<int> box_indices_after_regular_non_max_suppression(\n      num_boxes + max_detections);\n  std::vector<float> scores_after_regular_non_max_suppression(num_boxes +\n                                                              max_detections);\n\n  int size_of_sorted_indices = 0;\n  std::vector<int> sorted_indices;\n  sorted_indices.resize(num_boxes + max_detections);\n  std::vector<float> sorted_values;\n  sorted_values.resize(max_detections);\n\n  for (int col = 0; col < num_classes; col++) {\n    for (int row = 0; row < num_boxes; row++) {\n           class_scores[row] =\n          *(scores + row * num_classes_with_background + col + label_offset);\n    }\n       std::vector<int> selected;\n    TF_LITE_ENSURE_STATUS(NonMaxSuppressionSingleClassHelper(\n        context, node, op_data, class_scores, &selected,\n        num_detections_per_class));\n       int output_index = size_of_sorted_indices;\n    for (const auto& selected_index : selected) {\n      box_indices_after_regular_non_max_suppression[output_index] =\n          (selected_index * num_classes_with_background + col + label_offset);\n      scores_after_regular_non_max_suppression[output_index] =\n          class_scores[selected_index];\n      output_index++;\n    }\n          int num_indices_to_sort = std::min(output_index, max_detections);\n    DecreasingPartialArgSort(scores_after_regular_non_max_suppression.data(),\n                             output_index, num_indices_to_sort,\n                             sorted_indices.data());\n\n       for (int row = 0; row < num_indices_to_sort; row++) {\n      int temp = sorted_indices[row];\n      sorted_indices[row] = box_indices_after_regular_non_max_suppression[temp];\n      sorted_values[row] = scores_after_regular_non_max_suppression[temp];\n    }\n       for (int row = 0; row < num_indices_to_sort; row++) {\n      box_indices_after_regular_non_max_suppression[row] = sorted_indices[row];\n      scores_after_regular_non_max_suppression[row] = sorted_values[row];\n    }\n    size_of_sorted_indices = num_indices_to_sort;\n  }\n\n   for (int output_box_index = 0; output_box_index < max_detections;\n       output_box_index++) {\n    if (output_box_index < size_of_sorted_indices) {\n      const int anchor_index = floor(\n          box_indices_after_regular_non_max_suppression[output_box_index] /\n          num_classes_with_background);\n      const int class_index =\n          box_indices_after_regular_non_max_suppression[output_box_index] -\n          anchor_index * num_classes_with_background - label_offset;\n      const float selected_score =\n          scores_after_regular_non_max_suppression[output_box_index];\n           ReInterpretTensor<BoxCornerEncoding*>(detection_boxes)[output_box_index] =\n          ReInterpretTensor<const BoxCornerEncoding*>(\n              decoded_boxes)[anchor_index];\n           GetTensorData<float>(detection_classes)[output_box_index] = class_index;\n           GetTensorData<float>(detection_scores)[output_box_index] = selected_score;\n    } else {\n      ReInterpretTensor<BoxCornerEncoding*>(\n          detection_boxes)[output_box_index] = {0.0f, 0.0f, 0.0f, 0.0f};\n           GetTensorData<float>(detection_classes)[output_box_index] = 0.0f;\n           GetTensorData<float>(detection_scores)[output_box_index] = 0.0f;\n    }\n  }\n  GetTensorData<float>(num_detections)[0] = size_of_sorted_indices;\n  box_indices_after_regular_non_max_suppression.clear();\n  scores_after_regular_non_max_suppression.clear();\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nINTERNAL void vterm_allocator_free(VTerm *vt, void *ptr)\n{\n  (*vt->allocator->free)(ptr, vt->allocdata);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nlookup_bytestring(netdissect_options *ndo, register const u_char *bs,\n\t\t  const unsigned int nlen)\n{\n\tstruct enamemem *tp;\n\tregister u_int i, j, k;\n\n\tif (nlen >= 6) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = (bs[4] << 8) | bs[5];\n\t} else if (nlen >= 4) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = 0;\n\t} else\n\t\ti = j = k = 0;\n\n\ttp = &bytestringtable[(i ^ j) & (HASHNAMESIZE-1)];\n\twhile (tp->e_nxt)\n\t\tif (tp->e_addr0 == i &&\n\t\t    tp->e_addr1 == j &&\n\t\t    tp->e_addr2 == k &&\n\t\t    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)\n\t\t\treturn tp;\n\t\telse\n\t\t\ttp = tp->e_nxt;\n\n\ttp->e_addr0 = i;\n\ttp->e_addr1 = j;\n\ttp->e_addr2 = k;\n\n\ttp->e_bs = (u_char *) calloc(1, nlen + 1);\n\tif (tp->e_bs == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\n\tmemcpy(tp->e_bs, bs, nlen);\n\ttp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));\n\tif (tp->e_nxt == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\n\treturn tp;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPHP_FUNCTION(locale_get_all_variants)\n{\n\tconst char*  \tloc_name        = NULL;\n\tint    \t\tloc_name_len    = 0;\n\n\tint\tresult\t\t= 0;\n\tchar*\ttoken\t\t= NULL;\n\tchar*\tvariant\t\t= NULL;\n\tchar*\tsaved_ptr\t= NULL;\n\n\tintl_error_reset( NULL TSRMLS_CC );\n\t\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n\t&loc_name, &loc_name_len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t     \"locale_parse: unable to parse input params\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif(loc_name_len == 0) {\n\t\tloc_name = intl_locale_get_default(TSRMLS_C);\n\t}\n\n\n\tarray_init( return_value );\n\n\t\n\tif( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){ \n\t\t\n\t}\n\telse {\t\n\t\n\t\tvariant = get_icu_value_internal( loc_name , LOC_VARIANT_TAG , &result ,0);\n\t\tif( result > 0 && variant){\n\t\t\t\n\t\t\ttoken = php_strtok_r( variant , DELIMITER , &saved_ptr);\t\n\t\t\tadd_next_index_stringl( return_value, token , strlen(token) ,TRUE );\n\t\t\t\n\t\t\twhile( (token = php_strtok_r(NULL , DELIMITER, &saved_ptr)) && (strlen(token)>1) ){\n \t\t\t\tadd_next_index_stringl( return_value, token , strlen(token) ,TRUE );\n\t\t\t}\n\t\t}\n\t\tif( variant ){\n\t\t\tefree( variant );\n\t\t}\n\t}\n\t\t\t\n\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\t\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "NULL Pointer Dereference"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tStream_Write_UINT8(s, brush->x);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Write_UINT8(s, brush->data[7]);\n\t\tStream_Write_UINT8(s, brush->data[6]);\n\t\tStream_Write_UINT8(s, brush->data[5]);\n\t\tStream_Write_UINT8(s, brush->data[4]);\n\t\tStream_Write_UINT8(s, brush->data[3]);\n\t\tStream_Write_UINT8(s, brush->data[2]);\n\t\tStream_Write_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\n\treturn TRUE;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int __vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\tr = vapic_enter(vcpu);\n\tif (r) {\n\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\treturn r;\n\t}\n\n\tr = 1;\n\twhile (r > 0) {\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t    !vcpu->arch.apf.halted)\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\telse {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_vcpu_block(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t\tif (kvm_check_request(KVM_REQ_UNHALT, vcpu)) {\n\t\t\t\tkvm_apic_accept_events(vcpu);\n\t\t\t\tswitch(vcpu->arch.mp_state) {\n\t\t\t\tcase KVM_MP_STATE_HALTED:\n\t\t\t\t\tvcpu->arch.pv.pv_unhalted = false;\n\t\t\t\t\tvcpu->arch.mp_state =\n\t\t\t\t\t\tKVM_MP_STATE_RUNNABLE;\n\t\t\t\tcase KVM_MP_STATE_RUNNABLE:\n\t\t\t\t\tvcpu->arch.apf.halted = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tr = -EINTR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (r <= 0)\n\t\t\tbreak;\n\n\t\tclear_bit(KVM_REQ_PENDING_TIMER, &vcpu->requests);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\n\t\tif (dm_request_for_irq_injection(vcpu)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t}\n\n\t\tkvm_check_async_pf_completion(vcpu);\n\n\t\tif (signal_pending(current)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.signal_exits;\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_resched(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t}\n\t}\n\n\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\n\tvapic_exit(vcpu);\n\n\treturn r;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid enc624j600WritePhyReg(NetInterface *interface, uint8_t address,\n   uint16_t data)\n{\n     enc624j600WriteReg(interface, ENC624J600_REG_MIREGADR, MIREGADR_R8 | address);\n     enc624j600WriteReg(interface, ENC624J600_REG_MIWR, data);\n\n     while((enc624j600ReadReg(interface, ENC624J600_REG_MISTAT) & MISTAT_BUSY) != 0)\n   {\n   }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t     struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct iucv_sock *iucv = iucv_sk(sk);\n\tunsigned int copied, rlen;\n\tstruct sk_buff *skb, *rskb, *cskb;\n\tint err = 0;\n\tu32 offset;\n\n\tmsg->msg_namelen = 0;\n\n\tif ((sk->sk_state == IUCV_DISCONN) &&\n\t    skb_queue_empty(&iucv->backlog_skb_q) &&\n\t    skb_queue_empty(&sk->sk_receive_queue) &&\n\t    list_empty(&iucv->message_q.list))\n\t\treturn 0;\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\t\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\toffset = IUCV_SKB_CB(skb)->offset;\n\trlen   = skb->len - offset;\t\t\n\tcopied = min_t(unsigned int, rlen, len);\n\tif (!rlen)\n\t\tsk->sk_shutdown = sk->sk_shutdown | RCV_SHUTDOWN;\n\n\tcskb = skb;\n\tif (skb_copy_datagram_iovec(cskb, offset, msg->msg_iov, copied)) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -EFAULT;\n\t}\n\n\t\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tif (copied < rlen)\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\t\n\t\tmsg->msg_flags |= MSG_EOR;\n\t}\n\n\t\n\terr = put_cmsg(msg, SOL_IUCV, SCM_IUCV_TRGCLS,\n\t\t       sizeof(IUCV_SKB_CB(skb)->class),\n\t\t       (void *)&IUCV_SKB_CB(skb)->class);\n\tif (err) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn err;\n\t}\n\n\t\n\tif (!(flags & MSG_PEEK)) {\n\n\t\t\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tif (copied < rlen) {\n\t\t\t\tIUCV_SKB_CB(skb)->offset = offset + copied;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tkfree_skb(skb);\n\t\tif (iucv->transport == AF_IUCV_TRANS_HIPER) {\n\t\t\tatomic_inc(&iucv->msg_recv);\n\t\t\tif (atomic_read(&iucv->msg_recv) > iucv->msglimit) {\n\t\t\t\tWARN_ON(1);\n\t\t\t\tiucv_sock_close(sk);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tspin_lock_bh(&iucv->message_q.lock);\n\t\trskb = skb_dequeue(&iucv->backlog_skb_q);\n\t\twhile (rskb) {\n\t\t\tIUCV_SKB_CB(rskb)->offset = 0;\n\t\t\tif (sock_queue_rcv_skb(sk, rskb)) {\n\t\t\t\tskb_queue_head(&iucv->backlog_skb_q,\n\t\t\t\t\t\trskb);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\trskb = skb_dequeue(&iucv->backlog_skb_q);\n\t\t\t}\n\t\t}\n\t\tif (skb_queue_empty(&iucv->backlog_skb_q)) {\n\t\t\tif (!list_empty(&iucv->message_q.list))\n\t\t\t\tiucv_process_message_q(sk);\n\t\t\tif (atomic_read(&iucv->msg_recv) >=\n\t\t\t\t\t\t\tiucv->msglimit / 2) {\n\t\t\t\terr = iucv_send_ctrl(sk, AF_IUCV_FLAG_WIN);\n\t\t\t\tif (err) {\n\t\t\t\t\tsk->sk_state = IUCV_DISCONN;\n\t\t\t\t\tsk->sk_state_change(sk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&iucv->message_q.lock);\n\t}\n\ndone:\n\t\n\tif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))\n\t\tcopied = rlen;\n\n\treturn copied;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nast_for_trailer(struct compiling *c, const node *n, expr_ty left_expr)\n{\n    \n    REQ(n, trailer);\n    if (TYPE(CHILD(n, 0)) == LPAR) {\n        if (NCH(n) == 2)\n            return Call(left_expr, NULL, NULL, LINENO(n),\n                        n->n_col_offset, c->c_arena);\n        else\n            return ast_for_call(c, CHILD(n, 1), left_expr);\n    }\n    else if (TYPE(CHILD(n, 0)) == DOT) {\n        PyObject *attr_id = NEW_IDENTIFIER(CHILD(n, 1));\n        if (!attr_id)\n            return NULL;\n        return Attribute(left_expr, attr_id, Load,\n                         LINENO(n), n->n_col_offset, c->c_arena);\n    }\n    else {\n        REQ(CHILD(n, 0), LSQB);\n        REQ(CHILD(n, 2), RSQB);\n        n = CHILD(n, 1);\n        if (NCH(n) == 1) {\n            slice_ty slc = ast_for_slice(c, CHILD(n, 0));\n            if (!slc)\n                return NULL;\n            return Subscript(left_expr, slc, Load, LINENO(n), n->n_col_offset,\n                             c->c_arena);\n        }\n        else {\n            \n            int j;\n            slice_ty slc;\n            expr_ty e;\n            int simple = 1;\n            asdl_seq *slices, *elts;\n            slices = _Ta3_asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);\n            if (!slices)\n                return NULL;\n            for (j = 0; j < NCH(n); j += 2) {\n                slc = ast_for_slice(c, CHILD(n, j));\n                if (!slc)\n                    return NULL;\n                if (slc->kind != Index_kind)\n                    simple = 0;\n                asdl_seq_SET(slices, j / 2, slc);\n            }\n            if (!simple) {\n                return Subscript(left_expr, ExtSlice(slices, c->c_arena),\n                                 Load, LINENO(n), n->n_col_offset, c->c_arena);\n            }\n            \n            elts = _Ta3_asdl_seq_new(asdl_seq_LEN(slices), c->c_arena);\n            if (!elts)\n                return NULL;\n            for (j = 0; j < asdl_seq_LEN(slices); ++j) {\n                slc = (slice_ty)asdl_seq_GET(slices, j);\n                assert(slc->kind == Index_kind  && slc->v.Index.value);\n                asdl_seq_SET(elts, j, slc->v.Index.value);\n            }\n            e = Tuple(elts, Load, LINENO(n), n->n_col_offset, c->c_arena);\n            if (!e)\n                return NULL;\n            return Subscript(left_expr, Index(e, c->c_arena),\n                             Load, LINENO(n), n->n_col_offset, c->c_arena);\n        }\n    }\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void binder_deferred_fd_close(int fd)\n{\n\tstruct binder_task_work_cb *twcb;\n\n\ttwcb = kzalloc(sizeof(*twcb), GFP_KERNEL);\n\tif (!twcb)\n\t\treturn;\n\tinit_task_work(&twcb->twork, binder_do_fd_close);\n\t__close_fd_get_file(fd, &twcb->file);\n\tif (twcb->file)\n\t\ttask_work_add(current, &twcb->twork, TWA_RESUME);\n\telse\n\t\tkfree(twcb);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid jas_matrix_divpow2(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = (*data >= 0) ? ((*data) >> n) :\n\t\t\t\t  (-((-(*data)) >> n));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Integer Overflow"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid RegKey::setBinary(const TCHAR* valname, const void* value, int length) const {\n  LONG result = RegSetValueEx(key, valname, 0, REG_BINARY, (const BYTE*)value, length);\n  if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setBinary\", result);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void bt_tags_for_each(struct blk_mq_tags *tags,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_tag_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\n\tif (!tags->rqs)\n\t\treturn;\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t\trq = blk_mq_tag_to_rq(tags, off + bit);\n\t\t\tfn(rq, data, reserved);\n\t\t}\n\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\n    int overrun(int itemSize, int nItems) {\n      int len = ptr - start + itemSize * nItems;\n      if (len < (end - start) * 2)\n        len = (end - start) * 2;\n\n      U8* newStart = new U8[len];\n      memcpy(newStart, start, ptr - start);\n      ptr = newStart + (ptr - start);\n      delete [] start;\n      start = newStart;\n      end = newStart + len;\n\n      return nItems;\n    }\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Write"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nsmbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n{\n\tint rc;\n\tunsigned char key2[8];\n\tstruct crypto_skcipher *tfm_des;\n\tstruct scatterlist sgin, sgout;\n\tstruct skcipher_request *req;\n\n\tstr_to_key(key, key2);\n\n\ttfm_des = crypto_alloc_skcipher(\"ecb(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm_des)) {\n\t\trc = PTR_ERR(tfm_des);\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_err;\n\t}\n\n\treq = skcipher_request_alloc(tfm_des, GFP_KERNEL);\n\tif (!req) {\n\t\trc = -ENOMEM;\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_free_skcipher;\n\t}\n\n\tcrypto_skcipher_setkey(tfm_des, key2, 8);\n\n\tsg_init_one(&sgin, in, 8);\n\tsg_init_one(&sgout, out, 8);\n\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);\n\n\trc = crypto_skcipher_encrypt(req);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"could not encrypt crypt key rc: %d\\n\", rc);\n\n\tskcipher_request_free(req);\n\nsmbhash_free_skcipher:\n\tcrypto_free_skcipher(tfm_des);\nsmbhash_err:\n\treturn rc;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* data =\n      reinterpret_cast<TfLiteAudioMicrofrontendParams*>(node->user_data);\n  FrontendReset(data->state);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (data->out_float) {\n    GenerateFeatures<float>(data, input, output);\n  } else {\n    GenerateFeatures<int32>(data, input, output);\n  }\n\n  return kTfLiteOk;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void ttm_put_pages(struct page **pages, unsigned npages, int flags,\n\t\t\t  enum ttm_caching_state cstate)\n{\n\tstruct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tstruct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate);\n#endif\n\tunsigned long irq_flags;\n\tunsigned i;\n\n\tif (pool == NULL) {\n\t\t\n\t\ti = 0;\n\t\twhile (i < npages) {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tstruct page *p = pages[i];\n#endif\n\t\t\tunsigned order = 0, j;\n\n\t\t\tif (!pages[i]) {\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tif (!(flags & TTM_PAGE_FLAG_DMA32) &&\n\t\t\t    (npages - i) >= HPAGE_PMD_NR) {\n\t\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t\t    break;\n\n\t\t\t\tif (j == HPAGE_PMD_NR)\n\t\t\t\t\torder = HPAGE_PMD_ORDER;\n\t\t\t}\n#endif\n\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\t__free_pages(pages[i], order);\n\n\t\t\tj = 1 << order;\n\t\t\twhile (j) {\n\t\t\t\tpages[i++] = NULL;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\ti = 0;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (huge) {\n\t\tunsigned max_size, n2free;\n\n\t\tspin_lock_irqsave(&huge->lock, irq_flags);\n\t\twhile ((npages - i) >= HPAGE_PMD_NR) {\n\t\t\tstruct page *p = pages[i];\n\t\t\tunsigned j;\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t    break;\n\n\t\t\tif (j != HPAGE_PMD_NR)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&pages[i]->lru, &huge->list);\n\n\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tpages[i++] = NULL;\n\t\t\thuge->npages++;\n\t\t}\n\n\t\t\n\t\tmax_size = _manager->options.max_size;\n\t\tmax_size /= HPAGE_PMD_NR;\n\t\tif (huge->npages > max_size)\n\t\t\tn2free = huge->npages - max_size;\n\t\telse\n\t\t\tn2free = 0;\n\t\tspin_unlock_irqrestore(&huge->lock, irq_flags);\n\t\tif (n2free)\n\t\t\tttm_page_pool_free(huge, n2free, false);\n\t}\n#endif\n\n\tspin_lock_irqsave(&pool->lock, irq_flags);\n\twhile (i < npages) {\n\t\tif (pages[i]) {\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\tlist_add_tail(&pages[i]->lru, &pool->list);\n\t\t\tpages[i] = NULL;\n\t\t\tpool->npages++;\n\t\t}\n\t\t++i;\n\t}\n\t\n\tnpages = 0;\n\tif (pool->npages > _manager->options.max_size) {\n\t\tnpages = pool->npages - _manager->options.max_size;\n\t\t\n\t\tif (npages < NUM_PAGES_TO_ALLOC)\n\t\t\tnpages = NUM_PAGES_TO_ALLOC;\n\t}\n\tspin_unlock_irqrestore(&pool->lock, irq_flags);\n\tif (npages)\n\t\tttm_page_pool_free(pool, npages, false);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nZEND_API void zend_objects_store_del_ref_by_handle_ex(zend_object_handle handle, const zend_object_handlers *handlers TSRMLS_DC) \n{\n\tstruct _store_object *obj;\n\tint failure = 0;\n\n\tif (!EG(objects_store).object_buckets) {\n\t\treturn;\n\t}\n\n\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\n\t\n\tif (EG(objects_store).object_buckets[handle].valid) {\n\t\tif (obj->refcount == 1) {\n\t\t\tif (!EG(objects_store).object_buckets[handle].destructor_called) {\n\t\t\t\tEG(objects_store).object_buckets[handle].destructor_called = 1;\n\n\t\t\t\tif (obj->dtor) {\n\t\t\t\t\tif (handlers && !obj->handlers) {\n\t\t\t\t\t\tobj->handlers = handlers;\n\t\t\t\t\t}\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->dtor(obj->object, handle TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\n\t\t\tif (obj->refcount == 1) {\n\t\t\t\tGC_REMOVE_ZOBJ_FROM_BUFFER(obj);\n\t\t\t\tif (obj->free_storage) {\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->free_storage(obj->object TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t\tZEND_OBJECTS_STORE_ADD_TO_FREE_LIST();\n\t\t\t}\n\t\t}\n\t}\n\n\tobj->refcount--;\n\n#if ZEND_DEBUG_OBJECTS\n\tif (obj->refcount == 0) {\n\t\tfprintf(stderr, \"Deallocated object id #%d\\n\", handle);\n\t} else {\n\t\tfprintf(stderr, \"Decreased refcount of object id #%d\\n\", handle);\n\t}\n#endif\n\tif (failure) {\n\t\tzend_bailout();\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,\n\t\t\tstruct nci_rf_intf_activated_ntf *ntf, __u8 *data)\n{\n\tstruct activation_params_nfca_poll_iso_dep *nfca_poll;\n\tstruct activation_params_nfcb_poll_iso_dep *nfcb_poll;\n\n\tswitch (ntf->activation_rf_tech_and_mode) {\n\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\t\tnfca_poll = &ntf->activation_params.nfca_poll_iso_dep;\n\t\tnfca_poll->rats_res_len = *data++;\n\t\tpr_debug(\"rats_res_len %d\\n\", nfca_poll->rats_res_len);\n\t\tif (nfca_poll->rats_res_len > 0) {\n\t\t\tmemcpy(nfca_poll->rats_res,\n\t\t\t       data, nfca_poll->rats_res_len);\n\t\t}\n\t\tbreak;\n\n\tcase NCI_NFC_B_PASSIVE_POLL_MODE:\n\t\tnfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;\n\t\tnfcb_poll->attrib_res_len = *data++;\n\t\tpr_debug(\"attrib_res_len %d\\n\", nfcb_poll->attrib_res_len);\n\t\tif (nfcb_poll->attrib_res_len > 0) {\n\t\t\tmemcpy(nfcb_poll->attrib_res,\n\t\t\t       data, nfcb_poll->attrib_res_len);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t       ntf->activation_rf_tech_and_mode);\n\t\treturn NCI_STATUS_RF_PROTOCOL_ERROR;\n\t}\n\n\treturn NCI_STATUS_OK;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint bt_sock_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tsize_t target, copied = 0;\n\tlong timeo;\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg->msg_namelen = 0;\n\n\tBT_DBG(\"sk %p size %zu\", sk, size);\n\n\tlock_sock(sk);\n\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\n\ttimeo  = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\n\tdo {\n\t\tstruct sk_buff *skb;\n\t\tint chunk;\n\n\t\tskb = skb_dequeue(&sk->sk_receive_queue);\n\t\tif (!skb) {\n\t\t\tif (copied >= target)\n\t\t\t\tbreak;\n\n\t\t\terr = sock_error(sk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\n\t\t\terr = -EAGAIN;\n\t\t\tif (!timeo)\n\t\t\t\tbreak;\n\n\t\t\ttimeo = bt_sock_data_wait(sk, timeo);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = sock_intr_errno(timeo);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tchunk = min_t(unsigned int, skb->len, size);\n\t\tif (skb_copy_datagram_iovec(skb, 0, msg->msg_iov, chunk)) {\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += chunk;\n\t\tsize   -= chunk;\n\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tint skb_len = skb_headlen(skb);\n\n\t\t\tif (chunk <= skb_len) {\n\t\t\t\t__skb_pull(skb, chunk);\n\t\t\t} else {\n\t\t\t\tstruct sk_buff *frag;\n\n\t\t\t\t__skb_pull(skb, skb_len);\n\t\t\t\tchunk -= skb_len;\n\n\t\t\t\tskb_walk_frags(skb, frag) {\n\t\t\t\t\tif (chunk <= frag->len) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tskb->len -= chunk;\n\t\t\t\t\t\tskb->data_len -= chunk;\n\t\t\t\t\t\t__skb_pull(frag, chunk);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (frag->len) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tchunk -= frag->len;\n\t\t\t\t\t\tskb->len -= frag->len;\n\t\t\t\t\t\tskb->data_len -= frag->len;\n\t\t\t\t\t\t__skb_pull(frag, frag->len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkfree_skb(skb);\n\n\t\t} else {\n\t\t\t\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\tbreak;\n\t\t}\n\t} while (size);\n\nout:\n\trelease_sock(sk);\n\treturn copied ? : err;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t  struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sockaddr_llc *uaddr = (struct sockaddr_llc *)msg->msg_name;\n\tconst int nonblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb = NULL;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tunsigned long cpu_flags;\n\tsize_t copied = 0;\n\tu32 peek_seq = 0;\n\tu32 *seq;\n\tunsigned long used;\n\tint target;\t\n\tlong timeo;\n\n\tmsg->msg_namelen = 0;\n\n\tlock_sock(sk);\n\tcopied = -ENOTCONN;\n\tif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))\n\t\tgoto out;\n\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n\n\tseq = &llc->copied_seq;\n\tif (flags & MSG_PEEK) {\n\t\tpeek_seq = llc->copied_seq;\n\t\tseq = &peek_seq;\n\t}\n\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\tcopied = 0;\n\n\tdo {\n\t\tu32 offset;\n\n\t\t\n\t\tif (signal_pending(current)) {\n\t\t\tif (copied)\n\t\t\t\tbreak;\n\t\t\tcopied = timeo ? sock_intr_errno(timeo) : -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb) {\n\t\t\toffset = *seq;\n\t\t\tgoto found_ok_skb;\n\t\t}\n\t\t\n\n\t\tif (copied >= target && !sk->sk_backlog.tail)\n\t\t\tbreak;\n\n\t\tif (copied) {\n\t\t\tif (sk->sk_err ||\n\t\t\t    sk->sk_state == TCP_CLOSE ||\n\t\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t\t    !timeo ||\n\t\t\t    (flags & MSG_PEEK))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_err) {\n\t\t\t\tcopied = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_CLOSE) {\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE)) {\n\t\t\t\t\t\n\t\t\t\t\tcopied = -ENOTCONN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n\t\t\t\tcopied = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (copied >= target) { \n\t\t\trelease_sock(sk);\n\t\t\tlock_sock(sk);\n\t\t} else\n\t\t\tsk_wait_data(sk, &timeo);\n\n\t\tif ((flags & MSG_PEEK) && peek_seq != llc->copied_seq) {\n\t\t\tnet_dbg_ratelimited(\"LLC(%s:%d): Application bug, race in MSG_PEEK\\n\",\n\t\t\t\t\t    current->comm,\n\t\t\t\t\t    task_pid_nr(current));\n\t\t\tpeek_seq = llc->copied_seq;\n\t\t}\n\t\tcontinue;\n\tfound_ok_skb:\n\t\t\n\t\tused = skb->len - offset;\n\t\tif (len < used)\n\t\t\tused = len;\n\n\t\tif (!(flags & MSG_TRUNC)) {\n\t\t\tint rc = skb_copy_datagram_iovec(skb, offset,\n\t\t\t\t\t\t\t msg->msg_iov, used);\n\t\t\tif (rc) {\n\t\t\t\t\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t*seq += used;\n\t\tcopied += used;\n\t\tlen -= used;\n\n\t\t\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\tgoto copy_uaddr;\n\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tspin_lock_irqsave(&sk->sk_receive_queue.lock, cpu_flags);\n\t\t\tsk_eat_skb(sk, skb, false);\n\t\t\tspin_unlock_irqrestore(&sk->sk_receive_queue.lock, cpu_flags);\n\t\t\t*seq = 0;\n\t\t}\n\n\t\t\n\t\tif (used + offset < skb->len)\n\t\t\tcontinue;\n\t} while (len > 0);\n\nout:\n\trelease_sock(sk);\n\treturn copied;\ncopy_uaddr:\n\tif (uaddr != NULL && skb != NULL) {\n\t\tmemcpy(uaddr, llc_ui_skb_cb(skb), sizeof(*uaddr));\n\t\tmsg->msg_namelen = sizeof(*uaddr);\n\t}\n\tif (llc_sk(sk)->cmsg_flags)\n\t\tllc_cmsg_rcv(msg, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\t\tspin_lock_irqsave(&sk->sk_receive_queue.lock, cpu_flags);\n\t\t\tsk_eat_skb(sk, skb, false);\n\t\t\tspin_unlock_irqrestore(&sk->sk_receive_queue.lock, cpu_flags);\n\t\t\t*seq = 0;\n\t}\n\n\tgoto out;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nheader_put_byte (SF_PRIVATE *psf, char x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 1)\n\t\tpsf->header [psf->headindex++] = x ;\n} \n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nPHP_FUNCTION(locale_get_display_variant) \n{\n    get_icu_disp_value_src_php( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nint ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)\n{\n\tkuid_t euid;\n\tkgid_t egid;\n\tint id;\n\tint next_id = ids->next_id;\n\n\tif (size > IPCMNI)\n\t\tsize = IPCMNI;\n\n\tif (ids->in_use >= size)\n\t\treturn -ENOSPC;\n\n\tidr_preload(GFP_KERNEL);\n\n\tspin_lock_init(&new->lock);\n\tnew->deleted = false;\n\trcu_read_lock();\n\tspin_lock(&new->lock);\n\n\tid = idr_alloc(&ids->ipcs_idr, new,\n\t\t       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,\n\t\t       GFP_NOWAIT);\n\tidr_preload_end();\n\tif (id < 0) {\n\t\tspin_unlock(&new->lock);\n\t\trcu_read_unlock();\n\t\treturn id;\n\t}\n\n\tids->in_use++;\n\n\tcurrent_euid_egid(&euid, &egid);\n\tnew->cuid = new->uid = euid;\n\tnew->gid = new->cgid = egid;\n\n\tif (next_id < 0) {\n\t\tnew->seq = ids->seq++;\n\t\tif (ids->seq > IPCID_SEQ_MAX)\n\t\t\tids->seq = 0;\n\t} else {\n\t\tnew->seq = ipcid_to_seqx(next_id);\n\t\tids->next_id = -1;\n\t}\n\n\tnew->id = ipc_buildid(id, new->seq);\n\treturn id;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Race Condition or Concurrent Execution using Shared Resource with Improper Synchronization"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstatic void f2fs_put_super(struct super_block *sb)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tint i;\n\n\tf2fs_quota_off_umount(sb);\n\n\t\n\tmutex_lock(&sbi->umount_mutex);\n\n\t\n\tif (is_sbi_flag_set(sbi, SBI_IS_DIRTY) ||\n\t\t\t!is_set_ckpt_flags(sbi, CP_UMOUNT_FLAG)) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_UMOUNT,\n\t\t};\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\n\t\n\tf2fs_wait_discard_bios(sbi);\n\n\tif (f2fs_discard_en(sbi) && !sbi->discard_blks) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_UMOUNT | CP_TRIMMED,\n\t\t};\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\n\t\n\tf2fs_destroy_stats(sbi);\n\n\t\n\trelease_ino_entry(sbi, true);\n\n\tf2fs_leave_shrinker(sbi);\n\tmutex_unlock(&sbi->umount_mutex);\n\n\t\n\tf2fs_flush_merged_writes(sbi);\n\n\tiput(sbi->node_inode);\n\tiput(sbi->meta_inode);\n\n\t\n\tdestroy_node_manager(sbi);\n\tdestroy_segment_manager(sbi);\n\n\tkfree(sbi->ckpt);\n\n\tf2fs_unregister_sysfs(sbi);\n\n\tsb->s_fs_info = NULL;\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\tkfree(sbi->raw_super);\n\n\tdestroy_device_list(sbi);\n\tmempool_destroy(sbi->write_io_dummy);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\tdestroy_percpu_info(sbi);\n\tfor (i = 0; i < NR_PAGE_TYPE; i++)\n\t\tkfree(sbi->write_io[i]);\n\tkfree(sbi);\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Improper Input Validation"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nstruct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\n\tif (id < 0)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\n\treturn peer;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Use After Free"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nindenterror(struct tok_state *tok)\n{\n    if (tok->alterror) {\n        tok->done = E_TABSPACE;\n        tok->cur = tok->inp;\n        return 1;\n    }\n    if (tok->altwarning) {\n#ifdef PGEN\n        PySys_WriteStderr(\"inconsistent use of tabs and spaces \"\n                          \"in indentation\\n\");\n#else\n        PySys_FormatStderr(\"%U: inconsistent use of tabs and spaces \"\n                          \"in indentation\\n\", tok->filename);\n#endif\n        tok->altwarning = 0;\n    }\n    return 0;\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
{"code": "\nIs the following code snippet prone to any security vulnerability?\n\n```\nvoid __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct scm_timestamping tss;\n\tint empty = 1;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\n\t\n\tif (need_software_tstamp && skb->tstamp == 0)\n\t\t__net_timestamp(skb);\n\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tskb_get_timestampns(skb, &ts);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts), &ts);\n\t\t}\n\t}\n\n\tmemset(&tss, 0, sizeof(tss));\n\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&\n\t    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))\n\t\tempty = 0;\n\tif (shhwtstamps &&\n\t    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&\n\t    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))\n\t\tempty = 0;\n\tif (!empty) {\n\t\tput_cmsg(msg, SOL_SOCKET,\n\t\t\t SCM_TIMESTAMPING, sizeof(tss), &tss);\n\n\t\tif (skb->len && (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS))\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n\t\t\t\t skb->len, skb->data);\n\t}\n}\n```\n\nResponse:\n", "label": true, "cwe_name": "Out-of-bounds Read"}
